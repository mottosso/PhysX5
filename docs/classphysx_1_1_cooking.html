<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PhysX: physx::Cooking Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PhysX<span id="projectnumber">&#160;5.1.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classphysx_1_1_cooking.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classphysx_1_1_cooking-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">physx::Cooking Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for physx::Cooking:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classphysx_1_1_cooking.png" usemap="#physx::Cooking_map" alt=""/>
  <map id="physx::Cooking_map" name="physx::Cooking_map">
<area href="classphysx_1_1_px_cooking.html" title="Provides methods to cook (where cooking means to prepare the data and convert it to the right format ..." alt="physx::PxCooking" shape="rect" coords="0,0,144,24"/>
<area href="classphysx_1_1_px_user_allocated.html" alt="physx::PxUserAllocated" shape="rect" coords="154,0,298,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a288faab4c605c899def3428247746a8d"><td class="memItemLeft" align="right" valign="top"><a id="a288faab4c605c899def3428247746a8d" name="a288faab4c605c899def3428247746a8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Cooking</b> (const <a class="el" href="structphysx_1_1_px_cooking_params.html">PxCookingParams</a> &amp;params)</td></tr>
<tr class="separator:a288faab4c605c899def3428247746a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb06fed2e722ef09ca68ff622791358"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#aacb06fed2e722ef09ca68ff622791358">release</a> ()</td></tr>
<tr class="memdesc:aacb06fed2e722ef09ca68ff622791358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes this instance of the interface.  <br /></td></tr>
<tr class="separator:aacb06fed2e722ef09ca68ff622791358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f224fec665d86d454750c583d1136"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a678f224fec665d86d454750c583d1136">setParams</a> (const <a class="el" href="structphysx_1_1_px_cooking_params.html">PxCookingParams</a> &amp;params)</td></tr>
<tr class="memdesc:a678f224fec665d86d454750c583d1136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets cooking parameters.  <br /></td></tr>
<tr class="separator:a678f224fec665d86d454750c583d1136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a1def0096fd40e460622e3fa8ca01b"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structphysx_1_1_px_cooking_params.html">PxCookingParams</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a96a1def0096fd40e460622e3fa8ca01b">getParams</a> () const</td></tr>
<tr class="memdesc:a96a1def0096fd40e460622e3fa8ca01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets cooking parameters.  <br /></td></tr>
<tr class="separator:a96a1def0096fd40e460622e3fa8ca01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23220df7ab1558e1e7dcec7371c0946"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#ac23220df7ab1558e1e7dcec7371c0946">platformMismatch</a> () const</td></tr>
<tr class="memdesc:ac23220df7ab1558e1e7dcec7371c0946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks endianness is the same between cooking &amp; target platforms.  <br /></td></tr>
<tr class="separator:ac23220df7ab1558e1e7dcec7371c0946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef225a197658f28c6f1e48bbbb90b12"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a3ef225a197658f28c6f1e48bbbb90b12">cookTriangleMesh</a> (const <a class="el" href="classphysx_1_1_px_triangle_mesh_desc.html">PxTriangleMeshDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream, <a class="el" href="structphysx_1_1_px_triangle_mesh_cooking_result.html#a50ce7fe0985bc16734a32e9753ba7a5e">PxTriangleMeshCookingResult::Enum</a> *condition=NULL) const</td></tr>
<tr class="memdesc:a3ef225a197658f28c6f1e48bbbb90b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a triangle mesh. The results are written to the stream.  <br /></td></tr>
<tr class="separator:a3ef225a197658f28c6f1e48bbbb90b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0975d9f9bb7a88b47338ccc5ac89e5e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_triangle_mesh.html">PxTriangleMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a0975d9f9bb7a88b47338ccc5ac89e5e6">createTriangleMesh</a> (const <a class="el" href="classphysx_1_1_px_triangle_mesh_desc.html">PxTriangleMeshDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback, <a class="el" href="structphysx_1_1_px_triangle_mesh_cooking_result.html#a50ce7fe0985bc16734a32e9753ba7a5e">PxTriangleMeshCookingResult::Enum</a> *condition=NULL) const</td></tr>
<tr class="memdesc:a0975d9f9bb7a88b47338ccc5ac89e5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a triangle mesh without going through a stream.  <br /></td></tr>
<tr class="separator:a0975d9f9bb7a88b47338ccc5ac89e5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322a7e6099be73fd4222f84abc39c001"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a322a7e6099be73fd4222f84abc39c001">validateTriangleMesh</a> (const <a class="el" href="classphysx_1_1_px_triangle_mesh_desc.html">PxTriangleMeshDesc</a> &amp;desc) const</td></tr>
<tr class="memdesc:a322a7e6099be73fd4222f84abc39c001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found.  <br /></td></tr>
<tr class="separator:a322a7e6099be73fd4222f84abc39c001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3473885e221c2cbacd7c3ee48b3b7dc2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a3473885e221c2cbacd7c3ee48b3b7dc2">cookSoftBodyMesh</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;simulationMeshDesc, const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;collisionMeshDesc, const <a class="el" href="classphysx_1_1_px_soft_body_simulation_data_desc.html">PxSoftBodySimulationDataDesc</a> &amp;softbodyDataDesc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream) const</td></tr>
<tr class="memdesc:a3473885e221c2cbacd7c3ee48b3b7dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a softbody mesh. The results are written to the stream.  <br /></td></tr>
<tr class="separator:a3473885e221c2cbacd7c3ee48b3b7dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ce91f23a811095df0481eb2afa8468"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_soft_body_mesh.html">PxSoftBodyMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a90ce91f23a811095df0481eb2afa8468">createSoftBodyMesh</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;simulationMeshDesc, const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;collisionMeshDesc, const <a class="el" href="classphysx_1_1_px_soft_body_simulation_data_desc.html">PxSoftBodySimulationDataDesc</a> &amp;softbodyDataDesc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const</td></tr>
<tr class="memdesc:a90ce91f23a811095df0481eb2afa8468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a softbody mesh without going through a stream.  <br /></td></tr>
<tr class="separator:a90ce91f23a811095df0481eb2afa8468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac338f022095688495a5fcf668c353fc7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#ac338f022095688495a5fcf668c353fc7">cookTetrahedronMesh</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;meshDesc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream) const</td></tr>
<tr class="memdesc:ac338f022095688495a5fcf668c353fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a tetrahedron mesh. The results are written to the stream.  <br /></td></tr>
<tr class="separator:ac338f022095688495a5fcf668c353fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906a59f1c63789c6bb390d2a02c683b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a906a59f1c63789c6bb390d2a02c683b2">createTetrahedronMesh</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;meshDesc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const</td></tr>
<tr class="memdesc:a906a59f1c63789c6bb390d2a02c683b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a tetrahedron mesh without going through a stream.  <br /></td></tr>
<tr class="separator:a906a59f1c63789c6bb390d2a02c683b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f5517ac47406bdeb49fa433ce79202"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_collision_mesh_mapping_data.html">PxCollisionMeshMappingData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#ad8f5517ac47406bdeb49fa433ce79202">computeModelsMapping</a> (<a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;simulationMesh, const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;collisionMesh, const <a class="el" href="classphysx_1_1_px_soft_body_collision_data.html">PxSoftBodyCollisionData</a> &amp;collisionData, const <a class="el" href="structphysx_1_1_px_bounded_data.html">PxBoundedData</a> *vertexToTet) const</td></tr>
<tr class="memdesc:ad8f5517ac47406bdeb49fa433ce79202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mapping between collision and simulation mesh.  <br /></td></tr>
<tr class="separator:ad8f5517ac47406bdeb49fa433ce79202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c377b38b2b4b0af82008481774a40c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_collision_tetrahedron_mesh_data.html">PxCollisionTetrahedronMeshData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a36c377b38b2b4b0af82008481774a40c">computeCollisionData</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;collisionMeshDesc) const</td></tr>
<tr class="memdesc:a36c377b38b2b4b0af82008481774a40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes data to accelerate collision detection of tetrahedral meshes.  <br /></td></tr>
<tr class="separator:a36c377b38b2b4b0af82008481774a40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b249acb53a21f07ba45136d1160bcb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_simulation_tetrahedron_mesh_data.html">PxSimulationTetrahedronMeshData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a3b249acb53a21f07ba45136d1160bcb5">computeSimulationData</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;simulationMeshDesc) const</td></tr>
<tr class="memdesc:a3b249acb53a21f07ba45136d1160bcb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes data to accelerate collision detection of tetrahedral meshes.  <br /></td></tr>
<tr class="separator:a3b249acb53a21f07ba45136d1160bcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3249c9b782b8bbf1699544b0960316"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_soft_body_mesh.html">PxSoftBodyMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a9d3249c9b782b8bbf1699544b0960316">assembleSoftBodyMesh</a> (<a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;simulationMesh, <a class="el" href="classphysx_1_1_px_soft_body_simulation_data.html">PxSoftBodySimulationData</a> &amp;simulationData, <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;collisionMesh, <a class="el" href="classphysx_1_1_px_soft_body_collision_data.html">PxSoftBodyCollisionData</a> &amp;collisionData, <a class="el" href="classphysx_1_1_px_collision_mesh_mapping_data.html">PxCollisionMeshMappingData</a> &amp;mappingData, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const</td></tr>
<tr class="memdesc:a9d3249c9b782b8bbf1699544b0960316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles all data required for softbody simulation.  <br /></td></tr>
<tr class="separator:a9d3249c9b782b8bbf1699544b0960316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4381dfbdd5772beb9cf1c32eace3b1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_soft_body_mesh.html">PxSoftBodyMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#acc4381dfbdd5772beb9cf1c32eace3b1">assembleSoftBodyMesh</a> (<a class="el" href="classphysx_1_1_px_simulation_tetrahedron_mesh_data.html">PxSimulationTetrahedronMeshData</a> &amp;simulationMesh, <a class="el" href="classphysx_1_1_px_collision_tetrahedron_mesh_data.html">PxCollisionTetrahedronMeshData</a> &amp;collisionMesh, <a class="el" href="classphysx_1_1_px_collision_mesh_mapping_data.html">PxCollisionMeshMappingData</a> &amp;mappingData, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const</td></tr>
<tr class="memdesc:acc4381dfbdd5772beb9cf1c32eace3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles all data required for softbody simulation.  <br /></td></tr>
<tr class="separator:acc4381dfbdd5772beb9cf1c32eace3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c61af7aa13066c8125d1b163338a15"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#af6c61af7aa13066c8125d1b163338a15">cookConvexMesh</a> (const <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html">PxConvexMeshDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream, <a class="el" href="structphysx_1_1_px_convex_mesh_cooking_result.html#ac00bd08f804c233bde64159eb5bfbeb7">PxConvexMeshCookingResult::Enum</a> *condition) const</td></tr>
<tr class="memdesc:af6c61af7aa13066c8125d1b163338a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a convex mesh. The results are written to the stream.  <br /></td></tr>
<tr class="separator:af6c61af7aa13066c8125d1b163338a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ca3e095bf4cb71cf81ca08ddc632e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_convex_mesh.html">PxConvexMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a10ca3e095bf4cb71cf81ca08ddc632e4">createConvexMesh</a> (const <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html">PxConvexMeshDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback, <a class="el" href="structphysx_1_1_px_convex_mesh_cooking_result.html#ac00bd08f804c233bde64159eb5bfbeb7">PxConvexMeshCookingResult::Enum</a> *condition) const</td></tr>
<tr class="memdesc:a10ca3e095bf4cb71cf81ca08ddc632e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a convex mesh without going through a stream.  <br /></td></tr>
<tr class="separator:a10ca3e095bf4cb71cf81ca08ddc632e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2a87aa4f96b994c94285bb5ebf49dc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a3c2a87aa4f96b994c94285bb5ebf49dc">validateConvexMesh</a> (const <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html">PxConvexMeshDesc</a> &amp;desc) const</td></tr>
<tr class="memdesc:a3c2a87aa4f96b994c94285bb5ebf49dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies if the convex mesh is valid. Prints an error message for each inconsistency found.  <br /></td></tr>
<tr class="separator:a3c2a87aa4f96b994c94285bb5ebf49dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d3301daa8ca1fc09e85d92711438b5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a18d3301daa8ca1fc09e85d92711438b5">computeHullPolygons</a> (const <a class="el" href="classphysx_1_1_px_simple_triangle_mesh.html">PxSimpleTriangleMesh</a> &amp;mesh, <a class="el" href="classphysx_1_1_px_allocator_callback.html">PxAllocatorCallback</a> &amp;inCallback, PxU32 &amp;nbVerts, <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> *&amp;vertices, PxU32 &amp;nbIndices, PxU32 *&amp;indices, PxU32 &amp;nbPolygons, <a class="el" href="structphysx_1_1_px_hull_polygon.html">PxHullPolygon</a> *&amp;hullPolygons) const</td></tr>
<tr class="memdesc:a18d3301daa8ca1fc09e85d92711438b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computed hull polygons from given vertices and triangles. Polygons are needed for <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html" title="Descriptor class for #PxConvexMesh.">PxConvexMeshDesc</a> rather than triangles.  <br /></td></tr>
<tr class="separator:a18d3301daa8ca1fc09e85d92711438b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1aba883b2d2a158553fbd4baa737a1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a9a1aba883b2d2a158553fbd4baa737a1">cookHeightField</a> (const <a class="el" href="classphysx_1_1_px_height_field_desc.html">PxHeightFieldDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream) const</td></tr>
<tr class="memdesc:a9a1aba883b2d2a158553fbd4baa737a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a heightfield. The results are written to the stream.  <br /></td></tr>
<tr class="separator:a9a1aba883b2d2a158553fbd4baa737a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee64840e6cd5c5397cedb1a2c8321fd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_height_field.html">PxHeightField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a4ee64840e6cd5c5397cedb1a2c8321fd">createHeightField</a> (const <a class="el" href="classphysx_1_1_px_height_field_desc.html">PxHeightFieldDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const</td></tr>
<tr class="memdesc:a4ee64840e6cd5c5397cedb1a2c8321fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>.  <br /></td></tr>
<tr class="separator:a4ee64840e6cd5c5397cedb1a2c8321fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fa209957149d89af6bfd4ddde2a626"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#ad8fa209957149d89af6bfd4ddde2a626">cookBVH</a> (const <a class="el" href="classphysx_1_1_px_b_v_h_desc.html">PxBVHDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream) const</td></tr>
<tr class="memdesc:ad8fa209957149d89af6bfd4ddde2a626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a bounding volume hierarchy. The results are written to the stream.  <br /></td></tr>
<tr class="separator:ad8fa209957149d89af6bfd4ddde2a626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc7d21fdeb760ef5724913dae10f5c4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_b_v_h.html">PxBVH</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#a0cc7d21fdeb760ef5724913dae10f5c4">createBVH</a> (const <a class="el" href="classphysx_1_1_px_b_v_h_desc.html">PxBVHDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const</td></tr>
<tr class="memdesc:a0cc7d21fdeb760ef5724913dae10f5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a bounding volume hierarchy without going through a stream.  <br /></td></tr>
<tr class="separator:a0cc7d21fdeb760ef5724913dae10f5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93b4cb7a869f2a021126316b66448a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_cooking.html#ac93b4cb7a869f2a021126316b66448a8">getStandaloneInsertionCallback</a> ()</td></tr>
<tr class="memdesc:ac93b4cb7a869f2a021126316b66448a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets standalone object insertion interface.  <br /></td></tr>
<tr class="separator:ac93b4cb7a869f2a021126316b66448a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0601c1d647c9f1ea6b06b3440b6bdb"><td class="memItemLeft" align="right" valign="top"><a id="a9b0601c1d647c9f1ea6b06b3440b6bdb" name="a9b0601c1d647c9f1ea6b06b3440b6bdb"></a>
<a class="el" href="classphysx_1_1_px_triangle_mesh.html">PxTriangleMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createTriangleMesh</b> (const <a class="el" href="structphysx_1_1_px_triangle_mesh_internal_data.html">PxTriangleMeshInternalData</a> &amp;data) const</td></tr>
<tr class="separator:a9b0601c1d647c9f1ea6b06b3440b6bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586ffb588453d1fbb3ef242ad0e25406"><td class="memItemLeft" align="right" valign="top"><a id="a586ffb588453d1fbb3ef242ad0e25406" name="a586ffb588453d1fbb3ef242ad0e25406"></a>
<a class="el" href="classphysx_1_1_px_b_v_h.html">PxBVH</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>createBVH</b> (const <a class="el" href="structphysx_1_1_px_b_v_h_internal_data.html">PxBVHInternalData</a> &amp;data) const</td></tr>
<tr class="separator:a586ffb588453d1fbb3ef242ad0e25406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_cooking"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_cooking')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_cooking.html">physx::PxCooking</a></td></tr>
<tr class="memitem:ae7f3e78f4c406ffe811c05dfccd3ab68 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#ae7f3e78f4c406ffe811c05dfccd3ab68">release</a> ()=0</td></tr>
<tr class="memdesc:ae7f3e78f4c406ffe811c05dfccd3ab68 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes this instance of the interface.  <br /></td></tr>
<tr class="separator:ae7f3e78f4c406ffe811c05dfccd3ab68 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428331215e0859186ebab6f9abaddfa2 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a428331215e0859186ebab6f9abaddfa2">setParams</a> (const <a class="el" href="structphysx_1_1_px_cooking_params.html">PxCookingParams</a> &amp;params)=0</td></tr>
<tr class="memdesc:a428331215e0859186ebab6f9abaddfa2 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets cooking parameters.  <br /></td></tr>
<tr class="separator:a428331215e0859186ebab6f9abaddfa2 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e885b1cf6d55e44397e8db13d9fe3f4 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structphysx_1_1_px_cooking_params.html">PxCookingParams</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a9e885b1cf6d55e44397e8db13d9fe3f4">getParams</a> () const =0</td></tr>
<tr class="memdesc:a9e885b1cf6d55e44397e8db13d9fe3f4 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets cooking parameters.  <br /></td></tr>
<tr class="separator:a9e885b1cf6d55e44397e8db13d9fe3f4 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7437873827b8473b299629160f2919 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a6c7437873827b8473b299629160f2919">platformMismatch</a> () const =0</td></tr>
<tr class="memdesc:a6c7437873827b8473b299629160f2919 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks endianness is the same between cooking &amp; target platforms.  <br /></td></tr>
<tr class="separator:a6c7437873827b8473b299629160f2919 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803848230341444dd38f219f9ccbe024 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a803848230341444dd38f219f9ccbe024">cookTriangleMesh</a> (const <a class="el" href="classphysx_1_1_px_triangle_mesh_desc.html">PxTriangleMeshDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream, <a class="el" href="structphysx_1_1_px_triangle_mesh_cooking_result.html#a50ce7fe0985bc16734a32e9753ba7a5e">PxTriangleMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>
<tr class="memdesc:a803848230341444dd38f219f9ccbe024 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a triangle mesh. The results are written to the stream.  <br /></td></tr>
<tr class="separator:a803848230341444dd38f219f9ccbe024 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af555fb3fbe5e62a59007d479644628af inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_triangle_mesh.html">PxTriangleMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#af555fb3fbe5e62a59007d479644628af">createTriangleMesh</a> (const <a class="el" href="classphysx_1_1_px_triangle_mesh_desc.html">PxTriangleMeshDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback, <a class="el" href="structphysx_1_1_px_triangle_mesh_cooking_result.html#a50ce7fe0985bc16734a32e9753ba7a5e">PxTriangleMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>
<tr class="memdesc:af555fb3fbe5e62a59007d479644628af inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a triangle mesh without going through a stream.  <br /></td></tr>
<tr class="separator:af555fb3fbe5e62a59007d479644628af inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebbb519e5de69199db23118ad48ec4b inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_triangle_mesh.html">PxTriangleMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a6ebbb519e5de69199db23118ad48ec4b">createTriangleMesh</a> (const <a class="el" href="classphysx_1_1_px_triangle_mesh_desc.html">PxTriangleMeshDesc</a> &amp;desc) const</td></tr>
<tr class="memdesc:a6ebbb519e5de69199db23118ad48ec4b inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a triangle mesh without going through a stream. Convenience function for standalone objects.  <br /></td></tr>
<tr class="separator:a6ebbb519e5de69199db23118ad48ec4b inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccc1d9cf0e4a69a0f100c70a692cbdf inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#aaccc1d9cf0e4a69a0f100c70a692cbdf">validateTriangleMesh</a> (const <a class="el" href="classphysx_1_1_px_triangle_mesh_desc.html">PxTriangleMeshDesc</a> &amp;desc) const =0</td></tr>
<tr class="memdesc:aaccc1d9cf0e4a69a0f100c70a692cbdf inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found.  <br /></td></tr>
<tr class="separator:aaccc1d9cf0e4a69a0f100c70a692cbdf inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bc59b230668811378d1df7b4e00d2e inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#af7bc59b230668811378d1df7b4e00d2e">cookSoftBodyMesh</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;simulationMeshDesc, const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;collisionMeshDesc, const <a class="el" href="classphysx_1_1_px_soft_body_simulation_data_desc.html">PxSoftBodySimulationDataDesc</a> &amp;softbodyDataDesc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream) const =0</td></tr>
<tr class="memdesc:af7bc59b230668811378d1df7b4e00d2e inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a softbody mesh. The results are written to the stream.  <br /></td></tr>
<tr class="separator:af7bc59b230668811378d1df7b4e00d2e inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204cbfa8c7ebe2bafa37ed6e5cd78918 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_soft_body_mesh.html">PxSoftBodyMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a204cbfa8c7ebe2bafa37ed6e5cd78918">createSoftBodyMesh</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;simulationMeshDesc, const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;collisionMeshDesc, const <a class="el" href="classphysx_1_1_px_soft_body_simulation_data_desc.html">PxSoftBodySimulationDataDesc</a> &amp;softbodyDataDesc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:a204cbfa8c7ebe2bafa37ed6e5cd78918 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a softbody mesh without going through a stream.  <br /></td></tr>
<tr class="separator:a204cbfa8c7ebe2bafa37ed6e5cd78918 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586cc6a8e19bf6c88ac825c27e93a2ef inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_soft_body_mesh.html">PxSoftBodyMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a586cc6a8e19bf6c88ac825c27e93a2ef">createSoftBodyMesh</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;simulationMeshDesc, const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;collisionMeshDesc, const <a class="el" href="classphysx_1_1_px_soft_body_simulation_data_desc.html">PxSoftBodySimulationDataDesc</a> &amp;softbodyDataDesc) const</td></tr>
<tr class="memdesc:a586cc6a8e19bf6c88ac825c27e93a2ef inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a softbody mesh without going through a stream. Convenience function for standalone objects.  <br /></td></tr>
<tr class="separator:a586cc6a8e19bf6c88ac825c27e93a2ef inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1503ab43f40d08646c4479b281b335d8 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a1503ab43f40d08646c4479b281b335d8">cookTetrahedronMesh</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;meshDesc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream) const =0</td></tr>
<tr class="memdesc:a1503ab43f40d08646c4479b281b335d8 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a tetrahedron mesh. The results are written to the stream.  <br /></td></tr>
<tr class="separator:a1503ab43f40d08646c4479b281b335d8 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7dcb4b8d664d814b092f5f91609eac8 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#ae7dcb4b8d664d814b092f5f91609eac8">createTetrahedronMesh</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;meshDesc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:ae7dcb4b8d664d814b092f5f91609eac8 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a tetrahedron mesh without going through a stream.  <br /></td></tr>
<tr class="separator:ae7dcb4b8d664d814b092f5f91609eac8 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfc890ff5e1388fe6b164d5591dd361 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#aedfc890ff5e1388fe6b164d5591dd361">createTetrahedronMesh</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;meshDesc) const</td></tr>
<tr class="memdesc:aedfc890ff5e1388fe6b164d5591dd361 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a tetrahedron mesh without going through a stream. Convenience function for standalone objects.  <br /></td></tr>
<tr class="separator:aedfc890ff5e1388fe6b164d5591dd361 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8643424fbde680ef0103fccb8d4c3d3 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_collision_mesh_mapping_data.html">PxCollisionMeshMappingData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#af8643424fbde680ef0103fccb8d4c3d3">computeModelsMapping</a> (<a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;simulationMesh, const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;collisionMesh, const <a class="el" href="classphysx_1_1_px_soft_body_collision_data.html">PxSoftBodyCollisionData</a> &amp;collisionData, const <a class="el" href="structphysx_1_1_px_bounded_data.html">PxBoundedData</a> *vertexToTet=NULL) const =0</td></tr>
<tr class="memdesc:af8643424fbde680ef0103fccb8d4c3d3 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mapping between collision and simulation mesh.  <br /></td></tr>
<tr class="separator:af8643424fbde680ef0103fccb8d4c3d3 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba90069d720c8cb624c9a4dad72a2f77 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_collision_tetrahedron_mesh_data.html">PxCollisionTetrahedronMeshData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#aba90069d720c8cb624c9a4dad72a2f77">computeCollisionData</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;collisionMeshDesc) const =0</td></tr>
<tr class="memdesc:aba90069d720c8cb624c9a4dad72a2f77 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes data to accelerate collision detection of tetrahedral meshes.  <br /></td></tr>
<tr class="separator:aba90069d720c8cb624c9a4dad72a2f77 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492e7a08bbaf4530cc6b876c772726f8 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_simulation_tetrahedron_mesh_data.html">PxSimulationTetrahedronMeshData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a492e7a08bbaf4530cc6b876c772726f8">computeSimulationData</a> (const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;simulationMeshDesc) const =0</td></tr>
<tr class="memdesc:a492e7a08bbaf4530cc6b876c772726f8 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes data to accelerate collision detection of tetrahedral meshes.  <br /></td></tr>
<tr class="separator:a492e7a08bbaf4530cc6b876c772726f8 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54855a6ba11087546dbde46fe0e2665d inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_soft_body_mesh.html">PxSoftBodyMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a54855a6ba11087546dbde46fe0e2665d">assembleSoftBodyMesh</a> (<a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;simulationMesh, <a class="el" href="classphysx_1_1_px_soft_body_simulation_data.html">PxSoftBodySimulationData</a> &amp;simulationData, <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;collisionMesh, <a class="el" href="classphysx_1_1_px_soft_body_collision_data.html">PxSoftBodyCollisionData</a> &amp;collisionData, <a class="el" href="classphysx_1_1_px_collision_mesh_mapping_data.html">PxCollisionMeshMappingData</a> &amp;mappingData, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:a54855a6ba11087546dbde46fe0e2665d inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles all data required for softbody simulation.  <br /></td></tr>
<tr class="separator:a54855a6ba11087546dbde46fe0e2665d inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3922ce49104e359158f3e4b8c2b841ce inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_soft_body_mesh.html">PxSoftBodyMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a3922ce49104e359158f3e4b8c2b841ce">assembleSoftBodyMesh</a> (<a class="el" href="classphysx_1_1_px_simulation_tetrahedron_mesh_data.html">PxSimulationTetrahedronMeshData</a> &amp;simulationMesh, <a class="el" href="classphysx_1_1_px_collision_tetrahedron_mesh_data.html">PxCollisionTetrahedronMeshData</a> &amp;collisionMesh, <a class="el" href="classphysx_1_1_px_collision_mesh_mapping_data.html">PxCollisionMeshMappingData</a> &amp;mappingData, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:a3922ce49104e359158f3e4b8c2b841ce inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles all data required for softbody simulation.  <br /></td></tr>
<tr class="separator:a3922ce49104e359158f3e4b8c2b841ce inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf17768951d2fafdfacbae25d34d8de0 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#abf17768951d2fafdfacbae25d34d8de0">cookConvexMesh</a> (const <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html">PxConvexMeshDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream, <a class="el" href="structphysx_1_1_px_convex_mesh_cooking_result.html#ac00bd08f804c233bde64159eb5bfbeb7">PxConvexMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>
<tr class="memdesc:abf17768951d2fafdfacbae25d34d8de0 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a convex mesh. The results are written to the stream.  <br /></td></tr>
<tr class="separator:abf17768951d2fafdfacbae25d34d8de0 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac47672baa77299c649a19bae32c24f inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_convex_mesh.html">PxConvexMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a7ac47672baa77299c649a19bae32c24f">createConvexMesh</a> (const <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html">PxConvexMeshDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback, <a class="el" href="structphysx_1_1_px_convex_mesh_cooking_result.html#ac00bd08f804c233bde64159eb5bfbeb7">PxConvexMeshCookingResult::Enum</a> *condition=NULL) const =0</td></tr>
<tr class="memdesc:a7ac47672baa77299c649a19bae32c24f inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a convex mesh without going through a stream.  <br /></td></tr>
<tr class="separator:a7ac47672baa77299c649a19bae32c24f inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7d3522f9643625051b897446751cfb inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_convex_mesh.html">PxConvexMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a0a7d3522f9643625051b897446751cfb">createConvexMesh</a> (const <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html">PxConvexMeshDesc</a> &amp;desc) const</td></tr>
<tr class="memdesc:a0a7d3522f9643625051b897446751cfb inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a convex mesh without going through a stream. Convenience function for standalone objects.  <br /></td></tr>
<tr class="separator:a0a7d3522f9643625051b897446751cfb inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d5d3c3d04d96bf4a9263bd01d224e3 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a73d5d3c3d04d96bf4a9263bd01d224e3">validateConvexMesh</a> (const <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html">PxConvexMeshDesc</a> &amp;desc) const =0</td></tr>
<tr class="memdesc:a73d5d3c3d04d96bf4a9263bd01d224e3 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies if the convex mesh is valid. Prints an error message for each inconsistency found.  <br /></td></tr>
<tr class="separator:a73d5d3c3d04d96bf4a9263bd01d224e3 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c9ed7fa790c3a7a7005a058c0d8d45 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a80c9ed7fa790c3a7a7005a058c0d8d45">computeHullPolygons</a> (const <a class="el" href="classphysx_1_1_px_simple_triangle_mesh.html">PxSimpleTriangleMesh</a> &amp;mesh, <a class="el" href="classphysx_1_1_px_allocator_callback.html">PxAllocatorCallback</a> &amp;inCallback, PxU32 &amp;nbVerts, <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> *&amp;vertices, PxU32 &amp;nbIndices, PxU32 *&amp;indices, PxU32 &amp;nbPolygons, <a class="el" href="structphysx_1_1_px_hull_polygon.html">PxHullPolygon</a> *&amp;hullPolygons) const =0</td></tr>
<tr class="memdesc:a80c9ed7fa790c3a7a7005a058c0d8d45 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computed hull polygons from given vertices and triangles. Polygons are needed for <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html" title="Descriptor class for #PxConvexMesh.">PxConvexMeshDesc</a> rather than triangles.  <br /></td></tr>
<tr class="separator:a80c9ed7fa790c3a7a7005a058c0d8d45 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff08c57e29dcbf4db88009065047110 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a5ff08c57e29dcbf4db88009065047110">cookHeightField</a> (const <a class="el" href="classphysx_1_1_px_height_field_desc.html">PxHeightFieldDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream) const =0</td></tr>
<tr class="memdesc:a5ff08c57e29dcbf4db88009065047110 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a heightfield. The results are written to the stream.  <br /></td></tr>
<tr class="separator:a5ff08c57e29dcbf4db88009065047110 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fead9883a2b3859dcd54c9cf38daf5 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_height_field.html">PxHeightField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a97fead9883a2b3859dcd54c9cf38daf5">createHeightField</a> (const <a class="el" href="classphysx_1_1_px_height_field_desc.html">PxHeightFieldDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:a97fead9883a2b3859dcd54c9cf38daf5 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>.  <br /></td></tr>
<tr class="separator:a97fead9883a2b3859dcd54c9cf38daf5 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dd4f7d9ca8550853d15663fd16ba8d inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_height_field.html">PxHeightField</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a95dd4f7d9ca8550853d15663fd16ba8d">createHeightField</a> (const <a class="el" href="classphysx_1_1_px_height_field_desc.html">PxHeightFieldDesc</a> &amp;desc) const</td></tr>
<tr class="memdesc:a95dd4f7d9ca8550853d15663fd16ba8d inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. Convenience function for standalone objects.  <br /></td></tr>
<tr class="separator:a95dd4f7d9ca8550853d15663fd16ba8d inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0983803ee2b85f05a0b50db5291b621e inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a0983803ee2b85f05a0b50db5291b621e">cookBVH</a> (const <a class="el" href="classphysx_1_1_px_b_v_h_desc.html">PxBVHDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream) const =0</td></tr>
<tr class="memdesc:a0983803ee2b85f05a0b50db5291b621e inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks a bounding volume hierarchy. The results are written to the stream.  <br /></td></tr>
<tr class="separator:a0983803ee2b85f05a0b50db5291b621e inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27479add76ce0c07bc08a2ded52f6eb inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gafd8f8779793627061774cfcfa1b9fbd7">PX_DEPRECATED</a> <a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#ad27479add76ce0c07bc08a2ded52f6eb">cookBVHStructure</a> (const <a class="el" href="namespacephysx.html#a8a8833dbcca76a242768541ab0738c7e">PxBVHStructureDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream) const</td></tr>
<tr class="memdesc:ad27479add76ce0c07bc08a2ded52f6eb inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward compatibility helper. Cooks a bounding volume hierarchy. The results are written to the stream.  <br /></td></tr>
<tr class="separator:ad27479add76ce0c07bc08a2ded52f6eb inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd44de3e5eb8bef6ad1bbd9b688d1fc inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_b_v_h.html">PxBVH</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a9cd44de3e5eb8bef6ad1bbd9b688d1fc">createBVH</a> (const <a class="el" href="classphysx_1_1_px_b_v_h_desc.html">PxBVHDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const =0</td></tr>
<tr class="memdesc:a9cd44de3e5eb8bef6ad1bbd9b688d1fc inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a bounding volume hierarchy without going through a stream.  <br /></td></tr>
<tr class="separator:a9cd44de3e5eb8bef6ad1bbd9b688d1fc inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a2ea062dfbf63e8ced192a2f6b2d92 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_b_v_h.html">PxBVH</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#ae0a2ea062dfbf63e8ced192a2f6b2d92">createBVH</a> (const <a class="el" href="classphysx_1_1_px_b_v_h_desc.html">PxBVHDesc</a> &amp;desc) const</td></tr>
<tr class="memdesc:ae0a2ea062dfbf63e8ced192a2f6b2d92 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cooks and creates a bounding volume hierarchy without going through a stream. Convenience function for standalone objects.  <br /></td></tr>
<tr class="separator:ae0a2ea062dfbf63e8ced192a2f6b2d92 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ab7cd4ecb64df2c23405dcc0649a6a inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gafd8f8779793627061774cfcfa1b9fbd7">PX_DEPRECATED</a> <a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="namespacephysx.html#ab7288bccbce2550741f9d2747361b200">PxBVHStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a23ab7cd4ecb64df2c23405dcc0649a6a">createBVHStructure</a> (const <a class="el" href="namespacephysx.html#a8a8833dbcca76a242768541ab0738c7e">PxBVHStructureDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;insertionCallback) const</td></tr>
<tr class="memdesc:a23ab7cd4ecb64df2c23405dcc0649a6a inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward compatibility helper. Cooks and creates a bounding volume hierarchy without going through a stream.  <br /></td></tr>
<tr class="separator:a23ab7cd4ecb64df2c23405dcc0649a6a inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cb0dc683ee9e567184130db9c7cea1 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_cooking.html#a18cb0dc683ee9e567184130db9c7cea1">getStandaloneInsertionCallback</a> ()=0</td></tr>
<tr class="memdesc:a18cb0dc683ee9e567184130db9c7cea1 inherit pub_methods_classphysx_1_1_px_cooking"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets standalone object insertion interface.  <br /></td></tr>
<tr class="separator:a18cb0dc683ee9e567184130db9c7cea1 inherit pub_methods_classphysx_1_1_px_cooking"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_user_allocated"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_user_allocated')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_user_allocated.html">physx::PxUserAllocated</a></td></tr>
<tr class="memitem:ac6a9a67e2851ca793aab3e5cd5d40dc9 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="ac6a9a67e2851ca793aab3e5cd5d40dc9" name="ac6a9a67e2851ca793aab3e5cd5d40dc9"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t, void *address)</td></tr>
<tr class="separator:ac6a9a67e2851ca793aab3e5cd5d40dc9 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046ea5070dbf9afdd2a7861e92e94d81 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="a046ea5070dbf9afdd2a7861e92e94d81" name="a046ea5070dbf9afdd2a7861e92e94d81"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *, void *)</td></tr>
<tr class="separator:a046ea5070dbf9afdd2a7861e92e94d81 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bae0296ddfbc31b60216e2ba92abd2 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="ae4bae0296ddfbc31b60216e2ba92abd2" name="ae4bae0296ddfbc31b60216e2ba92abd2"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:ae4bae0296ddfbc31b60216e2ba92abd2 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new</b> (size_t size, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:ae4bae0296ddfbc31b60216e2ba92abd2 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a10b191838ea8c32665b016efdc8f3 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="a63a10b191838ea8c32665b016efdc8f3" name="a63a10b191838ea8c32665b016efdc8f3"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a63a10b191838ea8c32665b016efdc8f3 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new</b> (size_t size, size_t, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:a63a10b191838ea8c32665b016efdc8f3 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5b943c992e48740700b211db97c551 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="aba5b943c992e48740700b211db97c551" name="aba5b943c992e48740700b211db97c551"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:aba5b943c992e48740700b211db97c551 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new[]</b> (size_t size, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:aba5b943c992e48740700b211db97c551 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290c0241798e99dd5aa3268ab4409e5d inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="a290c0241798e99dd5aa3268ab4409e5d" name="a290c0241798e99dd5aa3268ab4409e5d"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a290c0241798e99dd5aa3268ab4409e5d inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new[]</b> (size_t size, size_t, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:a290c0241798e99dd5aa3268ab4409e5d inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75170caed9ba30211dac6786a2bd6a0b inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="a75170caed9ba30211dac6786a2bd6a0b" name="a75170caed9ba30211dac6786a2bd6a0b"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a75170caed9ba30211dac6786a2bd6a0b inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator delete</b> (void *ptr, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:a75170caed9ba30211dac6786a2bd6a0b inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac388e14397c75698987292f6e366603e inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="ac388e14397c75698987292f6e366603e" name="ac388e14397c75698987292f6e366603e"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:ac388e14397c75698987292f6e366603e inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:ac388e14397c75698987292f6e366603e inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f3a3f96013ef224beb23fbdc73d758 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="a14f3a3f96013ef224beb23fbdc73d758" name="a14f3a3f96013ef224beb23fbdc73d758"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr)</td></tr>
<tr class="separator:a14f3a3f96013ef224beb23fbdc73d758 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec6f784dc7cbe8d3542f22e8c5ec3fa inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="a5ec6f784dc7cbe8d3542f22e8c5ec3fa" name="a5ec6f784dc7cbe8d3542f22e8c5ec3fa"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr)</td></tr>
<tr class="separator:a5ec6f784dc7cbe8d3542f22e8c5ec3fa inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acc4381dfbdd5772beb9cf1c32eace3b1" name="acc4381dfbdd5772beb9cf1c32eace3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4381dfbdd5772beb9cf1c32eace3b1">&#9670;&#160;</a></span>assembleSoftBodyMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_soft_body_mesh.html">PxSoftBodyMesh</a> * Cooking::assembleSoftBodyMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_simulation_tetrahedron_mesh_data.html">PxSimulationTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_collision_tetrahedron_mesh_data.html">PxCollisionTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_collision_mesh_mapping_data.html">PxCollisionMeshMappingData</a> &amp;&#160;</td>
          <td class="paramname"><em>mappingData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bundles all data required for softbody simulation. </p>
<p>Creates a container that provides everything to create a <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMesh</td><td>Container that provides all information about the simulation mesh (geometry, mass distribution etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMesh</td><td>Container that provides all information about the collision mesh (geometry, surface information, acceleration structures etc.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mappingData</td><td>Mapping that describes how the collision mesh's vertices are embedded into the simulation mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classphysx_1_1_px_soft_body_mesh.html" title="A softbody mesh, containing structures to store collision shape, simulation shape and deformation sta...">PxSoftBodyMesh</a> pointer that represents a softbody mesh bundling all data (simulation mesh, collision mesh etc.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> createSoftBody() </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a3922ce49104e359158f3e4b8c2b841ce">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a9d3249c9b782b8bbf1699544b0960316" name="a9d3249c9b782b8bbf1699544b0960316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3249c9b782b8bbf1699544b0960316">&#9670;&#160;</a></span>assembleSoftBodyMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_soft_body_mesh.html">PxSoftBodyMesh</a> * Cooking::assembleSoftBodyMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body_simulation_data.html">PxSoftBodySimulationData</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body_collision_data.html">PxSoftBodyCollisionData</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_collision_mesh_mapping_data.html">PxCollisionMeshMappingData</a> &amp;&#160;</td>
          <td class="paramname"><em>mappingData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bundles all data required for softbody simulation. </p>
<p>Creates a container that provides everything to create a <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMesh</td><td>The geometry (tetrahedral mesh) to be used as simulation mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationData</td><td>Additional non-tetmesh data that contains mass information etc. for the simulation mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMesh</td><td>The geometry (tetrahedral mesh) to be used for collision detection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionData</td><td>Additional non-tetmesh data that contains surface information, acceleration structures etc. for the simulation mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mappingData</td><td>Mapping that describes how the collision mesh's vertices are embedded into the simulation mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classphysx_1_1_px_soft_body_mesh.html" title="A softbody mesh, containing structures to store collision shape, simulation shape and deformation sta...">PxSoftBodyMesh</a> pointer that represents a softbody mesh bundling all data (simulation mesh, collision mesh etc.)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> createSoftBody() </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a54855a6ba11087546dbde46fe0e2665d">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a36c377b38b2b4b0af82008481774a40c" name="a36c377b38b2b4b0af82008481774a40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c377b38b2b4b0af82008481774a40c">&#9670;&#160;</a></span>computeCollisionData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_collision_tetrahedron_mesh_data.html">PxCollisionTetrahedronMeshData</a> * Cooking::computeCollisionData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMeshDesc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes data to accelerate collision detection of tetrahedral meshes. </p>
<p>Computes data structures to speed up collision detection with tetrahedral meshes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMeshDesc</td><td>Raw tetrahedral mesh descriptor wich will be used for collision detection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classphysx_1_1_px_collision_tetrahedron_mesh_data.html" title="Conbines PxTetrahedronMeshData and PxSoftBodyCollisionData.">PxCollisionTetrahedronMeshData</a> pointer that describes the collision mesh </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#aba90069d720c8cb624c9a4dad72a2f77">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a18d3301daa8ca1fc09e85d92711438b5" name="a18d3301daa8ca1fc09e85d92711438b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d3301daa8ca1fc09e85d92711438b5">&#9670;&#160;</a></span>computeHullPolygons()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cooking::computeHullPolygons </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_simple_triangle_mesh.html">PxSimpleTriangleMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_allocator_callback.html">PxAllocatorCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>inCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>nbVerts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> *&amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>nbIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 *&amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>nbPolygons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_hull_polygon.html">PxHullPolygon</a> *&amp;&#160;</td>
          <td class="paramname"><em>hullPolygons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computed hull polygons from given vertices and triangles. Polygons are needed for <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html" title="Descriptor class for #PxConvexMesh.">PxConvexMeshDesc</a> rather than triangles. </p>
<p>Please note that the resulting polygons may have different number of vertices. Some vertices may be removed. The output vertices, indices and polygons must be used to construct a hull.</p>
<p>The provided <a class="el" href="classphysx_1_1_px_allocator_callback.html" title="Abstract base class for an application defined memory allocator that can be used by the Nv library.">PxAllocatorCallback</a> does allocate the out array's. It is the user responsibility to deallocated those array's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Simple triangle mesh containing vertices and triangles used to compute polygons. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inCallback</td><td>Memory allocator for out array allocations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nbVerts</td><td>Number of vertices used by polygons. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertices</td><td>Vertices array used by polygons. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nbIndices</td><td>Number of indices used by polygons. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td><a class="el" href="struct_indices.html">Indices</a> array used by polygons. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nbPolygons</td><td>Number of created polygons. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hullPolygons</td><td>Polygons array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#af6c61af7aa13066c8125d1b163338a15" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="namespacephysx.html#aa9ce226f28cde93c844ed5030d2758a7" title="collection of set bits defined in PxConvexFlag.">PxConvexFlags</a> <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html" title="Descriptor class for #PxConvexMesh.">PxConvexMeshDesc</a> <a class="el" href="classphysx_1_1_px_simple_triangle_mesh.html" title="A structure describing a triangle mesh.">PxSimpleTriangleMesh</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a80c9ed7fa790c3a7a7005a058c0d8d45">physx::PxCooking</a>.</p>

</div>
</div>
<a id="ad8f5517ac47406bdeb49fa433ce79202" name="ad8f5517ac47406bdeb49fa433ce79202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f5517ac47406bdeb49fa433ce79202">&#9670;&#160;</a></span>computeModelsMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_collision_mesh_mapping_data.html">PxCollisionMeshMappingData</a> * Cooking::computeModelsMapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_data.html">PxTetrahedronMeshData</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_soft_body_collision_data.html">PxSoftBodyCollisionData</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_bounded_data.html">PxBoundedData</a> *&#160;</td>
          <td class="paramname"><em>vertexToTet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the mapping between collision and simulation mesh. </p>
<p>The softbody deformation is computed on the simulation mesh. To deform the collision mesh accordingly it needs to be specified how its vertices need to be placed and updated inside the deformation mesh. This method computes that embedding information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMesh</td><td>A tetrahedral mesh that defines the shape of the simulation mesh which is used to compute the body's deformation <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMesh</td><td>A tetrahedral mesh that defines the shape of the collision mesh which is used for collision detection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionData</td><td>A data container that contains acceleration structures and surface information of the collision mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertexToTet</td><td>Optional indices (array of integers) that specifies the index of the tetrahedron in the simulation mesh that contains a collision mesh vertex. If not provided, the embedding will be computed internally. If the simulation mesh is obtained from <a class="el" href="classphysx_1_1_px_tet_maker.html#a61884a4dcff14ea429b784330b88a571" title="Create voxel-based tetrahedron mesh using TetMaker.">PxTetMaker::createVoxelTetrahedronMesh</a>, then the vertexToTet map createVoxelTetrahedronMesh returned should be used here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classphysx_1_1_px_collision_mesh_mapping_data.html" title="Contains information about how to update the collision mesh&#39;s vertices given a deformed simulation te...">PxCollisionMeshMappingData</a> pointer that describes how the collision mesh is embedded into the simulation mesh</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_tet_maker.html#a61884a4dcff14ea429b784330b88a571" title="Create voxel-based tetrahedron mesh using TetMaker.">PxTetMaker::createVoxelTetrahedronMesh</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#af8643424fbde680ef0103fccb8d4c3d3">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a3b249acb53a21f07ba45136d1160bcb5" name="a3b249acb53a21f07ba45136d1160bcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b249acb53a21f07ba45136d1160bcb5">&#9670;&#160;</a></span>computeSimulationData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_simulation_tetrahedron_mesh_data.html">PxSimulationTetrahedronMeshData</a> * Cooking::computeSimulationData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMeshDesc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes data to accelerate collision detection of tetrahedral meshes. </p>
<p>Computes data to compute and store a softbody's deformation using FEM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMeshDesc</td><td>Raw tetrahedral mesh descriptor wich will be used for FEM simulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classphysx_1_1_px_simulation_tetrahedron_mesh_data.html" title="Conbines PxTetrahedronMeshData and PxSoftBodyCollisionData.">PxSimulationTetrahedronMeshData</a> pointer that describes the simulation mesh </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a492e7a08bbaf4530cc6b876c772726f8">physx::PxCooking</a>.</p>

</div>
</div>
<a id="ad8fa209957149d89af6bfd4ddde2a626" name="ad8fa209957149d89af6bfd4ddde2a626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fa209957149d89af6bfd4ddde2a626">&#9670;&#160;</a></span>cookBVH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cooking::cookBVH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_b_v_h_desc.html">PxBVHDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a bounding volume hierarchy. The results are written to the stream. </p>
<p><a class="el" href="classphysx_1_1_cooking.html#ad8fa209957149d89af6bfd4ddde2a626" title="Cooks a bounding volume hierarchy. The results are written to the stream.">cookBVH()</a> allows a BVH description to be cooked into a binary stream suitable for loading and performing BVH detection at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The BVH descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_b_v_h.html" title="Class representing a bounding volume hierarchy.">PxBVH</a> <a class="el" href="classphysx_1_1_px_rigid_actor_ext.html#a204cd0d407e8048b50f91ef675dcc406" title="Gets a list of bounds based on shapes in rigid actor. This list can be used to cook/create bounding v...">PxRigidActorExt::getRigidActorShapeLocalBoundsList</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a0983803ee2b85f05a0b50db5291b621e">physx::PxCooking</a>.</p>

</div>
</div>
<a id="af6c61af7aa13066c8125d1b163338a15" name="af6c61af7aa13066c8125d1b163338a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c61af7aa13066c8125d1b163338a15">&#9670;&#160;</a></span>cookConvexMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cooking::cookConvexMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html">PxConvexMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_convex_mesh_cooking_result.html#ac00bd08f804c233bde64159eb5bfbeb7">PxConvexMeshCookingResult::Enum</a> *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a convex mesh. The results are written to the stream. </p>
<p>To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.</p>
<p><a class="el" href="classphysx_1_1_cooking.html#af6c61af7aa13066c8125d1b163338a15" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.</p>
<dl class="section note"><dt>Note</dt><dd>The number of vertices and the number of convex polygons in a cooked convex mesh is limited to 255. </dd>
<dd>
If those limits are exceeded in either the user-provided data or the final cooked mesh, an error is reported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The convex mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">condition</td><td>Result from convex mesh cooking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#a3ef225a197658f28c6f1e48bbbb90b12" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> <a class="el" href="classphysx_1_1_cooking.html#a678f224fec665d86d454750c583d1136" title="Sets cooking parameters.">setParams()</a> <a class="el" href="structphysx_1_1_px_convex_mesh_cooking_result.html#ac00bd08f804c233bde64159eb5bfbeb7">PxConvexMeshCookingResult::Enum</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#abf17768951d2fafdfacbae25d34d8de0">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a9a1aba883b2d2a158553fbd4baa737a1" name="a9a1aba883b2d2a158553fbd4baa737a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1aba883b2d2a158553fbd4baa737a1">&#9670;&#160;</a></span>cookHeightField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cooking::cookHeightField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_height_field_desc.html">PxHeightFieldDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a heightfield. The results are written to the stream. </p>
<p>To create a heightfield object there is an option to precompute some of calculations done while loading the heightfield data.</p>
<p><a class="el" href="classphysx_1_1_cooking.html#a9a1aba883b2d2a158553fbd4baa737a1" title="Cooks a heightfield. The results are written to the stream.">cookHeightField()</a> allows a heightfield description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The heightfield descriptor to read the HF from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_physics.html#a4c3095310103ada510f6fb9ebe08ea47" title="Creates a heightfield object from previously cooked stream.">PxPhysics.createHeightField()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a5ff08c57e29dcbf4db88009065047110">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a3473885e221c2cbacd7c3ee48b3b7dc2" name="a3473885e221c2cbacd7c3ee48b3b7dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3473885e221c2cbacd7c3ee48b3b7dc2">&#9670;&#160;</a></span>cookSoftBodyMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cooking::cookSoftBodyMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMeshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMeshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_soft_body_simulation_data_desc.html">PxSoftBodySimulationDataDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>softbodyDataDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a softbody mesh. The results are written to the stream. </p>
<p>To create a softbody mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection and to store data used during the FEM calculations.</p>
<p><a class="el" href="classphysx_1_1_cooking.html#a3473885e221c2cbacd7c3ee48b3b7dc2" title="Cooks a softbody mesh. The results are written to the stream.">cookSoftBodyMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.</p>
<p>Example</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMeshDesc</td><td>The tetrahedron mesh descriptor to read the simulation mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMeshDesc</td><td>The tetrahedron mesh descriptor to read the collision mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softbodyDataDesc</td><td>The softbody data descriptor to read mapping information from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#af6c61af7aa13066c8125d1b163338a15" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="classphysx_1_1_cooking.html#a678f224fec665d86d454750c583d1136" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classphysx_1_1_px_physics.html#a95416d7e40b19556cc1a2902f1d8e4bd" title="Creates a triangle mesh object.">PxPhysics.createTriangleMesh()</a> <a class="el" href="structphysx_1_1_px_triangle_mesh_cooking_result.html#a50ce7fe0985bc16734a32e9753ba7a5e">PxTriangleMeshCookingResult::Enum</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#af7bc59b230668811378d1df7b4e00d2e">physx::PxCooking</a>.</p>

</div>
</div>
<a id="ac338f022095688495a5fcf668c353fc7" name="ac338f022095688495a5fcf668c353fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac338f022095688495a5fcf668c353fc7">&#9670;&#160;</a></span>cookTetrahedronMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cooking::cookTetrahedronMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>meshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a tetrahedron mesh. The results are written to the stream. </p>
<p>To create a tetrahedron mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.</p>
<p><a class="el" href="classphysx_1_1_cooking.html#a3ef225a197658f28c6f1e48bbbb90b12" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.</p>
<p>Example</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshDesc</td><td>The tetrahedron mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#af6c61af7aa13066c8125d1b163338a15" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="classphysx_1_1_cooking.html#a678f224fec665d86d454750c583d1136" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classphysx_1_1_px_physics.html#a196dcc9d51b451ca41bada0569adcbf3" title="Creates a tetrahedron mesh object.">PxPhysics.createTetrahedronMesh()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a1503ab43f40d08646c4479b281b335d8">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a3ef225a197658f28c6f1e48bbbb90b12" name="a3ef225a197658f28c6f1e48bbbb90b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef225a197658f28c6f1e48bbbb90b12">&#9670;&#160;</a></span>cookTriangleMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cooking::cookTriangleMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_triangle_mesh_desc.html">PxTriangleMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_triangle_mesh_cooking_result.html#a50ce7fe0985bc16734a32e9753ba7a5e">PxTriangleMeshCookingResult::Enum</a> *&#160;</td>
          <td class="paramname"><em>condition</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks a triangle mesh. The results are written to the stream. </p>
<p>To create a triangle mesh object it is necessary to first 'cook' the mesh data into a form which allows the SDK to perform efficient collision detection.</p>
<p><a class="el" href="classphysx_1_1_cooking.html#a3ef225a197658f28c6f1e48bbbb90b12" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> allows a mesh description to be cooked into a binary stream suitable for loading and performing collision detection at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The triangle mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>User stream to output the cooked data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">condition</td><td>Result from triangle mesh cooking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#af6c61af7aa13066c8125d1b163338a15" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="classphysx_1_1_cooking.html#a678f224fec665d86d454750c583d1136" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classphysx_1_1_px_physics.html#a95416d7e40b19556cc1a2902f1d8e4bd" title="Creates a triangle mesh object.">PxPhysics.createTriangleMesh()</a> <a class="el" href="structphysx_1_1_px_triangle_mesh_cooking_result.html#a50ce7fe0985bc16734a32e9753ba7a5e">PxTriangleMeshCookingResult::Enum</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a803848230341444dd38f219f9ccbe024">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a0cc7d21fdeb760ef5724913dae10f5c4" name="a0cc7d21fdeb760ef5724913dae10f5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc7d21fdeb760ef5724913dae10f5c4">&#9670;&#160;</a></span>createBVH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_b_v_h.html">PxBVH</a> * Cooking::createBVH </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_b_v_h_desc.html">PxBVHDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a bounding volume hierarchy without going through a stream. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookBVH, but the produced BVH is not stored into a stream but is either directly inserted in <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd>
<dd>
<a class="el" href="classphysx_1_1_px_insertion_callback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> can be obtained through <a class="el" href="classphysx_1_1_px_physics.html#af441381c41df6b90c6e18cdd6e7a346e" title="Gets PxPhysics object insertion interface.">PxPhysics::getPhysicsInsertionCallback()</a> or <a class="el" href="classphysx_1_1_px_cooking.html#a18cb0dc683ee9e567184130db9c7cea1" title="Gets standalone object insertion interface.">PxCooking::getStandaloneInsertionCallback()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The BVH descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classphysx_1_1_px_b_v_h.html" title="Class representing a bounding volume hierarchy.">PxBVH</a> pointer on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#ad8fa209957149d89af6bfd4ddde2a626" title="Cooks a bounding volume hierarchy. The results are written to the stream.">cookBVH()</a> <a class="el" href="classphysx_1_1_px_insertion_callback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a9cd44de3e5eb8bef6ad1bbd9b688d1fc">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a10ca3e095bf4cb71cf81ca08ddc632e4" name="a10ca3e095bf4cb71cf81ca08ddc632e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ca3e095bf4cb71cf81ca08ddc632e4">&#9670;&#160;</a></span>createConvexMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_convex_mesh.html">PxConvexMesh</a> * Cooking::createConvexMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html">PxConvexMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_convex_mesh_cooking_result.html#ac00bd08f804c233bde64159eb5bfbeb7">PxConvexMeshCookingResult::Enum</a> *&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a convex mesh without going through a stream. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookConvexMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd>
<dd>
<a class="el" href="classphysx_1_1_px_insertion_callback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> can be obtained through <a class="el" href="classphysx_1_1_px_physics.html#af441381c41df6b90c6e18cdd6e7a346e" title="Gets PxPhysics object insertion interface.">PxPhysics::getPhysicsInsertionCallback()</a> or <a class="el" href="classphysx_1_1_px_cooking.html#a18cb0dc683ee9e567184130db9c7cea1" title="Gets standalone object insertion interface.">PxCooking::getStandaloneInsertionCallback()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The convex mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">condition</td><td>Result from convex mesh cooking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classphysx_1_1_px_convex_mesh.html" title="A convex mesh.">PxConvexMesh</a> pointer on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#af6c61af7aa13066c8125d1b163338a15" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="classphysx_1_1_cooking.html#a678f224fec665d86d454750c583d1136" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classphysx_1_1_px_insertion_callback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a7ac47672baa77299c649a19bae32c24f">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a4ee64840e6cd5c5397cedb1a2c8321fd" name="a4ee64840e6cd5c5397cedb1a2c8321fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee64840e6cd5c5397cedb1a2c8321fd">&#9670;&#160;</a></span>createHeightField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_height_field.html">PxHeightField</a> * Cooking::createHeightField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_height_field_desc.html">PxHeightFieldDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a heightfield mesh and inserts it into <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The heightfield descriptor to read the HF from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classphysx_1_1_px_height_field.html" title="A height field class.">PxHeightField</a> pointer on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#af6c61af7aa13066c8125d1b163338a15" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> <a class="el" href="classphysx_1_1_cooking.html#a678f224fec665d86d454750c583d1136" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classphysx_1_1_px_physics.html#a95416d7e40b19556cc1a2902f1d8e4bd" title="Creates a triangle mesh object.">PxPhysics.createTriangleMesh()</a> <a class="el" href="classphysx_1_1_px_insertion_callback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a97fead9883a2b3859dcd54c9cf38daf5">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a90ce91f23a811095df0481eb2afa8468" name="a90ce91f23a811095df0481eb2afa8468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ce91f23a811095df0481eb2afa8468">&#9670;&#160;</a></span>createSoftBodyMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_soft_body_mesh.html">PxSoftBodyMesh</a> * Cooking::createSoftBodyMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMeshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>collisionMeshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_soft_body_simulation_data_desc.html">PxSoftBodySimulationDataDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>softbodyDataDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a softbody mesh without going through a stream. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookSoftBodyMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd>
<dd>
<a class="el" href="classphysx_1_1_px_insertion_callback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> can be obtained through <a class="el" href="classphysx_1_1_px_physics.html#af441381c41df6b90c6e18cdd6e7a346e" title="Gets PxPhysics object insertion interface.">PxPhysics::getPhysicsInsertionCallback()</a> or <a class="el" href="classphysx_1_1_px_cooking.html#a18cb0dc683ee9e567184130db9c7cea1" title="Gets standalone object insertion interface.">PxCooking::getStandaloneInsertionCallback()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMeshDesc</td><td>The tetrahedron mesh descriptor to read the simulation mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collisionMeshDesc</td><td>The tetrahedron mesh descriptor to read the collision mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softbodyDataDesc</td><td>The softbody data descriptor to read mapping information from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classphysx_1_1_px_soft_body_mesh.html" title="A softbody mesh, containing structures to store collision shape, simulation shape and deformation sta...">PxSoftBodyMesh</a> pointer on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#a3ef225a197658f28c6f1e48bbbb90b12" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> <a class="el" href="classphysx_1_1_cooking.html#a678f224fec665d86d454750c583d1136" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classphysx_1_1_px_physics.html#a95416d7e40b19556cc1a2902f1d8e4bd" title="Creates a triangle mesh object.">PxPhysics.createTriangleMesh()</a> <a class="el" href="classphysx_1_1_px_insertion_callback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a204cbfa8c7ebe2bafa37ed6e5cd78918">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a906a59f1c63789c6bb390d2a02c683b2" name="a906a59f1c63789c6bb390d2a02c683b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906a59f1c63789c6bb390d2a02c683b2">&#9670;&#160;</a></span>createTetrahedronMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> * Cooking::createTetrahedronMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_tetrahedron_mesh_desc.html">PxTetrahedronMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>meshDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a tetrahedron mesh without going through a stream. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookTetrahedronMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd>
<dd>
<a class="el" href="classphysx_1_1_px_insertion_callback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> can be obtained through <a class="el" href="classphysx_1_1_px_physics.html#af441381c41df6b90c6e18cdd6e7a346e" title="Gets PxPhysics object insertion interface.">PxPhysics::getPhysicsInsertionCallback()</a> or <a class="el" href="classphysx_1_1_px_cooking.html#a18cb0dc683ee9e567184130db9c7cea1" title="Gets standalone object insertion interface.">PxCooking::getStandaloneInsertionCallback()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshDesc</td><td>The tetrahedron mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html" title="A tetramedron mesh, also called a &#39;tetrahedron soup&#39;.">PxTetrahedronMesh</a> pointer on success.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#ac338f022095688495a5fcf668c353fc7" title="Cooks a tetrahedron mesh. The results are written to the stream.">cookTetrahedronMesh()</a> <a class="el" href="classphysx_1_1_cooking.html#a678f224fec665d86d454750c583d1136" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classphysx_1_1_px_insertion_callback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#ae7dcb4b8d664d814b092f5f91609eac8">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a0975d9f9bb7a88b47338ccc5ac89e5e6" name="a0975d9f9bb7a88b47338ccc5ac89e5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0975d9f9bb7a88b47338ccc5ac89e5e6">&#9670;&#160;</a></span>createTriangleMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_triangle_mesh.html">PxTriangleMesh</a> * Cooking::createTriangleMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_triangle_mesh_desc.html">PxTriangleMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>insertionCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_triangle_mesh_cooking_result.html#a50ce7fe0985bc16734a32e9753ba7a5e">PxTriangleMeshCookingResult::Enum</a> *&#160;</td>
          <td class="paramname"><em>condition</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cooks and creates a triangle mesh without going through a stream. </p>
<dl class="section note"><dt>Note</dt><dd>This method does the same as cookTriangleMesh, but the produced mesh is not stored into a stream but is either directly inserted in <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>, or created as a standalone object. Use this method if you are unable to cook offline.</dd>
<dd>
<a class="el" href="classphysx_1_1_px_insertion_callback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> can be obtained through <a class="el" href="classphysx_1_1_px_physics.html#af441381c41df6b90c6e18cdd6e7a346e" title="Gets PxPhysics object insertion interface.">PxPhysics::getPhysicsInsertionCallback()</a> or <a class="el" href="classphysx_1_1_px_cooking.html#a18cb0dc683ee9e567184130db9c7cea1" title="Gets standalone object insertion interface.">PxCooking::getStandaloneInsertionCallback()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The triangle mesh descriptor to read the mesh from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">insertionCallback</td><td>The insertion interface from <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">condition</td><td>Result from triangle mesh cooking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classphysx_1_1_px_triangle_mesh.html" title="A triangle mesh, also called a &#39;polygon soup&#39;.">PxTriangleMesh</a> pointer on success. <br  />
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#a3ef225a197658f28c6f1e48bbbb90b12" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> <a class="el" href="classphysx_1_1_cooking.html#a678f224fec665d86d454750c583d1136" title="Sets cooking parameters.">setParams()</a> <a class="el" href="classphysx_1_1_px_physics.html#a95416d7e40b19556cc1a2902f1d8e4bd" title="Creates a triangle mesh object.">PxPhysics.createTriangleMesh()</a> <a class="el" href="classphysx_1_1_px_insertion_callback.html" title="Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used directly with...">PxInsertionCallback</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#af555fb3fbe5e62a59007d479644628af">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a96a1def0096fd40e460622e3fa8ca01b" name="a96a1def0096fd40e460622e3fa8ca01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a1def0096fd40e460622e3fa8ca01b">&#9670;&#160;</a></span>getParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structphysx_1_1_px_cooking_params.html">PxCookingParams</a> &amp; Cooking::getParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets cooking parameters. </p>
<dl class="section return"><dt>Returns</dt><dd>Current cooking parameters.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_cooking_params.html" title="Structure describing parameters affecting mesh cooking.">PxCookingParams</a> <a class="el" href="classphysx_1_1_cooking.html#a678f224fec665d86d454750c583d1136" title="Sets cooking parameters.">setParams()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a9e885b1cf6d55e44397e8db13d9fe3f4">physx::PxCooking</a>.</p>

</div>
</div>
<a id="ac93b4cb7a869f2a021126316b66448a8" name="ac93b4cb7a869f2a021126316b66448a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93b4cb7a869f2a021126316b66448a8">&#9670;&#160;</a></span>getStandaloneInsertionCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_insertion_callback.html">PxInsertionCallback</a> &amp; Cooking::getStandaloneInsertionCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets standalone object insertion interface. </p>
<p>This interface allows the creation of standalone objects that can exist without a <a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> or <a class="el" href="classphysx_1_1_px_scene.html" title="A scene is a collection of bodies and constraints which can interact.">PxScene</a> object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_cooking.html#af555fb3fbe5e62a59007d479644628af" title="Cooks and creates a triangle mesh without going through a stream.">PxCooking::createTriangleMesh</a> PxCooking::createHeightfield <a class="el" href="classphysx_1_1_px_cooking.html#ae7dcb4b8d664d814b092f5f91609eac8" title="Cooks and creates a tetrahedron mesh without going through a stream.">PxCooking::createTetrahedronMesh</a> <a class="el" href="classphysx_1_1_px_cooking.html#a9cd44de3e5eb8bef6ad1bbd9b688d1fc" title="Cooks and creates a bounding volume hierarchy without going through a stream.">PxCooking::createBVH</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a18cb0dc683ee9e567184130db9c7cea1">physx::PxCooking</a>.</p>

</div>
</div>
<a id="ac23220df7ab1558e1e7dcec7371c0946" name="ac23220df7ab1558e1e7dcec7371c0946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23220df7ab1558e1e7dcec7371c0946">&#9670;&#160;</a></span>platformMismatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cooking::platformMismatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks endianness is the same between cooking &amp; target platforms. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there is and endian mismatch. </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a6c7437873827b8473b299629160f2919">physx::PxCooking</a>.</p>

</div>
</div>
<a id="aacb06fed2e722ef09ca68ff622791358" name="aacb06fed2e722ef09ca68ff622791358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb06fed2e722ef09ca68ff622791358">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cooking::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes this instance of the interface. </p>
<p>This function should be called to cleanly shut down the <a class="el" href="classphysx_1_1_cooking.html">Cooking</a> library before application exit.</p>
<dl class="section note"><dt>Note</dt><dd>This function is required to be called to release foundation usage. </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#ae7f3e78f4c406ffe811c05dfccd3ab68">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a678f224fec665d86d454750c583d1136" name="a678f224fec665d86d454750c583d1136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f224fec665d86d454750c583d1136">&#9670;&#160;</a></span>setParams()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cooking::setParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_cooking_params.html">PxCookingParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets cooking parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td><a class="el" href="classphysx_1_1_cooking.html">Cooking</a> parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#a96a1def0096fd40e460622e3fa8ca01b" title="Gets cooking parameters.">getParams()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a428331215e0859186ebab6f9abaddfa2">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a3c2a87aa4f96b994c94285bb5ebf49dc" name="a3c2a87aa4f96b994c94285bb5ebf49dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2a87aa4f96b994c94285bb5ebf49dc">&#9670;&#160;</a></span>validateConvexMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cooking::validateConvexMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_convex_mesh_desc.html">PxConvexMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies if the convex mesh is valid. Prints an error message for each inconsistency found. </p>
<p>The convex mesh descriptor must contain an already created convex mesh - the vertices, indices and polygons must be provided. <br  />
</p>
<dl class="section note"><dt>Note</dt><dd>This function should be used if <a class="el" href="structphysx_1_1_px_convex_flag.html#a90b3c67ca51c9757220b42a2a59ccbc9a2a7196f261aeee4bdf14d9354e98bd9d" title="Disables the convex mesh validation to speed-up hull creation. Please use separate validation functio...">PxConvexFlag::eDISABLE_MESH_VALIDATION</a> is planned to be used in release builds.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The convex mesh descriptor to read the mesh from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the validity conditions hold, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#af6c61af7aa13066c8125d1b163338a15" title="Cooks a convex mesh. The results are written to the stream.">cookConvexMesh()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#a73d5d3c3d04d96bf4a9263bd01d224e3">physx::PxCooking</a>.</p>

</div>
</div>
<a id="a322a7e6099be73fd4222f84abc39c001" name="a322a7e6099be73fd4222f84abc39c001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322a7e6099be73fd4222f84abc39c001">&#9670;&#160;</a></span>validateTriangleMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cooking::validateTriangleMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_triangle_mesh_desc.html">PxTriangleMeshDesc</a> &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found. </p>
<p>The following conditions are true for a valid triangle mesh:</p><ol type="1">
<li>There are no duplicate vertices (within specified vertexWeldTolerance. See <a class="el" href="structphysx_1_1_px_cooking_params.html#aeef752c31d11ade404d547b0ed8c388c" title="Mesh weld tolerance. If mesh welding is enabled, this controls the distance at which vertices are wel...">PxCookingParams::meshWeldTolerance</a>)</li>
<li>There are no large triangles (within specified <a class="el" href="classphysx_1_1_px_tolerances_scale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are calculated in term...">PxTolerancesScale</a>.)</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The triangle mesh descriptor to read the mesh from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all the validity conditions hold, false otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_cooking.html#a3ef225a197658f28c6f1e48bbbb90b12" title="Cooks a triangle mesh. The results are written to the stream.">cookTriangleMesh()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_cooking.html#aaccc1d9cf0e4a69a0f100c70a692cbdf">physx::PxCooking</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/physxcooking/src/<a class="el" href="_cooking_8h_source.html">Cooking.h</a></li>
<li>source/physxcooking/src/Cooking.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacephysx.html">physx</a></li><li class="navelem"><a class="el" href="classphysx_1_1_cooking.html">Cooking</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
