<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PhysX: ExtBatchQuery Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PhysX<span id="projectnumber">&#160;5.1.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_ext_batch_query.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ext_batch_query-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ExtBatchQuery Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for ExtBatchQuery:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_ext_batch_query.png" usemap="#ExtBatchQuery_map" alt=""/>
  <map id="ExtBatchQuery_map" name="ExtBatchQuery_map">
<area href="classphysx_1_1_px_batch_query_ext.html" alt="physx::PxBatchQueryExt" shape="rect" coords="0,0,150,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a81ae6a33cf5f59a6acd83535decc0847"><td class="memItemLeft" align="right" valign="top"><a id="a81ae6a33cf5f59a6acd83535decc0847" name="a81ae6a33cf5f59a6acd83535decc0847"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ExtBatchQuery</b> (const <a class="el" href="classphysx_1_1_px_scene.html">PxScene</a> &amp;scene, <a class="el" href="classphysx_1_1_px_query_filter_callback.html">PxQueryFilterCallback</a> *queryFilterCallback, <a class="el" href="namespacephysx.html#aadaf816b0479200a97713e1dda8744d6">PxRaycastBuffer</a> *raycastBuffers, Raycast *raycastQueries, const PxU32 maxNbRaycasts, <a class="el" href="structphysx_1_1_px_raycast_hit.html">PxRaycastHit</a> *raycastTouches, const PxU32 maxNbRaycastTouches, <a class="el" href="namespacephysx.html#a3b7e7fb7c8e61f32b50564aebb5e3009">PxSweepBuffer</a> *sweepBuffers, Sweep *sweepQueries, const PxU32 maxNbSweeps, <a class="el" href="structphysx_1_1_px_sweep_hit.html">PxSweepHit</a> *sweepTouches, const PxU32 maxNbSweepTouches, <a class="el" href="namespacephysx.html#a9af52a9fe9935b3aeca4d1aa6c72246f">PxOverlapBuffer</a> *overlapBuffers, Overlap *overlapQueries, const PxU32 maxNbOverlaps, <a class="el" href="structphysx_1_1_px_overlap_hit.html">PxOverlapHit</a> *overlapTouches, const PxU32 maxNbOverlapTouches)</td></tr>
<tr class="separator:a81ae6a33cf5f59a6acd83535decc0847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36cd080bed5984afc131058f6ec6f8b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ext_batch_query.html#a36cd080bed5984afc131058f6ec6f8b6">release</a> ()</td></tr>
<tr class="separator:a36cd080bed5984afc131058f6ec6f8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab359300fedf13efbcd8c4e8769142579"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#aadaf816b0479200a97713e1dda8744d6">PxRaycastBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ext_batch_query.html#ab359300fedf13efbcd8c4e8769142579">raycast</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;origin, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;unitDir, const PxReal distance, const PxU16 maxNbTouches, PxHitFlags hitFlags=PxHitFlags(PxHitFlag::eDEFAULT), const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a>(), const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *cache=NULL)</td></tr>
<tr class="memdesc:ab359300fedf13efbcd8c4e8769142579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a raycast against objects in the scene.  <br /></td></tr>
<tr class="separator:ab359300fedf13efbcd8c4e8769142579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3ac0a6288746dda385c901aa7bf828"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a3b7e7fb7c8e61f32b50564aebb5e3009">PxSweepBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ext_batch_query.html#a6c3ac0a6288746dda385c901aa7bf828">sweep</a> (const <a class="el" href="classphysx_1_1_px_geometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;pose, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;unitDir, const PxReal distance, const PxU16 maxNbTouches, PxHitFlags hitFlags=PxHitFlags(PxHitFlag::eDEFAULT), const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a>(), const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *cache=NULL, const PxReal inflation=0.f)</td></tr>
<tr class="memdesc:a6c3ac0a6288746dda385c901aa7bf828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep test against objects in the scene.  <br /></td></tr>
<tr class="separator:a6c3ac0a6288746dda385c901aa7bf828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b98ab214aaf0a546dd7d31b0d52001"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a9af52a9fe9935b3aeca4d1aa6c72246f">PxOverlapBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ext_batch_query.html#a02b98ab214aaf0a546dd7d31b0d52001">overlap</a> (const <a class="el" href="classphysx_1_1_px_geometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;pose, PxU16 maxNbTouches=0, const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a>(), const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *cache=NULL)</td></tr>
<tr class="memdesc:a02b98ab214aaf0a546dd7d31b0d52001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an overlap test of a given geometry against objects in the scene.  <br /></td></tr>
<tr class="separator:a02b98ab214aaf0a546dd7d31b0d52001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e88278bfe0ef3d2d1bbee4ef945d55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ext_batch_query.html#a47e88278bfe0ef3d2d1bbee4ef945d55">execute</a> ()</td></tr>
<tr class="separator:a47e88278bfe0ef3d2d1bbee4ef945d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee1ef8f35647eee469b72158071d399"><td class="memItemLeft" align="right" valign="top"><a id="a5ee1ef8f35647eee469b72158071d399" name="a5ee1ef8f35647eee469b72158071d399"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>release</b> ()=0</td></tr>
<tr class="separator:a5ee1ef8f35647eee469b72158071d399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b7ff16f5ef9bfd5a3c135f53128e3f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#aadaf816b0479200a97713e1dda8744d6">PxRaycastBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_batch_query_ext.html#a85b7ff16f5ef9bfd5a3c135f53128e3f">raycast</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;origin, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;unitDir, const PxReal distance, const PxU16 maxNbTouches=0, PxHitFlags hitFlags=PxHitFlags(PxHitFlag::eDEFAULT), const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a>(), const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *cache=NULL)=0</td></tr>
<tr class="memdesc:a85b7ff16f5ef9bfd5a3c135f53128e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a raycast against objects in the scene.  <br /></td></tr>
<tr class="separator:a85b7ff16f5ef9bfd5a3c135f53128e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a53948a4d978f51bd3aa213cd0651b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a3b7e7fb7c8e61f32b50564aebb5e3009">PxSweepBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_batch_query_ext.html#aa5a53948a4d978f51bd3aa213cd0651b">sweep</a> (const <a class="el" href="classphysx_1_1_px_geometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;pose, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;unitDir, const PxReal distance, const PxU16 maxNbTouches=0, PxHitFlags hitFlags=PxHitFlags(PxHitFlag::eDEFAULT), const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a>(), const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *cache=NULL, const PxReal inflation=0.0f)=0</td></tr>
<tr class="memdesc:aa5a53948a4d978f51bd3aa213cd0651b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep test against objects in the scene.  <br /></td></tr>
<tr class="separator:aa5a53948a4d978f51bd3aa213cd0651b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cbcbc9c20fc32c409f7bc2f2e6a19a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a9af52a9fe9935b3aeca4d1aa6c72246f">PxOverlapBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_batch_query_ext.html#ae2cbcbc9c20fc32c409f7bc2f2e6a19a">overlap</a> (const <a class="el" href="classphysx_1_1_px_geometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;pose, PxU16 maxNbTouches=0, const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;filterData=<a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a>(), const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *cache=NULL)=0</td></tr>
<tr class="memdesc:ae2cbcbc9c20fc32c409f7bc2f2e6a19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an overlap test of a given geometry against objects in the scene.  <br /></td></tr>
<tr class="separator:ae2cbcbc9c20fc32c409f7bc2f2e6a19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48262fa9c66b1201a649a6a690a4ed0"><td class="memItemLeft" align="right" valign="top"><a id="ad48262fa9c66b1201a649a6a690a4ed0" name="ad48262fa9c66b1201a649a6a690a4ed0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>execute</b> ()=0</td></tr>
<tr class="separator:ad48262fa9c66b1201a649a6a690a4ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a47e88278bfe0ef3d2d1bbee4ef945d55" name="a47e88278bfe0ef3d2d1bbee4ef945d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e88278bfe0ef3d2d1bbee4ef945d55">&#9670;&#160;</a></span>execute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ExtBatchQuery::execute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classphysx_1_1_px_batch_query_ext.html">physx::PxBatchQueryExt</a>.</p>

</div>
</div>
<a id="a02b98ab214aaf0a546dd7d31b0d52001" name="a02b98ab214aaf0a546dd7d31b0d52001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b98ab214aaf0a546dd7d31b0d52001">&#9670;&#160;</a></span>overlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacephysx.html#a9af52a9fe9935b3aeca4d1aa6c72246f">PxOverlapBuffer</a> * ExtBatchQuery::overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_geometry.html">PxGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU16&#160;</td>
          <td class="paramname"><em>maxNbTouches</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;&#160;</td>
          <td class="paramname"><em>filterData</em> = <code><a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *&#160;</td>
          <td class="paramname"><em>cache</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an overlap test of a given geometry against objects in the scene. </p>
<dl class="section note"><dt>Note</dt><dd>Filtering: returning eBLOCK from user filter for overlap queries will cause a warning (see #PxQueryHitType).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry</td><td>Geometry of object to check for overlap (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Pose of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxNbTouches</td><td>Maximum number of hits to record in the touch buffer for this query. Default=0 reports a single blocking hit. If maxTouchHits is set to 0 all hits are treated as blocking by default. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>Filtering data and simple logic. See #PxQueryFilterData #PxQueryFilterCallback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>Cached hit shape (optional). Query is tested against cached shape first. If no hit is found the ray gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. Note: Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>eBLOCK should not be returned from user filters for <a class="el" href="class_ext_batch_query.html#a02b98ab214aaf0a546dd7d31b0d52001" title="Performs an overlap test of a given geometry against objects in the scene.">overlap()</a>. Doing so will result in undefined behavior, and a warning will be issued. </dd>
<dd>
If the PxQueryFlag::eNO_BLOCK flag is set, the eBLOCK will instead be automatically converted to an eTOUCH and the warning suppressed. </dd>
<dd>
This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a PxOverlapBuffer pointer that will store the result of the query after execute() is completed. This will point either to an element of the buffer allocated on construction or to a user buffer passed to the constructor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>PxCreateBatchQueryExt</dd>
<dd>
PxQueryFilterData PxQueryFilterCallback </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_batch_query_ext.html#ae2cbcbc9c20fc32c409f7bc2f2e6a19a">physx::PxBatchQueryExt</a>.</p>

</div>
</div>
<a id="ab359300fedf13efbcd8c4e8769142579" name="ab359300fedf13efbcd8c4e8769142579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab359300fedf13efbcd8c4e8769142579">&#9670;&#160;</a></span>raycast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacephysx.html#aadaf816b0479200a97713e1dda8744d6">PxRaycastBuffer</a> * ExtBatchQuery::raycast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU16&#160;</td>
          <td class="paramname"><em>maxNbTouches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&#160;</td>
          <td class="paramname"><em>hitFlags</em> = <code>PxHitFlags(PxHitFlag::eDEFAULT)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;&#160;</td>
          <td class="paramname"><em>filterData</em> = <code><a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *&#160;</td>
          <td class="paramname"><em>cache</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a raycast against objects in the scene. </p>
<dl class="section note"><dt>Note</dt><dd>Touching hits are not ordered. </dd>
<dd>
Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in article SceneQuery. User can ignore such objects by using one of the provided filter mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Origin of the ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Normalized direction of the ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Length of the ray. Needs to be larger than 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxNbTouches</td><td>Maximum number of hits to record in the touch buffer for this query. Default=0 reports a single blocking hit. If maxTouchHits is set to 0 all hits are treated as blocking by default. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hitFlags</td><td>Specifies which properties per hit should be computed and returned in hit array and blocking hit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>Filtering data passed to the filter shader. See #PxQueryFilterData #PxQueryFilterCallback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>Cached hit shape (optional). Query is tested against cached shape first. If no hit is found the ray gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. Note: Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a PxRaycastBuffer pointer that will store the result of the query after execute() is completed. This will point either to an element of the buffer allocated on construction or to a user buffer passed to the constructor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>PxCreateBatchQueryExt</dd>
<dd>
PxQueryFilterData PxQueryFilterCallback PxRaycastHit PxScene::raycast </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_batch_query_ext.html#a85b7ff16f5ef9bfd5a3c135f53128e3f">physx::PxBatchQueryExt</a>.</p>

</div>
</div>
<a id="a36cd080bed5984afc131058f6ec6f8b6" name="a36cd080bed5984afc131058f6ec6f8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36cd080bed5984afc131058f6ec6f8b6">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ExtBatchQuery::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classphysx_1_1_px_batch_query_ext.html">physx::PxBatchQueryExt</a>.</p>

</div>
</div>
<a id="a6c3ac0a6288746dda385c901aa7bf828" name="a6c3ac0a6288746dda385c901aa7bf828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3ac0a6288746dda385c901aa7bf828">&#9670;&#160;</a></span>sweep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacephysx.html#a3b7e7fb7c8e61f32b50564aebb5e3009">PxSweepBuffer</a> * ExtBatchQuery::sweep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_geometry.html">PxGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU16&#160;</td>
          <td class="paramname"><em>maxNbTouches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&#160;</td>
          <td class="paramname"><em>hitFlags</em> = <code>PxHitFlags(PxHitFlag::eDEFAULT)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;&#160;</td>
          <td class="paramname"><em>filterData</em> = <code><a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *&#160;</td>
          <td class="paramname"><em>cache</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>inflation</em> = <code>0.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep test against objects in the scene. </p>
<dl class="section note"><dt>Note</dt><dd>Touching hits are not ordered. </dd>
<dd>
If a shape from the scene is already overlapping with the query shape in its starting position, the hit is returned unless eASSUME_NO_INITIAL_OVERLAP was specified.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry</td><td>Geometry of object to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Pose of the sweep object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Sweep distance. Needs to be larger than 0. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxNbTouches</td><td>Maximum number of hits to record in the touch buffer for this query. Default=0 reports a single blocking hit. If maxTouchHits is set to 0 all hits are treated as blocking by default. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hitFlags</td><td>Specifies which properties per hit should be computed and returned in hit array and blocking hit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>Filtering data and simple logic. See #PxQueryFilterData #PxQueryFilterCallback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>Cached hit shape (optional). Query is tested against cached shape first. If no hit is found the ray gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. Note: Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inflation</td><td>This parameter creates a skin around the swept geometry which increases its extents for sweeping. The sweep will register a hit as soon as the skin touches a shape, and will return the corresponding distance and normal. Note: ePRECISE_SWEEP doesn't support inflation. Therefore the sweep will be performed with zero inflation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This query call writes to a list associated with the query object and is NOT thread safe (for performance reasons there is no lock and overlapping writes from different threads may result in undefined behavior).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a PxSweepBuffer pointer that will store the result of the query after execute() is completed. This will point either to an element of the buffer allocated on construction or to a user buffer passed to the constructor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>PxCreateBatchQueryExt</dd>
<dd>
PxHitFlags PxQueryFilterData PxBatchQueryPreFilterShader PxBatchQueryPostFilterShader PxSweepHit </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_batch_query_ext.html#aa5a53948a4d978f51bd3aa213cd0651b">physx::PxBatchQueryExt</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>source/physxextensions/src/ExtSceneQueryExt.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_ext_batch_query.html">ExtBatchQuery</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
