<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PhysX: physx::PxSoftBody Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PhysX<span id="projectnumber">&#160;5.1.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classphysx_1_1_px_soft_body.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classphysx_1_1_px_soft_body-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">physx::PxSoftBody Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a FEM softbody including everything to calculate its definition like geometry and material properties.  
 <a href="classphysx_1_1_px_soft_body.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_px_soft_body_8h_source.html">PxSoftBody.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for physx::PxSoftBody:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classphysx_1_1_px_soft_body.png" usemap="#physx::PxSoftBody_map" alt=""/>
  <map id="physx::PxSoftBody_map" name="physx::PxSoftBody_map">
<area href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="physx::PxActor" shape="rect" coords="0,56,237,80"/>
<area href="classphysx_1_1_px_base.html" title="Base class for objects that can be members of a PxCollection." alt="physx::PxBase" shape="rect" coords="0,0,237,24"/>
<area href="classphysx_1_1_np_actor_template.html" alt="physx::NpActorTemplate&lt; PxSoftBody &gt;" shape="rect" coords="0,168,237,192"/>
<area href="classphysx_1_1_np_soft_body.html" alt="physx::NpSoftBody" shape="rect" coords="0,224,237,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43ba0e4e924c32131b00ba0d15ac5599"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a43ba0e4e924c32131b00ba0d15ac5599">setSoftBodyFlag</a> (<a class="el" href="structphysx_1_1_px_soft_body_flag.html#ad392f0ca084f5a0ec7f110b8c2476315">PxSoftBodyFlag::Enum</a> flag, bool val)=0</td></tr>
<tr class="memdesc:a43ba0e4e924c32131b00ba0d15ac5599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single softbody flag.  <br /></td></tr>
<tr class="separator:a43ba0e4e924c32131b00ba0d15ac5599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9ef79efcb2011b47bf133769535c64"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#add9ef79efcb2011b47bf133769535c64">setSoftBodyFlags</a> (<a class="el" href="classphysx_1_1_px_flags.html">PxSoftBodyFlags</a> flags)=0</td></tr>
<tr class="memdesc:add9ef79efcb2011b47bf133769535c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the softbody flags.  <br /></td></tr>
<tr class="separator:add9ef79efcb2011b47bf133769535c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56e6ff5f75fcce761f81155322afc94"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_flags.html">PxSoftBodyFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ad56e6ff5f75fcce761f81155322afc94">getSoftBodyFlag</a> () const =0</td></tr>
<tr class="memdesc:ad56e6ff5f75fcce761f81155322afc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the softbody flags.  <br /></td></tr>
<tr class="separator:ad56e6ff5f75fcce761f81155322afc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac90eaf62454ee3a35d824a5ac3668e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aac90eaf62454ee3a35d824a5ac3668e4">setParameter</a> (const <a class="el" href="structphysx_1_1_px_f_e_m_parameters.html">PxFEMParameters</a> parameters)=0</td></tr>
<tr class="memdesc:aac90eaf62454ee3a35d824a5ac3668e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parameter for FEM internal solve.  <br /></td></tr>
<tr class="separator:aac90eaf62454ee3a35d824a5ac3668e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae482aec041036f6187163848d1b8aaf0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_f_e_m_parameters.html">PxFEMParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ae482aec041036f6187163848d1b8aaf0">getParameter</a> () const =0</td></tr>
<tr class="memdesc:ae482aec041036f6187163848d1b8aaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get parameter for FEM internal solve.  <br /></td></tr>
<tr class="separator:ae482aec041036f6187163848d1b8aaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977c8932888461538bba4f33395c650c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a977c8932888461538bba4f33395c650c">readData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> &amp;buffer, bool flush=false)=0</td></tr>
<tr class="memdesc:a977c8932888461538bba4f33395c650c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a read command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:a977c8932888461538bba4f33395c650c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e154c7880a2f81bbb137bbef4b1a0fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a7e154c7880a2f81bbb137bbef4b1a0fd">readData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, bool flush=false)=0</td></tr>
<tr class="memdesc:a7e154c7880a2f81bbb137bbef4b1a0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a read command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:a7e154c7880a2f81bbb137bbef4b1a0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c79d6afd0c16411d2e45a5f1cc56252"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a3c79d6afd0c16411d2e45a5f1cc56252">writeData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> &amp;buffer, bool flush=false)=0</td></tr>
<tr class="memdesc:a3c79d6afd0c16411d2e45a5f1cc56252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a write command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:a3c79d6afd0c16411d2e45a5f1cc56252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fccbe8185a375cf42f9362d59f9748"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ad7fccbe8185a375cf42f9362d59f9748">writeData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, bool flush=false)=0</td></tr>
<tr class="memdesc:ad7fccbe8185a375cf42f9362d59f9748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a write command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:ad7fccbe8185a375cf42f9362d59f9748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8418698e3c39c87b07946a7f81cf2b23"><td class="memItemLeft" align="right" valign="top">virtual PxCudaContextManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a8418698e3c39c87b07946a7f81cf2b23">getCudaContextManager</a> () const =0</td></tr>
<tr class="memdesc:a8418698e3c39c87b07946a7f81cf2b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cuda context manager.  <br /></td></tr>
<tr class="separator:a8418698e3c39c87b07946a7f81cf2b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478d801eed43606ac4e06b48c883e137"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a478d801eed43606ac4e06b48c883e137">setWakeCounter</a> (PxReal wakeCounterValue)=0</td></tr>
<tr class="memdesc:a478d801eed43606ac4e06b48c883e137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wake counter for the soft body.  <br /></td></tr>
<tr class="separator:a478d801eed43606ac4e06b48c883e137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18445e28706f4fa7f493c707eca4ef22"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a18445e28706f4fa7f493c707eca4ef22">getWakeCounter</a> () const =0</td></tr>
<tr class="memdesc:a18445e28706f4fa7f493c707eca4ef22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wake counter of the soft body.  <br /></td></tr>
<tr class="separator:a18445e28706f4fa7f493c707eca4ef22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131f8915719ffda345077d99118d946f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a131f8915719ffda345077d99118d946f">isSleeping</a> () const =0</td></tr>
<tr class="memdesc:a131f8915719ffda345077d99118d946f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this soft body is sleeping.  <br /></td></tr>
<tr class="separator:a131f8915719ffda345077d99118d946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99548c514e09862494287eee688b0a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ab99548c514e09862494287eee688b0a1">setSolverIterationCounts</a> (PxU32 minPositionIters, PxU32 minVelocityIters=1)=0</td></tr>
<tr class="memdesc:ab99548c514e09862494287eee688b0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the solver iteration counts for the body.  <br /></td></tr>
<tr class="separator:ab99548c514e09862494287eee688b0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801ea01a7236f962fad8fca8adf8321e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a801ea01a7236f962fad8fca8adf8321e">getSolverIterationCounts</a> (PxU32 &amp;minPositionIters, PxU32 &amp;minVelocityIters) const =0</td></tr>
<tr class="memdesc:a801ea01a7236f962fad8fca8adf8321e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the solver iteration counts.  <br /></td></tr>
<tr class="separator:a801ea01a7236f962fad8fca8adf8321e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e7f27f4209373f2dcce01448faa906"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a85e7f27f4209373f2dcce01448faa906">getShape</a> ()=0</td></tr>
<tr class="memdesc:a85e7f27f4209373f2dcce01448faa906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the shape pointer belonging to the actor.  <br /></td></tr>
<tr class="separator:a85e7f27f4209373f2dcce01448faa906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0473f9bb9b0e36c07c2754e001a22d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a9c0473f9bb9b0e36c07c2754e001a22d">getCollisionMesh</a> ()=0</td></tr>
<tr class="memdesc:a9c0473f9bb9b0e36c07c2754e001a22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the collision mesh pointer.  <br /></td></tr>
<tr class="separator:a9c0473f9bb9b0e36c07c2754e001a22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f670bd0d2719c737aa52f562bd1a31"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ad2f670bd0d2719c737aa52f562bd1a31">getSimulationMesh</a> ()=0</td></tr>
<tr class="memdesc:ad2f670bd0d2719c737aa52f562bd1a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the simulation mesh pointer.  <br /></td></tr>
<tr class="separator:ad2f670bd0d2719c737aa52f562bd1a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e96324d4a20e9938900df58e2bd074"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_soft_body_aux_data.html">PxSoftBodyAuxData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a46e96324d4a20e9938900df58e2bd074">getSoftBodyAuxData</a> ()=0</td></tr>
<tr class="memdesc:a46e96324d4a20e9938900df58e2bd074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the simulation state pointer.  <br /></td></tr>
<tr class="separator:a46e96324d4a20e9938900df58e2bd074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa602720974de655d95049ac7dcee3c96"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aa602720974de655d95049ac7dcee3c96">attachShape</a> (<a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> &amp;shape)=0</td></tr>
<tr class="memdesc:aa602720974de655d95049ac7dcee3c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a shape.  <br /></td></tr>
<tr class="separator:aa602720974de655d95049ac7dcee3c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1358e4fc28d149ee1287edebd4240afe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a1358e4fc28d149ee1287edebd4240afe">attachSimulationMesh</a> (<a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> &amp;simulationMesh, <a class="el" href="classphysx_1_1_px_soft_body_aux_data.html">PxSoftBodyAuxData</a> &amp;softBodyAuxData)=0</td></tr>
<tr class="memdesc:a1358e4fc28d149ee1287edebd4240afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a simulation mesh.  <br /></td></tr>
<tr class="separator:a1358e4fc28d149ee1287edebd4240afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e89cb3118981013838932b5328b2eb3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a8e89cb3118981013838932b5328b2eb3">detachShape</a> ()=0</td></tr>
<tr class="memdesc:a8e89cb3118981013838932b5328b2eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the shape.  <br /></td></tr>
<tr class="separator:a8e89cb3118981013838932b5328b2eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45855574b47484673ddbc1b7b919e499"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a45855574b47484673ddbc1b7b919e499">detachSimulationMesh</a> ()=0</td></tr>
<tr class="memdesc:a45855574b47484673ddbc1b7b919e499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the simulation mesh.  <br /></td></tr>
<tr class="separator:a45855574b47484673ddbc1b7b919e499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd25cee2966691df649efab08c66648b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#abd25cee2966691df649efab08c66648b">release</a> ()=0</td></tr>
<tr class="memdesc:abd25cee2966691df649efab08c66648b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the softbody.  <br /></td></tr>
<tr class="separator:abd25cee2966691df649efab08c66648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe61c672f855820507b4ca39eaf44c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a7fe61c672f855820507b4ca39eaf44c3">addParticleFilter</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *buffer, PxU32 particleId, PxU32 tetId)=0</td></tr>
<tr class="memdesc:a7fe61c672f855820507b4ca39eaf44c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a collision filter between a particle and a tetrahedron in the soft body's collision mesh.  <br /></td></tr>
<tr class="separator:a7fe61c672f855820507b4ca39eaf44c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e58d78320439bfa33d1806dcc172ed5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a6e58d78320439bfa33d1806dcc172ed5">removeParticleFilter</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *buffer, PxU32 particleId, PxU32 tetId)=0</td></tr>
<tr class="memdesc:a6e58d78320439bfa33d1806dcc172ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a collision filter between a particle and a tetrahedron in the soft body's collision mesh.  <br /></td></tr>
<tr class="separator:a6e58d78320439bfa33d1806dcc172ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeaf25e7ea0ff2976a0cb39e20cff26"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aaaeaf25e7ea0ff2976a0cb39e20cff26">addParticleAttachment</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *buffer, PxU32 particleId, PxU32 tetId, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;barycentric)=0</td></tr>
<tr class="memdesc:aaaeaf25e7ea0ff2976a0cb39e20cff26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not.  <br /></td></tr>
<tr class="separator:aaaeaf25e7ea0ff2976a0cb39e20cff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab99896beb748035721e2475893d3bfd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aab99896beb748035721e2475893d3bfd">removeParticleAttachment</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, PxU32 handle)=0</td></tr>
<tr class="memdesc:aab99896beb748035721e2475893d3bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not.  <br /></td></tr>
<tr class="separator:aab99896beb748035721e2475893d3bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d283966ec1724c1833be787bdc51ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a34d283966ec1724c1833be787bdc51ee">addRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 vertId)=0</td></tr>
<tr class="memdesc:a34d283966ec1724c1833be787bdc51ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a collision filter between a vertex in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:a34d283966ec1724c1833be787bdc51ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fa0a9aa318e559478c127e771cb86a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ae8fa0a9aa318e559478c127e771cb86a">removeRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 vertId)=0</td></tr>
<tr class="memdesc:ae8fa0a9aa318e559478c127e771cb86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a collision filter between a vertex in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:ae8fa0a9aa318e559478c127e771cb86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0df35db3b120d40bc457fe46edf1923"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ab0df35db3b120d40bc457fe46edf1923">addRigidAttachment</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 vertId, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;actorSpacePose, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint=NULL)=0</td></tr>
<tr class="memdesc:ab0df35db3b120d40bc457fe46edf1923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <br /></td></tr>
<tr class="separator:ab0df35db3b120d40bc457fe46edf1923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3807a77c6ce9fc27b472a1f4093bcb7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a3807a77c6ce9fc27b472a1f4093bcb7e">removeRigidAttachment</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 handle)=0</td></tr>
<tr class="memdesc:a3807a77c6ce9fc27b472a1f4093bcb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <br /></td></tr>
<tr class="separator:a3807a77c6ce9fc27b472a1f4093bcb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1223e4814b8b781fe274d549492cde9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a1223e4814b8b781fe274d549492cde9f">addTetRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 tetIdx)=0</td></tr>
<tr class="memdesc:a1223e4814b8b781fe274d549492cde9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filter between a tetrahedron in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:a1223e4814b8b781fe274d549492cde9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cc13579616f7f83ff7d9eb046dfc44"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ac2cc13579616f7f83ff7d9eb046dfc44">removeTetRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 tetIdx)=0</td></tr>
<tr class="memdesc:ac2cc13579616f7f83ff7d9eb046dfc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filter between a tetrahedron in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:ac2cc13579616f7f83ff7d9eb046dfc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4efd157fd4bceabee9d278c34dcda7"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#abe4efd157fd4bceabee9d278c34dcda7">addTetRigidAttachment</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 tetIdx, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;barycentric, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;actorSpacePose, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint=NULL)=0</td></tr>
<tr class="memdesc:abe4efd157fd4bceabee9d278c34dcda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <br /></td></tr>
<tr class="separator:abe4efd157fd4bceabee9d278c34dcda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51d32b513aea14f5f15c8e7982b5bf3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ac51d32b513aea14f5f15c8e7982b5bf3">addSoftBodyFilter</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *otherSoftBody, PxU32 otherTetIdx, PxU32 tetIdx1)=0</td></tr>
<tr class="memdesc:ac51d32b513aea14f5f15c8e7982b5bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filter between a tetrahedron in a soft body and a tetrahedron in another soft body.  <br /></td></tr>
<tr class="separator:ac51d32b513aea14f5f15c8e7982b5bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c8c3660b669a7bb65226e816248886"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ab4c8c3660b669a7bb65226e816248886">removeSoftBodyFilter</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *otherSoftBody, PxU32 otherTetIdx, PxU32 tetIdx1)=0</td></tr>
<tr class="memdesc:ab4c8c3660b669a7bb65226e816248886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filter between a tetrahedron in a soft body and a tetrahedron in other soft body.  <br /></td></tr>
<tr class="separator:ab4c8c3660b669a7bb65226e816248886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33c57f9d8f328b206398c3e8b551861"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ae33c57f9d8f328b206398c3e8b551861">addSoftBodyFilters</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *otherSoftBody, PxU32 *otherTetIndices, PxU32 *tetIndices, PxU32 tetIndicesSize)=0</td></tr>
<tr class="memdesc:ae33c57f9d8f328b206398c3e8b551861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filters between a tetrahedron in a soft body with another soft body.  <br /></td></tr>
<tr class="separator:ae33c57f9d8f328b206398c3e8b551861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae814d96255b19f85fdb33043bb862fba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ae814d96255b19f85fdb33043bb862fba">removeSoftBodyFilters</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *otherSoftBody, PxU32 *otherTetIndices, PxU32 *tetIndices, PxU32 tetIndicesSize)=0</td></tr>
<tr class="memdesc:ae814d96255b19f85fdb33043bb862fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filters between a tetrahedron in a soft body with another soft body.  <br /></td></tr>
<tr class="separator:ae814d96255b19f85fdb33043bb862fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c6454c000cdf9b96e9ae58a826041f"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a29c6454c000cdf9b96e9ae58a826041f">addSoftBodyAttachment</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *softbody0, PxU32 tetIdx0, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;tetBarycentric0, PxU32 tetIdx1, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;tetBarycentric1, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint=NULL)=0</td></tr>
<tr class="memdesc:a29c6454c000cdf9b96e9ae58a826041f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an attachment between two soft bodies.  <br /></td></tr>
<tr class="separator:a29c6454c000cdf9b96e9ae58a826041f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6acf80193100b2713a0e58229611b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aee6acf80193100b2713a0e58229611b5">removeSoftBodyAttachment</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *softbody0, PxU32 handle)=0</td></tr>
<tr class="memdesc:aee6acf80193100b2713a0e58229611b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attachment between a soft body and the other soft body. Be aware that destroying the soft body before destroying the attachment is illegal and may cause a crash.  <br /></td></tr>
<tr class="separator:aee6acf80193100b2713a0e58229611b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1da16afabd826cc9db106f1749edbd4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#af1da16afabd826cc9db106f1749edbd4">addClothFilter</a> (PxFEMCloth *cloth, PxU32 triIdx, PxU32 tetIdx)=0</td></tr>
<tr class="memdesc:af1da16afabd826cc9db106f1749edbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filter between a tetrahedron in a soft body and a triangle in a cloth.  <br /></td></tr>
<tr class="separator:af1da16afabd826cc9db106f1749edbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253209fa24469ac27d7ddf9109203acd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a253209fa24469ac27d7ddf9109203acd">removeClothFilter</a> (PxFEMCloth *cloth, PxU32 triIdx, PxU32 tetIdx)=0</td></tr>
<tr class="memdesc:a253209fa24469ac27d7ddf9109203acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filter between a tetrahedron in a soft body and a triangle in a cloth.  <br /></td></tr>
<tr class="separator:a253209fa24469ac27d7ddf9109203acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb8c9c3b1a546dcc8b5ed73d854da21"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#abbb8c9c3b1a546dcc8b5ed73d854da21">addClothAttachment</a> (PxFEMCloth *cloth, PxU32 triIdx, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;triBarycentric, PxU32 tetIdx, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;tetBarycentric, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint=NULL)=0</td></tr>
<tr class="memdesc:abbb8c9c3b1a546dcc8b5ed73d854da21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an attachment between a soft body and a cloth. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the cloth does not.  <br /></td></tr>
<tr class="separator:abbb8c9c3b1a546dcc8b5ed73d854da21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0e444fad640b513acc99f42f7a6f56"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#acb0e444fad640b513acc99f42f7a6f56">removeClothAttachment</a> (PxFEMCloth *cloth, PxU32 handle)=0</td></tr>
<tr class="memdesc:acb0e444fad640b513acc99f42f7a6f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attachment between a cloth and a soft body. Be aware that destroying the cloth before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the cloth does not.  <br /></td></tr>
<tr class="separator:acb0e444fad640b513acc99f42f7a6f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13967dbaef4161b72e48f685c39b077"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#af13967dbaef4161b72e48f685c39b077">getSimPositionInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:af13967dbaef4161b72e48f685c39b077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the simulation mesh on the host.  <br /></td></tr>
<tr class="separator:af13967dbaef4161b72e48f685c39b077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b2dba42ea1ab7e59a27b30d4a7203b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aa7b2dba42ea1ab7e59a27b30d4a7203b">getKinematicTargetCPU</a> ()=0</td></tr>
<tr class="memdesc:aa7b2dba42ea1ab7e59a27b30d4a7203b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the simulation mesh on the host.  <br /></td></tr>
<tr class="separator:aa7b2dba42ea1ab7e59a27b30d4a7203b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a56a2c3af0a2b35b10c054bef2baa7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ae9a56a2c3af0a2b35b10c054bef2baa7">getSimVelocityInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:ae9a56a2c3af0a2b35b10c054bef2baa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the velocities of the simulation mesh on the host.  <br /></td></tr>
<tr class="separator:ae9a56a2c3af0a2b35b10c054bef2baa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cea5ff304ad2d73c3e71147613e818f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a4cea5ff304ad2d73c3e71147613e818f">getPositionInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:a4cea5ff304ad2d73c3e71147613e818f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the collision mesh on the host.  <br /></td></tr>
<tr class="separator:a4cea5ff304ad2d73c3e71147613e818f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed600012be729205b6a2ce757199a9e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aed600012be729205b6a2ce757199a9e1">getRestPositionInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:aed600012be729205b6a2ce757199a9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the rest vertices of the collision mesh on the host.  <br /></td></tr>
<tr class="separator:aed600012be729205b6a2ce757199a9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486959160c394478b2f37b8cb1dea091"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a486959160c394478b2f37b8cb1dea091">getWorldBounds</a> (float inflation=1.01f) const =0</td></tr>
<tr class="memdesc:a486959160c394478b2f37b8cb1dea091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the soft body.  <br /></td></tr>
<tr class="separator:a486959160c394478b2f37b8cb1dea091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3867e1e682567681e73ee0f68828069c"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a3867e1e682567681e73ee0f68828069c">getGpuSoftBodyIndex</a> ()=0</td></tr>
<tr class="memdesc:a3867e1e682567681e73ee0f68828069c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GPU soft body index.  <br /></td></tr>
<tr class="separator:a3867e1e682567681e73ee0f68828069c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea6c35b687859239b5a889692ebac94"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a3ea6c35b687859239b5a889692ebac94">getConcreteTypeName</a> () const <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="memdesc:a3ea6c35b687859239b5a889692ebac94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string name of dynamic type.  <br /></td></tr>
<tr class="separator:a3ea6c35b687859239b5a889692ebac94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_actor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_actor.html">physx::PxActor</a></td></tr>
<tr class="memitem:a782e6bd48fb10f393581302d428eee19 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a782e6bd48fb10f393581302d428eee19">release</a> ()=0</td></tr>
<tr class="memdesc:a782e6bd48fb10f393581302d428eee19 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the actor.  <br /></td></tr>
<tr class="separator:a782e6bd48fb10f393581302d428eee19 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff803bacb565652fb46ab69cda1d2526 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_actor_type.html#aa12d1dbb97bda016f592de47e67e3963">PxActorType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aff803bacb565652fb46ab69cda1d2526">getType</a> () const =0</td></tr>
<tr class="memdesc:aff803bacb565652fb46ab69cda1d2526 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the type of actor.  <br /></td></tr>
<tr class="separator:aff803bacb565652fb46ab69cda1d2526 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002cfb766d7d8aa71f174980fe7b1c6b inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_scene.html">PxScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a002cfb766d7d8aa71f174980fe7b1c6b">getScene</a> () const =0</td></tr>
<tr class="memdesc:a002cfb766d7d8aa71f174980fe7b1c6b inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the scene which this actor belongs to.  <br /></td></tr>
<tr class="separator:a002cfb766d7d8aa71f174980fe7b1c6b inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab374c355cdd9c9b5a93479a8c751704a inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#ab374c355cdd9c9b5a93479a8c751704a">setName</a> (const char *name)=0</td></tr>
<tr class="memdesc:ab374c355cdd9c9b5a93479a8c751704a inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classphysx_1_1_px_actor.html#aad553a24aa6546e93bfb887d0c27fba9" title="Retrieves the name string set with setName().">getName()</a>.  <br /></td></tr>
<tr class="separator:ab374c355cdd9c9b5a93479a8c751704a inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad553a24aa6546e93bfb887d0c27fba9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aad553a24aa6546e93bfb887d0c27fba9">getName</a> () const =0</td></tr>
<tr class="memdesc:aad553a24aa6546e93bfb887d0c27fba9 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the name string set with <a class="el" href="classphysx_1_1_px_actor.html#ab374c355cdd9c9b5a93479a8c751704a" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>.  <br /></td></tr>
<tr class="separator:aad553a24aa6546e93bfb887d0c27fba9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4121e4d3f38d9303b840159ac18bc5d inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#ab4121e4d3f38d9303b840159ac18bc5d">getWorldBounds</a> (float inflation=1.01f) const =0</td></tr>
<tr class="memdesc:ab4121e4d3f38d9303b840159ac18bc5d inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the actor.  <br /></td></tr>
<tr class="separator:ab4121e4d3f38d9303b840159ac18bc5d inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6587b0a441c214a3f4504099105e298f inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a6587b0a441c214a3f4504099105e298f">setActorFlag</a> (<a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8">PxActorFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:a6587b0a441c214a3f4504099105e298f inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular actor flag.  <br /></td></tr>
<tr class="separator:a6587b0a441c214a3f4504099105e298f inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47d905605f403aa95aee541a772b696 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aa47d905605f403aa95aee541a772b696">setActorFlags</a> (<a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a> inFlags)=0</td></tr>
<tr class="memdesc:aa47d905605f403aa95aee541a772b696 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the actor flags.  <br /></td></tr>
<tr class="separator:aa47d905605f403aa95aee541a772b696 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3aebddb7b31092182606c61398983a inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a5d3aebddb7b31092182606c61398983a">getActorFlags</a> () const =0</td></tr>
<tr class="memdesc:a5d3aebddb7b31092182606c61398983a inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> flags.  <br /></td></tr>
<tr class="separator:a5d3aebddb7b31092182606c61398983a inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3786b0f53c9a37074372d0ea62ce348d inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a3786b0f53c9a37074372d0ea62ce348d">setDominanceGroup</a> (<a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a> dominanceGroup)=0</td></tr>
<tr class="memdesc:a3786b0f53c9a37074372d0ea62ce348d inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns dynamic actors a dominance group identifier.  <br /></td></tr>
<tr class="separator:a3786b0f53c9a37074372d0ea62ce348d inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7effc9b077780ffd713baa8869feae inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a4b7effc9b077780ffd713baa8869feae">getDominanceGroup</a> () const =0</td></tr>
<tr class="memdesc:a4b7effc9b077780ffd713baa8869feae inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value set with <a class="el" href="classphysx_1_1_px_actor.html#a3786b0f53c9a37074372d0ea62ce348d" title="Assigns dynamic actors a dominance group identifier.">setDominanceGroup()</a>.  <br /></td></tr>
<tr class="separator:a4b7effc9b077780ffd713baa8869feae inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160170378b1a28ef6f82f9c603b3cdf9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a160170378b1a28ef6f82f9c603b3cdf9">setOwnerClient</a> (<a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a> inClient)=0</td></tr>
<tr class="memdesc:a160170378b1a28ef6f82f9c603b3cdf9 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the owner client of an actor.  <br /></td></tr>
<tr class="separator:a160170378b1a28ef6f82f9c603b3cdf9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fe5ab2d87b2cded54153370492875 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a0f3fe5ab2d87b2cded54153370492875">getOwnerClient</a> () const =0</td></tr>
<tr class="memdesc:a0f3fe5ab2d87b2cded54153370492875 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the owner client that was specified at creation time.  <br /></td></tr>
<tr class="separator:a0f3fe5ab2d87b2cded54153370492875 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2001117af8250e4afc077e160307aa13 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a2001117af8250e4afc077e160307aa13">getAggregate</a> () const =0</td></tr>
<tr class="memdesc:a2001117af8250e4afc077e160307aa13 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the aggregate the actor might be a part of.  <br /></td></tr>
<tr class="separator:a2001117af8250e4afc077e160307aa13 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a09013f88c156cfcdfcb001611360e92c">release</a> ()=0</td></tr>
<tr class="memdesc:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the <a class="el" href="classphysx_1_1_px_base.html" title="Base class for objects that can be members of a PxCollection.">PxBase</a> instance, please check documentation of release in derived class.  <br /></td></tr>
<tr class="separator:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aea4c4ef95da2697f36d3a9fc9a2f897a">getConcreteTypeName</a> () const =0</td></tr>
<tr class="memdesc:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string name of dynamic type.  <br /></td></tr>
<tr class="separator:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="a76be84f268e30c6fcb62a413963908db" name="a76be84f268e30c6fcb62a413963908db"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is</b> ()</td></tr>
<tr class="separator:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="a114ba2d2c3e2e50368c7003660b7e78d" name="a114ba2d2c3e2e50368c7003660b7e78d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is</b> () const</td></tr>
<tr class="separator:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> PxType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aeb75b831810e817d266223ccb244f3e4">getConcreteType</a> () const</td></tr>
<tr class="memdesc:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns concrete type of object.  <br /></td></tr>
<tr class="separator:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aa1f16f63ebbcad8aff05560d28709ff0">setBaseFlag</a> (PxBaseFlag::Enum flag, bool value)</td></tr>
<tr class="memdesc:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="structphysx_1_1_px_base_flag.html" title="Flags for PxBase.">PxBaseFlag</a> <br  />
  <br /></td></tr>
<tr class="separator:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a87724fce99cffbdd787a13391e58c04e">setBaseFlags</a> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> inFlags)</td></tr>
<tr class="memdesc:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PxBaseFlags <br  />
  <br /></td></tr>
<tr class="separator:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a1f7953973ba7e246effc9d4f6e6f34ab">getBaseFlags</a> () const</td></tr>
<tr class="memdesc:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns PxBaseFlags.  <br /></td></tr>
<tr class="separator:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a43f6a532bcc3da9e6fc8977094f419d9">isReleasable</a> () const</td></tr>
<tr class="memdesc:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the object is subordinate.  <br /></td></tr>
<tr class="separator:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6c6716eec721065ea5ac640f850eafa5"><td class="memItemLeft" align="right" valign="top"><a id="a6c6716eec721065ea5ac640f850eafa5" name="a6c6716eec721065ea5ac640f850eafa5"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxSoftBody</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a6c6716eec721065ea5ac640f850eafa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05e4f32c556aa6bacfbd1ea9bac2c96"><td class="memItemLeft" align="right" valign="top"><a id="af05e4f32c556aa6bacfbd1ea9bac2c96" name="af05e4f32c556aa6bacfbd1ea9bac2c96"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxSoftBody</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:af05e4f32c556aa6bacfbd1ea9bac2c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2829fb17dad1d3e808e74db36006c5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ace2829fb17dad1d3e808e74db36006c5">isKindOf</a> (const char *name) const <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="memdesc:ace2829fb17dad1d3e808e74db36006c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:ace2829fb17dad1d3e808e74db36006c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_actor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_actor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_actor.html">physx::PxActor</a></td></tr>
<tr class="memitem:a38b030b8d43f75ca6a0011d369369fdf inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="a38b030b8d43f75ca6a0011d369369fdf" name="a38b030b8d43f75ca6a0011d369369fdf"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxActor</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a38b030b8d43f75ca6a0011d369369fdf inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d98db236080d8bdb8f7dd179d84bde inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="ad8d98db236080d8bdb8f7dd179d84bde" name="ad8d98db236080d8bdb8f7dd179d84bde"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxActor</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:ad8d98db236080d8bdb8f7dd179d84bde inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a538ec41302af60afec0df10f31f4ab24">isKindOf</a> (const char *name) const</td></tr>
<tr class="memdesc:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a92f28ef9d2c863db69d316e68375fac5" name="a92f28ef9d2c863db69d316e68375fac5"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxBase</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor setting concrete type and base flags. <br /></td></tr>
<tr class="separator:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a4f41a74f151437e79ea1fb075df19cbc" name="a4f41a74f151437e79ea1fb075df19cbc"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxBase</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialization constructor setting base flags. <br /></td></tr>
<tr class="separator:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="adcee0bb92feaaaaeb2340d7304af1830" name="adcee0bb92feaaaaeb2340d7304af1830"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PxBase</b> ()</td></tr>
<tr class="memdesc:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a8645a6d66bcc1df05a82bf3be518cb55">isKindOf</a> (const char *superClass) const</td></tr>
<tr class="memdesc:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="abcfbbbce797c885d67969f6c5b975601" name="abcfbbbce797c885d67969f6c5b975601"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeMatch</b> () const</td></tr>
<tr class="separator:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classphysx_1_1_px_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classphysx_1_1_px_actor')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classphysx_1_1_px_actor.html">physx::PxActor</a></td></tr>
<tr class="memitem:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="a85d97eb04de762d740345cc469824b6f" name="a85d97eb04de762d740345cc469824b6f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>userData</b></td></tr>
<tr class="memdesc:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object. <br /></td></tr>
<tr class="separator:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:ad6a3f9870b95cebff97107058729852a inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="ad6a3f9870b95cebff97107058729852a" name="ad6a3f9870b95cebff97107058729852a"></a>
PxType&#160;</td><td class="memItemRight" valign="bottom"><b>mConcreteType</b></td></tr>
<tr class="separator:ad6a3f9870b95cebff97107058729852a inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24687e4fc96f1902f53cd4e0444c4482 inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a24687e4fc96f1902f53cd4e0444c4482" name="a24687e4fc96f1902f53cd4e0444c4482"></a>
<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mBaseFlags</b></td></tr>
<tr class="separator:a24687e4fc96f1902f53cd4e0444c4482 inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e247c6b6559031c784449e79396af0 inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a67e247c6b6559031c784449e79396af0" name="a67e247c6b6559031c784449e79396af0"></a>
PxU32&#160;</td><td class="memItemRight" valign="bottom"><b>mBuiltInRefCount</b></td></tr>
<tr class="separator:a67e247c6b6559031c784449e79396af0 inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a FEM softbody including everything to calculate its definition like geometry and material properties. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abbb8c9c3b1a546dcc8b5ed73d854da21" name="abbb8c9c3b1a546dcc8b5ed73d854da21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb8c9c3b1a546dcc8b5ed73d854da21">&#9670;&#160;</a></span>addClothAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::PxSoftBody::addClothAttachment </td>
          <td>(</td>
          <td class="paramtype">PxFEMCloth *&#160;</td>
          <td class="paramname"><em>cloth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>triIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>triBarycentric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>tetBarycentric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an attachment between a soft body and a cloth. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the cloth does not. </p>
<p>This method attaches a point inside a tetrahedron of the collision mesh to a cloth.</p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloth</td><td>The cloth actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triIdx</td><td>The index of a triangle in the cloth mesh that contains the point to be attached to the soft body </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triBarycentric</td><td>The barycentric coordinates of the attachment point inside the triangle specified by triangleIdx </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of a tetrahedron in the softbody's collision mesh that contains the point to be attached to the cloth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetBarycentric</td><td>The barycentric coordinates of the attachment point inside the tetrahedron specified by tetIdx </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The user defined cone distance limit constraint to limit the movement between a triangle in the fem cloth and a tet in the soft body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to release the attachment later </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a5fa10948aeb97d5cb89f16e10ef919ba">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="af1da16afabd826cc9db106f1749edbd4" name="af1da16afabd826cc9db106f1749edbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1da16afabd826cc9db106f1749edbd4">&#9670;&#160;</a></span>addClothFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::addClothFilter </td>
          <td>(</td>
          <td class="paramtype">PxFEMCloth *&#160;</td>
          <td class="paramname"><em>cloth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>triIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates collision filter between a tetrahedron in a soft body and a triangle in a cloth. </p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloth</td><td>The cloth actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triIdx</td><td>The index of the triangle in the cloth mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of the tetrahedron in the softbody's collision mesh to be filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a7ae67852881f9d50ea2b8c84938c1c5a">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="aaaeaf25e7ea0ff2976a0cb39e20cff26" name="aaaeaf25e7ea0ff2976a0cb39e20cff26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaeaf25e7ea0ff2976a0cb39e20cff26">&#9670;&#160;</a></span>addParticleAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::PxSoftBody::addParticleAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>particleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>barycentric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The <a class="el" href="classphysx_1_1_px_particle_buffer.html" title="The shared base class for all particle buffers, can be instantiated directly to simulate granular and...">PxParticleBuffer</a> to which the particle belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">particleId</td><td>The particle that is attached to a tetrahedron in the soft body's collision mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetId</td><td>The tetrahedron in the soft body's collision mesh to attach the particle to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barycentric</td><td>The barycentric coordinates of the particle attachment position with respect to the tetrahedron specified with tetId. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to release the attachment later </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a005fce4e8c69d42ed397b063136565c9">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a7fe61c672f855820507b4ca39eaf44c3" name="a7fe61c672f855820507b4ca39eaf44c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe61c672f855820507b4ca39eaf44c3">&#9670;&#160;</a></span>addParticleFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::addParticleFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>particleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a collision filter between a particle and a tetrahedron in the soft body's collision mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The <a class="el" href="classphysx_1_1_px_particle_buffer.html" title="The shared base class for all particle buffers, can be instantiated directly to simulate granular and...">PxParticleBuffer</a> to which the particle belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">particleId</td><td>The particle whose collisions with the tetrahedron in the soft body are filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetId</td><td>The tetradedron in the soft body that is filtered. If tetId is PX_MAX_TETID, this particle will filter against all tetrahedra in this soft body </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#ad2dc4681d8b7f45784e662dd65dbb83e">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ab0df35db3b120d40bc457fe46edf1923" name="ab0df35db3b120d40bc457fe46edf1923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0df35db3b120d40bc457fe46edf1923">&#9670;&#160;</a></span>addRigidAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::PxSoftBody::addRigidAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>vertId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>actorSpacePose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not. </p>
<p>This method attaches a vertex on the soft body collision mesh to the rigid body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertId</td><td>The index of a vertex in the softbody's collision mesh that gets attached to the rigid body. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">actorSpacePose</td><td>The location of the attachment point expressed in the rigid body's coordinate system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The user defined cone distance limit constraint to limit the movement between a vertex in the soft body and rigid body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to relese the attachment later </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#af297b69811c935ac3a900befbd21638e">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a34d283966ec1724c1833be787bdc51ee" name="a34d283966ec1724c1833be787bdc51ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d283966ec1724c1833be787bdc51ee">&#9670;&#160;</a></span>addRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::addRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>vertId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a collision filter between a vertex in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertId</td><td>The index of a vertex in the softbody's collision mesh whose collisions with the rigid body are filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a31d0c3c97e086b461900e79327bfc9c8">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a29c6454c000cdf9b96e9ae58a826041f" name="a29c6454c000cdf9b96e9ae58a826041f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c6454c000cdf9b96e9ae58a826041f">&#9670;&#160;</a></span>addSoftBodyAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::PxSoftBody::addSoftBodyAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>softbody0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>tetBarycentric0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>tetBarycentric1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an attachment between two soft bodies. </p>
<p>This method attaches a point inside a tetrahedron of the collision mesh to a point in another soft body's tetrahedron collision mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">softbody0</td><td>The soft body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx0</td><td>The index of a tetrahedron in the other soft body that contains the point to be attached to the soft body </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetBarycentric0</td><td>The barycentric coordinates of the attachment point inside the tetrahedron specified by tetIdx0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx1</td><td>The index of a tetrahedron in the softbody's collision mesh that contains the point to be attached to the softbody0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetBarycentric1</td><td>The barycentric coordinates of the attachment point inside the tetrahedron specified by tetIdx1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The user defined cone distance limit constraint to limit the movement between tets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to release the attachment later </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a200f3a2ddb701be64fcdb981f1a9e1a2">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ac51d32b513aea14f5f15c8e7982b5bf3" name="ac51d32b513aea14f5f15c8e7982b5bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51d32b513aea14f5f15c8e7982b5bf3">&#9670;&#160;</a></span>addSoftBodyFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::addSoftBodyFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>otherTetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates collision filter between a tetrahedron in a soft body and a tetrahedron in another soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIdx</td><td>The index of the tetrahedron in the other softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx1</td><td>The index of the tetrahedron in the softbody's collision mesh to be filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#aecc75faebd3eecc87040439f5d495309">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ae33c57f9d8f328b206398c3e8b551861" name="ae33c57f9d8f328b206398c3e8b551861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33c57f9d8f328b206398c3e8b551861">&#9670;&#160;</a></span>addSoftBodyFilters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::addSoftBodyFilters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 *&#160;</td>
          <td class="paramname"><em>otherTetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 *&#160;</td>
          <td class="paramname"><em>tetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIndicesSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates collision filters between a tetrahedron in a soft body with another soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIndices</td><td>The indices of the tetrahedron in the other softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndices</td><td>The indices of the tetrahedron of the softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndicesSize</td><td>The size of tetIndices. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a889850c0798dbd4145ad548745eee7e4">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="abe4efd157fd4bceabee9d278c34dcda7" name="abe4efd157fd4bceabee9d278c34dcda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4efd157fd4bceabee9d278c34dcda7">&#9670;&#160;</a></span>addTetRigidAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::PxSoftBody::addTetRigidAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>barycentric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>actorSpacePose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not. </p>
<p>This method attaches a point inside a tetrahedron of the collision to the rigid body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of a tetrahedron in the softbody's collision mesh that contains the point to be attached to the rigid body </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barycentric</td><td>The barycentric coordinates of the attachment point inside the tetrahedron specified by tetIdx </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">actorSpacePose</td><td>The location of the attachment point expressed in the rigid body's coordinate system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The user defined cone distance limit constraint to limit the movement between a tet and rigid body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to release the attachment later </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a5dda681f24e37f9126dee9206c12a243">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a1223e4814b8b781fe274d549492cde9f" name="a1223e4814b8b781fe274d549492cde9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1223e4814b8b781fe274d549492cde9f">&#9670;&#160;</a></span>addTetRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::addTetRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates collision filter between a tetrahedron in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of a tetrahedron in the softbody's collision mesh whose collisions with the rigid body is filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a3ae9d773c4ef3ac8c86a67809718cbf6">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="aa602720974de655d95049ac7dcee3c96" name="aa602720974de655d95049ac7dcee3c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa602720974de655d95049ac7dcee3c96">&#9670;&#160;</a></span>attachShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::PxSoftBody::attachShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a shape. </p>
<p>Attaches the shape to use for collision detection</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The shape to use for collisions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the operation was successful </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#acdeda0387029495cbc11a6610e9d258d">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a1358e4fc28d149ee1287edebd4240afe" name="a1358e4fc28d149ee1287edebd4240afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1358e4fc28d149ee1287edebd4240afe">&#9670;&#160;</a></span>attachSimulationMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::PxSoftBody::attachSimulationMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body_aux_data.html">PxSoftBodyAuxData</a> &amp;&#160;</td>
          <td class="paramname"><em>softBodyAuxData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a simulation mesh. </p>
<p>Attaches the simulation mesh (geometry) and a state containing inverse mass, rest pose etc. required to compute the softbody deformation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMesh</td><td>The tetrahedral mesh used to compute the softbody's deformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softBodyAuxData</td><td>A state that contain a mapping from simulation to collision mesh, volume information etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the operation was successful </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#adcc86fb7943d50aae402c1001cb01842">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a8e89cb3118981013838932b5328b2eb3" name="a8e89cb3118981013838932b5328b2eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e89cb3118981013838932b5328b2eb3">&#9670;&#160;</a></span>detachShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::detachShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches the shape. </p>
<p>Detaches the shape used for collision detection.</p>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="classphysx_1_1_px_soft_body.html#a45855574b47484673ddbc1b7b919e499" title="Detaches the simulation mesh.">detachSimulationMesh()</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a84b4237b5b7b860fba2bf3377f309f6f">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a45855574b47484673ddbc1b7b919e499" name="a45855574b47484673ddbc1b7b919e499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45855574b47484673ddbc1b7b919e499">&#9670;&#160;</a></span>detachSimulationMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::detachSimulationMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches the simulation mesh. </p>
<p>Detaches the simulation mesh and simulation state used to compute the softbody deformation.</p>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="classphysx_1_1_px_soft_body.html#a8e89cb3118981013838932b5328b2eb3" title="Detaches the shape.">detachShape()</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a1b0bda2ef6e089cf443503077ae3d93a">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a9c0473f9bb9b0e36c07c2754e001a22d" name="a9c0473f9bb9b0e36c07c2754e001a22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0473f9bb9b0e36c07c2754e001a22d">&#9670;&#160;</a></span>getCollisionMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> * physx::PxSoftBody::getCollisionMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the collision mesh pointer. </p>
<p>Allows to access the geometry of the tetrahedral mesh used to perform collision detection</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the collision mesh </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a0272d41af4b4adcee83cf12d4c4e2492">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a3ea6c35b687859239b5a889692ebac94" name="a3ea6c35b687859239b5a889692ebac94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea6c35b687859239b5a889692ebac94">&#9670;&#160;</a></span>getConcreteTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * physx::PxSoftBody::getConcreteTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string name of dynamic type. </p>
<dl class="section return"><dt>Returns</dt><dd>Class name of most derived type of this object. </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_base.html#aea4c4ef95da2697f36d3a9fc9a2f897a">physx::PxBase</a>.</p>

</div>
</div>
<a id="a8418698e3c39c87b07946a7f81cf2b23" name="a8418698e3c39c87b07946a7f81cf2b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8418698e3c39c87b07946a7f81cf2b23">&#9670;&#160;</a></span>getCudaContextManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxCudaContextManager * physx::PxSoftBody::getCudaContextManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cuda context manager. </p>
<dl class="section return"><dt>Returns</dt><dd>The cuda context manager </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a8144bfdbad7d4dce5d1c674d35fb0fc2">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a3867e1e682567681e73ee0f68828069c" name="a3867e1e682567681e73ee0f68828069c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3867e1e682567681e73ee0f68828069c">&#9670;&#160;</a></span>getGpuSoftBodyIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::PxSoftBody::getGpuSoftBodyIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the GPU soft body index. </p>
<dl class="section return"><dt>Returns</dt><dd>The GPU index, or 0xFFFFFFFF if the soft body is not in a scene. </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#aa845d3794994188a5dbf3b6a8ec6d2f3">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="aa7b2dba42ea1ab7e59a27b30d4a7203b" name="aa7b2dba42ea1ab7e59a27b30d4a7203b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b2dba42ea1ab7e59a27b30d4a7203b">&#9670;&#160;</a></span>getKinematicTargetCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> * physx::PxSoftBody::getKinematicTargetCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the vertices of the simulation mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass must match the inverse mass in the simVelocityCPU buffer at the same index. A copy of this value is stored in the simVelocityCPU buffer to allow for faster access on the GPU. If the inverse masses in those two buffers don't match, the simulation may produce wrong results</p>
<p>Allows to access the CPU buffer of the simulation mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the simulation mesh's vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a470ac75a2de4ce6d2d9508ac16389c8e">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ae482aec041036f6187163848d1b8aaf0" name="ae482aec041036f6187163848d1b8aaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae482aec041036f6187163848d1b8aaf0">&#9670;&#160;</a></span>getParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structphysx_1_1_px_f_e_m_parameters.html">PxFEMParameters</a> physx::PxSoftBody::getParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get parameter for FEM internal solve. </p>
<dl class="section return"><dt>Returns</dt><dd>The FEM parameters </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a25244c54cd78fc7f657623a9616b588a">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a4cea5ff304ad2d73c3e71147613e818f" name="a4cea5ff304ad2d73c3e71147613e818f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cea5ff304ad2d73c3e71147613e818f">&#9670;&#160;</a></span>getPositionInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> * physx::PxSoftBody::getPositionInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the vertices of the collision mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass on the collision mesh has no effect, it can be set to an arbitrary value.</p>
<p>Allows to access the CPU buffer of the collision mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the collision mesh's vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#af781f6fcb1a3195826035444421cd3c8">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="aed600012be729205b6a2ce757199a9e1" name="aed600012be729205b6a2ce757199a9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed600012be729205b6a2ce757199a9e1">&#9670;&#160;</a></span>getRestPositionInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> * physx::PxSoftBody::getRestPositionInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the rest vertices of the collision mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass on the collision mesh has no effect, it can be set to an arbitrary value.</p>
<p>Allows to access the CPU buffer of the collision mesh's rest vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the collision mesh's rest vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#ab85b9bd9c8d46799d5c1781dcb2c7666">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a85e7f27f4209373f2dcce01448faa906" name="a85e7f27f4209373f2dcce01448faa906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e7f27f4209373f2dcce01448faa906">&#9670;&#160;</a></span>getShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> * physx::PxSoftBody::getShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the shape pointer belonging to the actor. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the collision mesh's shape </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_shape.html" title="Abstract class for collision shapes.">PxShape</a> getNbShapes() <a class="el" href="classphysx_1_1_px_shape.html#af21c5392d4e2ead73034c1d838cfe48e" title="Decrements the reference count of a shape and releases it if the new reference count is zero.">PxShape::release()</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a7460e06efc162477757e1db9cfc898a2">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="af13967dbaef4161b72e48f685c39b077" name="af13967dbaef4161b72e48f685c39b077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13967dbaef4161b72e48f685c39b077">&#9670;&#160;</a></span>getSimPositionInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> * physx::PxSoftBody::getSimPositionInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the vertices of the simulation mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass must match the inverse mass in the simVelocityCPU buffer at the same index. A copy of this value is stored in the simVelocityCPU buffer to allow for faster access on the GPU. If the inverse masses in those two buffers don't match, the simulation may produce wrong results</p>
<p>Allows to access the CPU buffer of the simulation mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the simulation mesh's vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a16046224da390bf20d6ab5dcce6da341">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ad2f670bd0d2719c737aa52f562bd1a31" name="ad2f670bd0d2719c737aa52f562bd1a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f670bd0d2719c737aa52f562bd1a31">&#9670;&#160;</a></span>getSimulationMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> * physx::PxSoftBody::getSimulationMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the simulation mesh pointer. </p>
<p>Allows to access the geometry of the tetrahedral mesh used to compute the object's deformation</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the simulation mesh </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#abe546777169959ae0a817f5263b8e723">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ae9a56a2c3af0a2b35b10c054bef2baa7" name="ae9a56a2c3af0a2b35b10c054bef2baa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a56a2c3af0a2b35b10c054bef2baa7">&#9670;&#160;</a></span>getSimVelocityInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> * physx::PxSoftBody::getSimVelocityInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the velocities of the simulation mesh on the host. </p>
<p>Each element uses 4 float values containing velocity and inverseMass per vertex [x, y, z, inverseMass] The inverse mass must match the inverse mass in the simPositionInvMassCPU buffer at the same index. A copy of this value is stored in the simPositionInvMassCPU buffer to allow for faster access on the GPU. If the inverse masses in those two buffers don't match, the simulation may produce wrong results</p>
<p>Allows to access the CPU buffer of the simulation mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the simulation mesh's velocities (x, y, z) and the inverse mass as 4th component </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a2c507cfe064d0217afe06ee8fdbc094c">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a46e96324d4a20e9938900df58e2bd074" name="a46e96324d4a20e9938900df58e2bd074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e96324d4a20e9938900df58e2bd074">&#9670;&#160;</a></span>getSoftBodyAuxData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_soft_body_aux_data.html">PxSoftBodyAuxData</a> * physx::PxSoftBody::getSoftBodyAuxData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the simulation state pointer. </p>
<p>Allows to access the additional data of the simulation mesh (inverse mass, rest state etc.). The geometry part of the data is stored in the simulation mesh.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the simulation state </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a8802c7d01c763ee631d102f313f4cf59">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ad56e6ff5f75fcce761f81155322afc94" name="ad56e6ff5f75fcce761f81155322afc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56e6ff5f75fcce761f81155322afc94">&#9670;&#160;</a></span>getSoftBodyFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_flags.html">PxSoftBodyFlags</a> physx::PxSoftBody::getSoftBodyFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the softbody flags. </p>
<dl class="section return"><dt>Returns</dt><dd>The softbody flags </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a521c9a35bb5108d7bb73b7218eaf4479">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a801ea01a7236f962fad8fca8adf8321e" name="a801ea01a7236f962fad8fca8adf8321e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801ea01a7236f962fad8fca8adf8321e">&#9670;&#160;</a></span>getSolverIterationCounts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::getSolverIterationCounts </td>
          <td>(</td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>minVelocityIters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the solver iteration counts. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html#ab99548c514e09862494287eee688b0a1" title="Sets the solver iteration counts for the body.">setSolverIterationCounts()</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a2265532db39f1c302da481cff9de29f6">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a18445e28706f4fa7f493c707eca4ef22" name="a18445e28706f4fa7f493c707eca4ef22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18445e28706f4fa7f493c707eca4ef22">&#9670;&#160;</a></span>getWakeCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxSoftBody::getWakeCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the wake counter of the soft body. </p>
<dl class="section return"><dt>Returns</dt><dd>The wake counter of the soft body.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html#a131f8915719ffda345077d99118d946f" title="Returns true if this soft body is sleeping.">isSleeping()</a> <a class="el" href="classphysx_1_1_px_soft_body.html#a478d801eed43606ac4e06b48c883e137" title="Sets the wake counter for the soft body.">setWakeCounter()</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a798fae12993c6a8bc7e68d9656d30ab1">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a486959160c394478b2f37b8cb1dea091" name="a486959160c394478b2f37b8cb1dea091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486959160c394478b2f37b8cb1dea091">&#9670;&#160;</a></span>getWorldBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a> physx::PxSoftBody::getWorldBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inflation</em> = <code>1.01f</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the axis aligned bounding box enclosing the soft body. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to use this method while the simulation is running (except during <a class="el" href="classphysx_1_1_px_scene.html#a9c63e5a0e592a434b8647c98e569aed4" title="Performs collision detection for the scene over elapsedTime.">PxScene::collide()</a>, in <a class="el" href="classphysx_1_1_px_contact_modify_callback.html" title="An interface class that the user can implement in order to modify contact constraints.">PxContactModifyCallback</a> or in contact report callbacks).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inflation</td><td>Scale factor for computed world bounds. Box extents are multiplied by this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The soft body's bounding box.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_bounds3.html" title="Class representing 3D range or axis aligned bounding box.">PxBounds3</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_actor.html#ab4121e4d3f38d9303b840159ac18bc5d">physx::PxActor</a>.</p>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a843cec147943460ff245dbaf22b5eade">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ace2829fb17dad1d3e808e74db36006c5" name="ace2829fb17dad1d3e808e74db36006c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2829fb17dad1d3e808e74db36006c5">&#9670;&#160;</a></span>isKindOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::PxSoftBody::isKindOf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>superClass</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a given type name matches with the type of this instance. </p>

<p>Reimplemented from <a class="el" href="classphysx_1_1_px_actor.html#a538ec41302af60afec0df10f31f4ab24">physx::PxActor</a>.</p>

</div>
</div>
<a id="a131f8915719ffda345077d99118d946f" name="a131f8915719ffda345077d99118d946f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131f8915719ffda345077d99118d946f">&#9670;&#160;</a></span>isSleeping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::PxSoftBody::isSleeping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this soft body is sleeping. </p>
<p>When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or a sleep-affecting property is changed by the user, the entire sleep mechanism should be transparent to the user.</p>
<p>A soft body can only go to sleep if all vertices are ready for sleeping. A soft body is guaranteed to be awake if at least one of the following holds:</p>
<ul>
<li>The wake counter is positive (<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html#a478d801eed43606ac4e06b48c883e137" title="Sets the wake counter for the soft body.">setWakeCounter()</a>). </dd></dl>
</li>
<li>The velocity of any vertex is above the sleep threshold.</li>
</ul>
<p>If a soft body is sleeping, the following state is guaranteed:</p>
<ul>
<li>The wake counter is zero. </li>
<li>The linear velocity of all vertices is zero.</li>
</ul>
<p>When a soft body gets inserted into a scene, it will be considered asleep if all the points above hold, else it will be treated as awake.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if the soft body has not been added to a scene already.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the soft body is sleeping.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html#a131f8915719ffda345077d99118d946f" title="Returns true if this soft body is sleeping.">isSleeping()</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a50b8a1a0606542f15707b72b0ae215f0">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a7e154c7880a2f81bbb137bbef4b1a0fd" name="a7e154c7880a2f81bbb137bbef4b1a0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e154c7880a2f81bbb137bbef4b1a0fd">&#9670;&#160;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::readData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a read command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Read operations are scheduled and then flushed in <a class="el" href="classphysx_1_1_px_scene.html#ac9bf1631519e43a0375f821396e246e9" title="Advances the simulation by an elapsedTime time.">PxScene::simulate()</a>. Read operations are known to be finished when <a class="el" href="classphysx_1_1_px_buffer.html#a7f20d43d6afbf29e4ecf3ad01fc69e6a" title="Provides access to internal memory (either device or pinned host memory depending on PxBufferType).">PxBuffer::map()</a> returns.</p>
<p><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1bab6e0e9ada73a0be2a93fdfa5125ceae0" title="Flag to request access to the collision mesh&#39;s positions; read only.">PxSoftBodyData::ePOSITION_INVMASS</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba49e3ff122602577a46962206d9666780" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses.">PxSoftBodyData::eSIM_VELOCITY</a> can be read from the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.</p>
<p>The data to read from the GPU is written to the corresponding cpu buffer that a softbody provides. Those cpu buffers are accessible through <a class="el" href="classphysx_1_1_px_soft_body.html#a4cea5ff304ad2d73c3e71147613e818f" title="Access to the vertices of the collision mesh on the host.">getPositionInvMassCPU()</a>, <a class="el" href="classphysx_1_1_px_soft_body.html#af13967dbaef4161b72e48f685c39b077" title="Access to the vertices of the simulation mesh on the host.">getSimPositionInvMassCPU()</a> or <a class="el" href="classphysx_1_1_px_soft_body.html#ae9a56a2c3af0a2b35b10c054bef2baa7" title="Access to the velocities of the simulation mesh on the host.">getSimVelocityInvMassCPU()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html#a3c79d6afd0c16411d2e45a5f1cc56252" title="Issues a write command to the PxSoftBody.">writeData()</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html" title="Identifies input and output buffers for PxSoftBody.">PxSoftBodyData</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a179db5aa51cccbf4fea1a18bdc7cbf21">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a977c8932888461538bba4f33395c650c" name="a977c8932888461538bba4f33395c650c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977c8932888461538bba4f33395c650c">&#9670;&#160;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::readData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a read command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Read operations are scheduled and then flushed in <a class="el" href="classphysx_1_1_px_scene.html#ac9bf1631519e43a0375f821396e246e9" title="Advances the simulation by an elapsedTime time.">PxScene::simulate()</a>. Read operations are known to be finished when <a class="el" href="classphysx_1_1_px_buffer.html#a7f20d43d6afbf29e4ecf3ad01fc69e6a" title="Provides access to internal memory (either device or pinned host memory depending on PxBufferType).">PxBuffer::map()</a> returns.</p>
<p><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1bab6e0e9ada73a0be2a93fdfa5125ceae0" title="Flag to request access to the collision mesh&#39;s positions; read only.">PxSoftBodyData::ePOSITION_INVMASS</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba49e3ff122602577a46962206d9666780" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses.">PxSoftBodyData::eSIM_VELOCITY</a> can be read from the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.</p>
<p>The softbody class offers internal cpu buffers that can be used to hold the data. The cpu buffers are accessible through <a class="el" href="classphysx_1_1_px_soft_body.html#a4cea5ff304ad2d73c3e71147613e818f" title="Access to the vertices of the collision mesh on the host.">getPositionInvMassCPU()</a>, <a class="el" href="classphysx_1_1_px_soft_body.html#af13967dbaef4161b72e48f685c39b077" title="Access to the vertices of the simulation mesh on the host.">getSimPositionInvMassCPU()</a> and <a class="el" href="classphysx_1_1_px_soft_body.html#ae9a56a2c3af0a2b35b10c054bef2baa7" title="Access to the velocities of the simulation mesh on the host.">getSimVelocityInvMassCPU()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Specifies buffer to which data is written to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html#a3c79d6afd0c16411d2e45a5f1cc56252" title="Issues a write command to the PxSoftBody.">writeData()</a>, <a class="el" href="classphysx_1_1_px_buffer.html" title="Buffer for delayed bulk read and write operations supporting host and GPU device memory spaces.">PxBuffer</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html" title="Identifies input and output buffers for PxSoftBody.">PxSoftBodyData</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a71e544250ed356146de0589947a08a82">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="abd25cee2966691df649efab08c66648b" name="abd25cee2966691df649efab08c66648b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd25cee2966691df649efab08c66648b">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the softbody. </p>
<p>Releases the softbody and frees its resources. </p>

<p>Implements <a class="el" href="classphysx_1_1_px_actor.html#a782e6bd48fb10f393581302d428eee19">physx::PxActor</a>.</p>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a6fecbe185a5f96a553e3ecc5d3d22586">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="acb0e444fad640b513acc99f42f7a6f56" name="acb0e444fad640b513acc99f42f7a6f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0e444fad640b513acc99f42f7a6f56">&#9670;&#160;</a></span>removeClothAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::removeClothAttachment </td>
          <td>(</td>
          <td class="paramtype">PxFEMCloth *&#160;</td>
          <td class="paramname"><em>cloth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases an attachment between a cloth and a soft body. Be aware that destroying the cloth before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the cloth does not. </p>
<p>This method removes a previously-created attachment between a point inside a collision mesh tetrahedron and a point inside a cloth mesh.</p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloth</td><td>The cloth actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Index that identifies the attachment. This handle gets returned by the addClothAttachment when the attachment is created </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a65ccd5efbe37a02b33020bf526fbb879">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a253209fa24469ac27d7ddf9109203acd" name="a253209fa24469ac27d7ddf9109203acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253209fa24469ac27d7ddf9109203acd">&#9670;&#160;</a></span>removeClothFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::removeClothFilter </td>
          <td>(</td>
          <td class="paramtype">PxFEMCloth *&#160;</td>
          <td class="paramname"><em>cloth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>triIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes collision filter between a tetrahedron in a soft body and a triangle in a cloth. </p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloth</td><td>The cloth actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triIdx</td><td>The index of the triangle in the cloth mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of the tetrahedron in the softbody's collision mesh to be filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a25d0e44122f54cf956aa00e4eed4637c">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="aab99896beb748035721e2475893d3bfd" name="aab99896beb748035721e2475893d3bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab99896beb748035721e2475893d3bfd">&#9670;&#160;</a></span>removeParticleAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::removeParticleAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Index that identifies the attachment. This handle gets returned by the addParticleAttachment when the attachment is created </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a1d1a90aaef852b165a94d5d5a19601fc">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a6e58d78320439bfa33d1806dcc172ed5" name="a6e58d78320439bfa33d1806dcc172ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e58d78320439bfa33d1806dcc172ed5">&#9670;&#160;</a></span>removeParticleFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::removeParticleFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>particleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a collision filter between a particle and a tetrahedron in the soft body's collision mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The <a class="el" href="classphysx_1_1_px_particle_buffer.html" title="The shared base class for all particle buffers, can be instantiated directly to simulate granular and...">PxParticleBuffer</a> to which the particle belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">particleId</td><td>The particle whose collisions with the tetrahedron in the soft body are filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetId</td><td>The tetrahedron in the soft body is filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a3bd1fb08f0f7069e09f37be5607df3ac">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a3807a77c6ce9fc27b472a1f4093bcb7e" name="a3807a77c6ce9fc27b472a1f4093bcb7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3807a77c6ce9fc27b472a1f4093bcb7e">&#9670;&#160;</a></span>removeRigidAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::removeRigidAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not. </p>
<p>This method removes a previously-created attachment between a vertex of the soft body collision mesh and the rigid body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Index that identifies the attachment. This handle gets returned by the addRigidAttachment when the attachment is created </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a2af8ad423b1fb1a40f820563ee491d72">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ae8fa0a9aa318e559478c127e771cb86a" name="ae8fa0a9aa318e559478c127e771cb86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fa0a9aa318e559478c127e771cb86a">&#9670;&#160;</a></span>removeRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::removeRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>vertId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a collision filter between a vertex in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertId</td><td>The index of a vertex in the softbody's collision mesh whose collisions with the rigid body are filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a4e5d98f6e8b4e4e262eb3210f5e4e91d">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="aee6acf80193100b2713a0e58229611b5" name="aee6acf80193100b2713a0e58229611b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6acf80193100b2713a0e58229611b5">&#9670;&#160;</a></span>removeSoftBodyAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::removeSoftBodyAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>softbody0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases an attachment between a soft body and the other soft body. Be aware that destroying the soft body before destroying the attachment is illegal and may cause a crash. </p>
<p>This method removes a previously-created attachment between a point inside a tetrahedron of the collision mesh to a point in another soft body's tetrahedron collision mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">softbody0</td><td>The softbody actor used for the attachment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Index that identifies the attachment. This handle gets returned by the addSoftBodyAttachment when the attachment is created. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a5c47f0e7a98b43272211aa15c11778ef">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ab4c8c3660b669a7bb65226e816248886" name="ab4c8c3660b669a7bb65226e816248886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c8c3660b669a7bb65226e816248886">&#9670;&#160;</a></span>removeSoftBodyFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::removeSoftBodyFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>otherTetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes collision filter between a tetrahedron in a soft body and a tetrahedron in other soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIdx</td><td>The index of the other tetrahedron in the other softbody's collision mesh whose collision with the tetrahedron with the soft body is filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx1</td><td>The index of the tetrahedron in the softbody's collision mesh whose collision with the other tetrahedron with the other soft body is filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#ad584e5d0a8e6e2a3c6e26ff97123948f">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ae814d96255b19f85fdb33043bb862fba" name="ae814d96255b19f85fdb33043bb862fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae814d96255b19f85fdb33043bb862fba">&#9670;&#160;</a></span>removeSoftBodyFilters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::removeSoftBodyFilters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 *&#160;</td>
          <td class="paramname"><em>otherTetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 *&#160;</td>
          <td class="paramname"><em>tetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIndicesSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes collision filters between a tetrahedron in a soft body with another soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIndices</td><td>The indices of the tetrahedron in the other softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndices</td><td>The indices of the tetrahedron of the softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndicesSize</td><td>The size of tetIndices. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#ac4de9c04860fb81f471f500a96e90e6f">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ac2cc13579616f7f83ff7d9eb046dfc44" name="ac2cc13579616f7f83ff7d9eb046dfc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cc13579616f7f83ff7d9eb046dfc44">&#9670;&#160;</a></span>removeTetRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::removeTetRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes collision filter between a tetrahedron in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of a tetrahedron in the softbody's collision mesh whose collisions with the rigid body is filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#af73645316600c85639db4a150eb91adf">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="aac90eaf62454ee3a35d824a5ac3668e4" name="aac90eaf62454ee3a35d824a5ac3668e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac90eaf62454ee3a35d824a5ac3668e4">&#9670;&#160;</a></span>setParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::setParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_f_e_m_parameters.html">PxFEMParameters</a>&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set parameter for FEM internal solve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>The FEM parameters </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a4750f90937bcf4c2d3d38da3405adaf5">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a43ba0e4e924c32131b00ba0d15ac5599" name="a43ba0e4e924c32131b00ba0d15ac5599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ba0e4e924c32131b00ba0d15ac5599">&#9670;&#160;</a></span>setSoftBodyFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::setSoftBodyFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_soft_body_flag.html#ad392f0ca084f5a0ec7f110b8c2476315">PxSoftBodyFlag::Enum</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a single softbody flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>The flag to set or clear </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new state of the flag </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#ab35f8ee26d9a063e75ee27da85ab9075">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="add9ef79efcb2011b47bf133769535c64" name="add9ef79efcb2011b47bf133769535c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9ef79efcb2011b47bf133769535c64">&#9670;&#160;</a></span>setSoftBodyFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::setSoftBodyFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_flags.html">PxSoftBodyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the softbody flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>The new softbody flags </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a892116fcb446822ea526c0468d9afeed">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ab99548c514e09862494287eee688b0a1" name="ab99548c514e09862494287eee688b0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99548c514e09862494287eee688b0a1">&#9670;&#160;</a></span>setSolverIterationCounts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::setSolverIterationCounts </td>
          <td>(</td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>minVelocityIters</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the solver iteration counts for the body. </p>
<p>The solver iteration count determines how accurately deformation and contacts are resolved. If you are having trouble with softbodies that are not as stiff as they should be, then setting a higher position iteration count may improve the behavior.</p>
<p>If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations.</p>
<p><b>Default:</b> 4 position iterations, 1 velocity iteration</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minPositionIters</td><td>Minimal number of position iterations the solver should perform for this body. <b>Range:</b> [1,255] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minVelocityIters</td><td>Minimal number of velocity iterations the solver should perform for this body. <b>Range:</b> [1,255]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html#a801ea01a7236f962fad8fca8adf8321e" title="Retrieves the solver iteration counts.">getSolverIterationCounts()</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#af4ec3a30186b37bf9498d0dd599c6257">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a478d801eed43606ac4e06b48c883e137" name="a478d801eed43606ac4e06b48c883e137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478d801eed43606ac4e06b48c883e137">&#9670;&#160;</a></span>setWakeCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::setWakeCounter </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>wakeCounterValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the wake counter for the soft body. </p>
<p>The wake counter value determines the minimum amount of time until the soft body can be put to sleep. Please note that a soft body will not be put to sleep if any vertex velocity is above the specified threshold or if other awake objects are touching it.</p>
<dl class="section note"><dt>Note</dt><dd>Passing in a positive value will wake the soft body up automatically.</dd></dl>
<p><b>Default:</b> 0.4 (which corresponds to 20 frames for a time step of 0.02)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeCounterValue</td><td>Wake counter value. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html#a131f8915719ffda345077d99118d946f" title="Returns true if this soft body is sleeping.">isSleeping()</a> <a class="el" href="classphysx_1_1_px_soft_body.html#a18445e28706f4fa7f493c707eca4ef22" title="Returns the wake counter of the soft body.">getWakeCounter()</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a8b9ae97f130dec4ed562db346b0beac5">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="ad7fccbe8185a375cf42f9362d59f9748" name="ad7fccbe8185a375cf42f9362d59f9748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fccbe8185a375cf42f9362d59f9748">&#9670;&#160;</a></span>writeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a write command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Write operations are scheduled and then flushed in <a class="el" href="classphysx_1_1_px_scene.html#ac9bf1631519e43a0375f821396e246e9" title="Advances the simulation by an elapsedTime time.">PxScene::simulate()</a>. Write operations are known to be finished when PxScene::fetchResult() returns.</p>
<p><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba49e3ff122602577a46962206d9666780" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses.">PxSoftBodyData::eSIM_VELOCITY</a> can be written to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1bab6e0e9ada73a0be2a93fdfa5125ceae0" title="Flag to request access to the collision mesh&#39;s positions; read only.">PxSoftBodyData::ePOSITION_INVMASS</a> is read only, because the collision-mesh vertices are driven by the simulation-mesh vertices, which can be written to with <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a>.</p>
<p>The data to write to the GPU is taken from the corresponding cpu buffer that a softbody provides. Those cpu buffers are accessible through <a class="el" href="classphysx_1_1_px_soft_body.html#a4cea5ff304ad2d73c3e71147613e818f" title="Access to the vertices of the collision mesh on the host.">getPositionInvMassCPU()</a>, <a class="el" href="classphysx_1_1_px_soft_body.html#af13967dbaef4161b72e48f685c39b077" title="Access to the vertices of the simulation mesh on the host.">getSimPositionInvMassCPU()</a> or <a class="el" href="classphysx_1_1_px_soft_body.html#ae9a56a2c3af0a2b35b10c054bef2baa7" title="Access to the velocities of the simulation mesh on the host.">getSimVelocityInvMassCPU()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html#a977c8932888461538bba4f33395c650c" title="Issues a read command to the PxSoftBody.">readData()</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html" title="Identifies input and output buffers for PxSoftBody.">PxSoftBodyData</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#a9aca1e67e9fdd3c0890a065ddd6974dc">physx::NpSoftBody</a>.</p>

</div>
</div>
<a id="a3c79d6afd0c16411d2e45a5f1cc56252" name="a3c79d6afd0c16411d2e45a5f1cc56252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c79d6afd0c16411d2e45a5f1cc56252">&#9670;&#160;</a></span>writeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxSoftBody::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a write command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Write operations are scheduled and then flushed in <a class="el" href="classphysx_1_1_px_scene.html#ac9bf1631519e43a0375f821396e246e9" title="Advances the simulation by an elapsedTime time.">PxScene::simulate()</a>. Write operations are known to be finished when PxScene::fetchResult() returns.</p>
<p><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba49e3ff122602577a46962206d9666780" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses.">PxSoftBodyData::eSIM_VELOCITY</a> can be written to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1bab6e0e9ada73a0be2a93fdfa5125ceae0" title="Flag to request access to the collision mesh&#39;s positions; read only.">PxSoftBodyData::ePOSITION_INVMASS</a> is read only, because the collision-mesh vertices are driven by the simulation-mesh vertices, which can be written to with <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a>.</p>
<p>The softbody class offers internal cpu buffers that can be used to hold the data. The cpu buffers are accessible through <a class="el" href="classphysx_1_1_px_soft_body.html#a4cea5ff304ad2d73c3e71147613e818f" title="Access to the vertices of the collision mesh on the host.">getPositionInvMassCPU()</a>, <a class="el" href="classphysx_1_1_px_soft_body.html#af13967dbaef4161b72e48f685c39b077" title="Access to the vertices of the simulation mesh on the host.">getSimPositionInvMassCPU()</a> and <a class="el" href="classphysx_1_1_px_soft_body.html#ae9a56a2c3af0a2b35b10c054bef2baa7" title="Access to the velocities of the simulation mesh on the host.">getSimVelocityInvMassCPU()</a>. Consider to use the <a class="el" href="classphysx_1_1_px_soft_body_ext.html#a7d38f3baba9f41a471c85725dcef03b4" title="Uploads prepared SoftBody data to the GPU. It ensures that the embedded collision mesh matches the si...">PxSoftBodyExt::commit()</a> extension method if all buffers should get written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Specifies buffer from which data is read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_soft_body.html#a977c8932888461538bba4f33395c650c" title="Issues a read command to the PxSoftBody.">readData()</a>, <a class="el" href="classphysx_1_1_px_buffer.html" title="Buffer for delayed bulk read and write operations supporting host and GPU device memory spaces.">PxBuffer</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html" title="Identifies input and output buffers for PxSoftBody.">PxSoftBodyData</a>, <a class="el" href="classphysx_1_1_px_soft_body_ext.html#a7d38f3baba9f41a471c85725dcef03b4" title="Uploads prepared SoftBody data to the GPU. It ensures that the embedded collision mesh matches the si...">PxSoftBodyExt::commit</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_np_soft_body.html#ae1f73ff72ecda078a7b7d4c0dbddd7b1">physx::NpSoftBody</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="_px_soft_body_8h_source.html">PxSoftBody.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacephysx.html">physx</a></li><li class="navelem"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
