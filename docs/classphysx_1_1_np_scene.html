<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PhysX: physx::NpScene Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PhysX<span id="projectnumber">&#160;5.1.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classphysx_1_1_np_scene.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classphysx_1_1_np_scene-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">physx::NpScene Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for physx::NpScene:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classphysx_1_1_np_scene.png" usemap="#physx::NpScene_map" alt=""/>
  <map id="physx::NpScene_map" name="physx::NpScene_map">
<area href="classphysx_1_1_np_scene_accessor.html" alt="physx::NpSceneAccessor" shape="rect" coords="0,168,205,192"/>
<area href="classphysx_1_1_px_user_allocated.html" alt="physx::PxUserAllocated" shape="rect" coords="215,168,420,192"/>
<area href="classphysx_1_1_px_scene.html" title="A scene is a collection of bodies and constraints which can interact." alt="physx::PxScene" shape="rect" coords="0,112,205,136"/>
<area href="classphysx_1_1_px_scene_s_q_system.html" title="Traditional SQ system for PxScene." alt="physx::PxSceneSQSystem" shape="rect" coords="0,56,205,80"/>
<area href="classphysx_1_1_px_scene_query_system_base.html" title="Base class for the scene-query system." alt="physx::PxSceneQuerySystemBase" shape="rect" coords="0,0,205,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene_1_1_material_event.html">MaterialEvent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structphysx_1_1_np_scene_1_1_start_write_result.html">StartWriteResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0d5db06a011b89be6c51ef4844152e57"><td class="memItemLeft" align="right" valign="top"><a id="a0d5db06a011b89be6c51ef4844152e57" name="a0d5db06a011b89be6c51ef4844152e57"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>MATERIAL_EVENT</b> { <b>MATERIAL_ADD</b>
, <b>MATERIAL_UPDATE</b>
, <b>MATERIAL_REMOVE</b>
 }</td></tr>
<tr class="separator:a0d5db06a011b89be6c51ef4844152e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abdf9aafe76d85dc5608e569376df2eb6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#abdf9aafe76d85dc5608e569376df2eb6">release</a> ()</td></tr>
<tr class="memdesc:abdf9aafe76d85dc5608e569376df2eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the scene.  <br /></td></tr>
<tr class="separator:abdf9aafe76d85dc5608e569376df2eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fc524e3c214722465430e0ad554c6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a53fc524e3c214722465430e0ad554c6f">setFlag</a> (<a class="el" href="structphysx_1_1_px_scene_flag.html#a1a7984bb50590b1a2ce5ca5fe6469e50">PxSceneFlag::Enum</a> flag, bool value)</td></tr>
<tr class="memdesc:a53fc524e3c214722465430e0ad554c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a scene flag. You can only set one flag at a time.  <br /></td></tr>
<tr class="separator:a53fc524e3c214722465430e0ad554c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032146965d449d65ea35e93d039a27b7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a1ba7b23b18ff732b37a74fdd1496be2c">PxSceneFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a032146965d449d65ea35e93d039a27b7">getFlags</a> () const</td></tr>
<tr class="memdesc:a032146965d449d65ea35e93d039a27b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scene flags.  <br /></td></tr>
<tr class="separator:a032146965d449d65ea35e93d039a27b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdc7e9623f1822ad460e4dc3bac2f41"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a0cdc7e9623f1822ad460e4dc3bac2f41">setGravity</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;)</td></tr>
<tr class="memdesc:a0cdc7e9623f1822ad460e4dc3bac2f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a constant gravity for the entire scene.  <br /></td></tr>
<tr class="separator:a0cdc7e9623f1822ad460e4dc3bac2f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5198b7257a8cffa856dcbe979f49f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#afc5198b7257a8cffa856dcbe979f49f2">getGravity</a> () const</td></tr>
<tr class="memdesc:afc5198b7257a8cffa856dcbe979f49f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current gravity setting.  <br /></td></tr>
<tr class="separator:afc5198b7257a8cffa856dcbe979f49f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3655560e5dac5ba7c3977d67ddb3df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ace3655560e5dac5ba7c3977d67ddb3df">setBounceThresholdVelocity</a> (const PxReal t)</td></tr>
<tr class="memdesc:ace3655560e5dac5ba7c3977d67ddb3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounce threshold velocity. Collision speeds below this threshold will not cause a bounce.  <br /></td></tr>
<tr class="separator:ace3655560e5dac5ba7c3977d67ddb3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cddad2ad26773e073d27b61e7749ebd"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a6cddad2ad26773e073d27b61e7749ebd">getBounceThresholdVelocity</a> () const</td></tr>
<tr class="memdesc:a6cddad2ad26773e073d27b61e7749ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounce threshold velocity.  <br /></td></tr>
<tr class="separator:a6cddad2ad26773e073d27b61e7749ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213d2ef7f2baf9613b1de1fdd2d6ba05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a213d2ef7f2baf9613b1de1fdd2d6ba05">setMaxBiasCoefficient</a> (const PxReal t)</td></tr>
<tr class="memdesc:a213d2ef7f2baf9613b1de1fdd2d6ba05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the max bias coefficient.  <br /></td></tr>
<tr class="separator:a213d2ef7f2baf9613b1de1fdd2d6ba05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a74b8b08c99a62ea9c987e38ddba35"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a79a74b8b08c99a62ea9c987e38ddba35">getMaxBiasCoefficient</a> () const</td></tr>
<tr class="memdesc:a79a74b8b08c99a62ea9c987e38ddba35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the max bias coefficient.  <br /></td></tr>
<tr class="separator:a79a74b8b08c99a62ea9c987e38ddba35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb738f041a90dc9a22fe6494476860f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a7cb738f041a90dc9a22fe6494476860f">setFrictionOffsetThreshold</a> (const PxReal t)</td></tr>
<tr class="memdesc:a7cb738f041a90dc9a22fe6494476860f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the friction offset threshold.  <br /></td></tr>
<tr class="separator:a7cb738f041a90dc9a22fe6494476860f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0770948af43be11d82add237afc0ad4"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ac0770948af43be11d82add237afc0ad4">getFrictionOffsetThreshold</a> () const</td></tr>
<tr class="memdesc:ac0770948af43be11d82add237afc0ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the friction offset threshold.  <br /></td></tr>
<tr class="separator:ac0770948af43be11d82add237afc0ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911d803e082ba5c34b4f30bc3d6c4bb9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a911d803e082ba5c34b4f30bc3d6c4bb9">setFrictionCorrelationDistance</a> (const PxReal t)</td></tr>
<tr class="memdesc:a911d803e082ba5c34b4f30bc3d6c4bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the friction correlation distance.  <br /></td></tr>
<tr class="separator:a911d803e082ba5c34b4f30bc3d6c4bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250c2fd08143f1e91691a65b41526394"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a250c2fd08143f1e91691a65b41526394">getFrictionCorrelationDistance</a> () const</td></tr>
<tr class="memdesc:a250c2fd08143f1e91691a65b41526394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the friction correlation distance.  <br /></td></tr>
<tr class="separator:a250c2fd08143f1e91691a65b41526394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26353210471576d8e7e6bd1c18de6575"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a26353210471576d8e7e6bd1c18de6575">setLimits</a> (const <a class="el" href="classphysx_1_1_px_scene_limits.html">PxSceneLimits</a> &amp;limits)</td></tr>
<tr class="memdesc:a26353210471576d8e7e6bd1c18de6575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set new scene limits.  <br /></td></tr>
<tr class="separator:a26353210471576d8e7e6bd1c18de6575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb77c09bb27fd93eee045ce1591b681"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_scene_limits.html">PxSceneLimits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aacb77c09bb27fd93eee045ce1591b681">getLimits</a> () const</td></tr>
<tr class="memdesc:aacb77c09bb27fd93eee045ce1591b681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current scene limits.  <br /></td></tr>
<tr class="separator:aacb77c09bb27fd93eee045ce1591b681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4d92e311fd404ebaba740244e55a8e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a5b4d92e311fd404ebaba740244e55a8e">addActor</a> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;actor, const <a class="el" href="classphysx_1_1_px_b_v_h.html">PxBVH</a> *bvh)</td></tr>
<tr class="memdesc:a5b4d92e311fd404ebaba740244e55a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an actor to this scene.  <br /></td></tr>
<tr class="separator:a5b4d92e311fd404ebaba740244e55a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df7359e59642397e0b20d900688226c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a6df7359e59642397e0b20d900688226c">removeActor</a> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;actor, bool wakeOnLostTouch)</td></tr>
<tr class="memdesc:a6df7359e59642397e0b20d900688226c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an actor from this scene.  <br /></td></tr>
<tr class="separator:a6df7359e59642397e0b20d900688226c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6873324086c08b7c73af1828052aba7"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#af6873324086c08b7c73af1828052aba7">getNbConstraints</a> () const</td></tr>
<tr class="memdesc:af6873324086c08b7c73af1828052aba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraint shaders in the scene.  <br /></td></tr>
<tr class="separator:af6873324086c08b7c73af1828052aba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e4dfe27afea8452cc39e10dd09f172"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ac1e4dfe27afea8452cc39e10dd09f172">getConstraints</a> (<a class="el" href="classphysx_1_1_px_constraint.html">PxConstraint</a> **buffer, PxU32 bufferSize, PxU32 startIndex=0) const</td></tr>
<tr class="memdesc:ac1e4dfe27afea8452cc39e10dd09f172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the constraint shaders in the scene.  <br /></td></tr>
<tr class="separator:ac1e4dfe27afea8452cc39e10dd09f172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f737006011f8f2b1dba7ff55b98c6cc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a9f737006011f8f2b1dba7ff55b98c6cc">addArticulation</a> (<a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> &amp;)</td></tr>
<tr class="memdesc:a9f737006011f8f2b1dba7ff55b98c6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an articulation to this scene.  <br /></td></tr>
<tr class="separator:a9f737006011f8f2b1dba7ff55b98c6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5afb6860bbbac51c7e2f2f78c09d54"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#afa5afb6860bbbac51c7e2f2f78c09d54">removeArticulation</a> (<a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> &amp;, bool wakeOnLostTouch)</td></tr>
<tr class="memdesc:afa5afb6860bbbac51c7e2f2f78c09d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an articulation from this scene.  <br /></td></tr>
<tr class="separator:afa5afb6860bbbac51c7e2f2f78c09d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5aeb14d2f5e6560f3a2935abed82ef3"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aa5aeb14d2f5e6560f3a2935abed82ef3">getNbArticulations</a> () const</td></tr>
<tr class="memdesc:aa5aeb14d2f5e6560f3a2935abed82ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of articulations in the scene.  <br /></td></tr>
<tr class="separator:aa5aeb14d2f5e6560f3a2935abed82ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648d102cfc6de073ef23243e225ce414"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a648d102cfc6de073ef23243e225ce414">getArticulations</a> (<a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const</td></tr>
<tr class="memdesc:a648d102cfc6de073ef23243e225ce414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the articulations in the scene.  <br /></td></tr>
<tr class="separator:a648d102cfc6de073ef23243e225ce414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b018b464729621c7aa0d121cef2d30"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ae1b018b464729621c7aa0d121cef2d30">getNbSoftBodies</a> () const</td></tr>
<tr class="memdesc:ae1b018b464729621c7aa0d121cef2d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of soft bodies in the scene.  <br /></td></tr>
<tr class="separator:ae1b018b464729621c7aa0d121cef2d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eefd0b7be71bade4ffc0d15ad146a35"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a1eefd0b7be71bade4ffc0d15ad146a35">getSoftBodies</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const</td></tr>
<tr class="memdesc:a1eefd0b7be71bade4ffc0d15ad146a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an array of all the soft bodies in the scene.  <br /></td></tr>
<tr class="separator:a1eefd0b7be71bade4ffc0d15ad146a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489b4634511bce61ca64821337bd92d2"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a489b4634511bce61ca64821337bd92d2">getNbParticleSystems</a> (<a class="el" href="structphysx_1_1_px_particle_solver_type.html#aab44d7e28b088d01cda18e0b7217ad2f">PxParticleSolverType::Enum</a> type) const</td></tr>
<tr class="memdesc:a489b4634511bce61ca64821337bd92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of particle systems of the requested type in the scene.  <br /></td></tr>
<tr class="separator:a489b4634511bce61ca64821337bd92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad143484c5d213a12bb2e69d3cafdf0c4"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ad143484c5d213a12bb2e69d3cafdf0c4">getParticleSystems</a> (<a class="el" href="structphysx_1_1_px_particle_solver_type.html#aab44d7e28b088d01cda18e0b7217ad2f">PxParticleSolverType::Enum</a> type, <a class="el" href="classphysx_1_1_px_particle_system.html">PxParticleSystem</a> **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const</td></tr>
<tr class="memdesc:ad143484c5d213a12bb2e69d3cafdf0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an array of all the particle systems of the requested type in the scene.  <br /></td></tr>
<tr class="separator:ad143484c5d213a12bb2e69d3cafdf0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d3234732ad157a17eb7c64a4c8f9b4"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a89d3234732ad157a17eb7c64a4c8f9b4">getNbFEMCloths</a> () const</td></tr>
<tr class="memdesc:a89d3234732ad157a17eb7c64a4c8f9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of FEM cloths in the scene.  <br /></td></tr>
<tr class="separator:a89d3234732ad157a17eb7c64a4c8f9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf585f9ffa7e3981b81d95b3f9434b07"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#acf585f9ffa7e3981b81d95b3f9434b07">getFEMCloths</a> (PxFEMCloth **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const</td></tr>
<tr class="memdesc:acf585f9ffa7e3981b81d95b3f9434b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an array of all the FEM cloths in the scene.  <br /></td></tr>
<tr class="separator:acf585f9ffa7e3981b81d95b3f9434b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a31837ae36e5f7b3b2cf8a391950c5"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a93a31837ae36e5f7b3b2cf8a391950c5">getNbHairSystems</a> () const</td></tr>
<tr class="memdesc:a93a31837ae36e5f7b3b2cf8a391950c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of hair systems in the scene.  <br /></td></tr>
<tr class="separator:a93a31837ae36e5f7b3b2cf8a391950c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50505c3cc2c76aed10097df9a00d0898"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a50505c3cc2c76aed10097df9a00d0898">getHairSystems</a> (PxHairSystem **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const</td></tr>
<tr class="memdesc:a50505c3cc2c76aed10097df9a00d0898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an array of all the hair systems in the scene.  <br /></td></tr>
<tr class="separator:a50505c3cc2c76aed10097df9a00d0898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2bf7a910274994ba1e7a789269808f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#abb2bf7a910274994ba1e7a789269808f">addAggregate</a> (<a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> &amp;)</td></tr>
<tr class="memdesc:abb2bf7a910274994ba1e7a789269808f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an aggregate to this scene.  <br /></td></tr>
<tr class="separator:abb2bf7a910274994ba1e7a789269808f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42641d6f1b646a03bf5f716296696fd2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a42641d6f1b646a03bf5f716296696fd2">removeAggregate</a> (<a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> &amp;, bool wakeOnLostTouch)</td></tr>
<tr class="memdesc:a42641d6f1b646a03bf5f716296696fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an aggregate from this scene.  <br /></td></tr>
<tr class="separator:a42641d6f1b646a03bf5f716296696fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fb85e7ae86fa4945d15ce1059a2b43"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a91fb85e7ae86fa4945d15ce1059a2b43">getNbAggregates</a> () const</td></tr>
<tr class="memdesc:a91fb85e7ae86fa4945d15ce1059a2b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of aggregates in the scene.  <br /></td></tr>
<tr class="separator:a91fb85e7ae86fa4945d15ce1059a2b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a843d6652a7cd7e956775f926a6e2cb"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a4a843d6652a7cd7e956775f926a6e2cb">getAggregates</a> (<a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const</td></tr>
<tr class="memdesc:a4a843d6652a7cd7e956775f926a6e2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the aggregates in the scene.  <br /></td></tr>
<tr class="separator:a4a843d6652a7cd7e956775f926a6e2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc9783086db1f704b0a5778ca4e4300"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aefc9783086db1f704b0a5778ca4e4300">addCollection</a> (const <a class="el" href="classphysx_1_1_px_collection.html">PxCollection</a> &amp;collection)</td></tr>
<tr class="memdesc:aefc9783086db1f704b0a5778ca4e4300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds objects in the collection to this scene.  <br /></td></tr>
<tr class="separator:aefc9783086db1f704b0a5778ca4e4300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ff3fbd073192ed9998b632bf503715"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ab5ff3fbd073192ed9998b632bf503715">setDominanceGroupPair</a> (<a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a> group1, <a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a> group2, const <a class="el" href="structphysx_1_1_px_dominance_group_pair.html">PxDominanceGroupPair</a> &amp;dominance)</td></tr>
<tr class="memdesc:ab5ff3fbd073192ed9998b632bf503715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the dominance behavior of contacts between two actors with two certain dominance groups.  <br /></td></tr>
<tr class="separator:ab5ff3fbd073192ed9998b632bf503715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716d215dfdc868843a1b38ed24c944dd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_dominance_group_pair.html">PxDominanceGroupPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a716d215dfdc868843a1b38ed24c944dd">getDominanceGroupPair</a> (<a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a> group1, <a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a> group2) const</td></tr>
<tr class="memdesc:a716d215dfdc868843a1b38ed24c944dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples the dominance matrix.  <br /></td></tr>
<tr class="separator:a716d215dfdc868843a1b38ed24c944dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77b3c021b3c6f7125fee3b351555206"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ad77b3c021b3c6f7125fee3b351555206">getNbActors</a> (<a class="el" href="namespacephysx.html#abb179bd82b9dca8e4c30ae19447fa5a7">PxActorTypeFlags</a> types) const</td></tr>
<tr class="memdesc:ad77b3c021b3c6f7125fee3b351555206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of actors of certain types in the scene. For supported types, see PxActorTypeFlags.  <br /></td></tr>
<tr class="separator:ad77b3c021b3c6f7125fee3b351555206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d78ebac2b9075c068456acec30bdbf"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#af3d78ebac2b9075c068456acec30bdbf">getActors</a> (<a class="el" href="namespacephysx.html#abb179bd82b9dca8e4c30ae19447fa5a7">PxActorTypeFlags</a> types, <a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> **buffer, PxU32 bufferSize, PxU32 startIndex=0) const</td></tr>
<tr class="memdesc:af3d78ebac2b9075c068456acec30bdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an array of all the actors of certain types in the scene. For supported types, see PxActorTypeFlags.  <br /></td></tr>
<tr class="separator:af3d78ebac2b9075c068456acec30bdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b7b941085e406907bb85e993fcaa11"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a93b7b941085e406907bb85e993fcaa11">getActiveActors</a> (PxU32 &amp;nbActorsOut)</td></tr>
<tr class="memdesc:a93b7b941085e406907bb85e993fcaa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the <a class="el" href="classphysx_1_1_px_scene.html" title="A scene is a collection of bodies and constraints which can interact.">PxScene</a> for a list of the PxActors whose transforms have been updated during the previous simulation step. Only includes actors of type <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> and <a class="el" href="classphysx_1_1_px_articulation_link.html" title="A component of an articulation that represents a rigid body.">PxArticulationLink</a>.  <br /></td></tr>
<tr class="separator:a93b7b941085e406907bb85e993fcaa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb0bedc73408e5f28656bbbe0f81374"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aecb0bedc73408e5f28656bbbe0f81374">getSimulationStatistics</a> (<a class="el" href="classphysx_1_1_px_simulation_statistics.html">PxSimulationStatistics</a> &amp;s) const</td></tr>
<tr class="memdesc:aecb0bedc73408e5f28656bbbe0f81374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method to retrieve statistics for the current simulation step.  <br /></td></tr>
<tr class="separator:aecb0bedc73408e5f28656bbbe0f81374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83681b49b69acfb10decdc486b3a4a95"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a83681b49b69acfb10decdc486b3a4a95">createClient</a> ()</td></tr>
<tr class="memdesc:a83681b49b69acfb10decdc486b3a4a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves a new client ID.  <br /></td></tr>
<tr class="separator:a83681b49b69acfb10decdc486b3a4a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423b5f90c744e70bf374e247aa662b26"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_friction_type.html#aa2bd47515042cacbc4e34cb163331a86">PxFrictionType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a423b5f90c744e70bf374e247aa662b26">getFrictionType</a> () const</td></tr>
<tr class="memdesc:a423b5f90c744e70bf374e247aa662b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the friction model.  <br /></td></tr>
<tr class="separator:a423b5f90c744e70bf374e247aa662b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0505359e51a314a0358712c524e8df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#acf0505359e51a314a0358712c524e8df">setSimulationEventCallback</a> (<a class="el" href="classphysx_1_1_px_simulation_event_callback.html">PxSimulationEventCallback</a> *callback)</td></tr>
<tr class="memdesc:acf0505359e51a314a0358712c524e8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user notify object which receives special simulation events when they occur.  <br /></td></tr>
<tr class="separator:acf0505359e51a314a0358712c524e8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b0d45fa77042425ea1c46216eee23f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_simulation_event_callback.html">PxSimulationEventCallback</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a60b0d45fa77042425ea1c46216eee23f">getSimulationEventCallback</a> () const</td></tr>
<tr class="memdesc:a60b0d45fa77042425ea1c46216eee23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the simulationEventCallback pointer set with <a class="el" href="classphysx_1_1_np_scene.html#acf0505359e51a314a0358712c524e8df" title="Sets a user notify object which receives special simulation events when they occur.">setSimulationEventCallback()</a>.  <br /></td></tr>
<tr class="separator:a60b0d45fa77042425ea1c46216eee23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a394872deaa7dbd44d6240bd8e8dafc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a6a394872deaa7dbd44d6240bd8e8dafc">setContactModifyCallback</a> (<a class="el" href="classphysx_1_1_px_contact_modify_callback.html">PxContactModifyCallback</a> *callback)</td></tr>
<tr class="memdesc:a6a394872deaa7dbd44d6240bd8e8dafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user callback object, which receives callbacks on all contacts generated for specified actors.  <br /></td></tr>
<tr class="separator:a6a394872deaa7dbd44d6240bd8e8dafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179b420149b554519450a31462001072"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_contact_modify_callback.html">PxContactModifyCallback</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a179b420149b554519450a31462001072">getContactModifyCallback</a> () const</td></tr>
<tr class="memdesc:a179b420149b554519450a31462001072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the <a class="el" href="classphysx_1_1_px_contact_modify_callback.html" title="An interface class that the user can implement in order to modify contact constraints.">PxContactModifyCallback</a> pointer set with <a class="el" href="classphysx_1_1_np_scene.html#a6a394872deaa7dbd44d6240bd8e8dafc" title="Sets a user callback object, which receives callbacks on all contacts generated for specified actors.">setContactModifyCallback()</a>.  <br /></td></tr>
<tr class="separator:a179b420149b554519450a31462001072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550ed2822765595bfaed32dd0bc0602f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a550ed2822765595bfaed32dd0bc0602f">setCCDContactModifyCallback</a> (<a class="el" href="classphysx_1_1_px_c_c_d_contact_modify_callback.html">PxCCDContactModifyCallback</a> *callback)</td></tr>
<tr class="memdesc:a550ed2822765595bfaed32dd0bc0602f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a user callback object, which receives callbacks on all CCD contacts generated for specified actors.  <br /></td></tr>
<tr class="separator:a550ed2822765595bfaed32dd0bc0602f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8474ccb43f9b2d5bba614ae5256410d3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_c_c_d_contact_modify_callback.html">PxCCDContactModifyCallback</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a8474ccb43f9b2d5bba614ae5256410d3">getCCDContactModifyCallback</a> () const</td></tr>
<tr class="memdesc:a8474ccb43f9b2d5bba614ae5256410d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the <a class="el" href="classphysx_1_1_px_c_c_d_contact_modify_callback.html" title="An interface class that the user can implement in order to modify CCD contact constraints.">PxCCDContactModifyCallback</a> pointer set with <a class="el" href="classphysx_1_1_np_scene.html#a6a394872deaa7dbd44d6240bd8e8dafc" title="Sets a user callback object, which receives callbacks on all contacts generated for specified actors.">setContactModifyCallback()</a>.  <br /></td></tr>
<tr class="separator:a8474ccb43f9b2d5bba614ae5256410d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f115b6be26fd492c312a032e6096f1f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a9f115b6be26fd492c312a032e6096f1f">setBroadPhaseCallback</a> (<a class="el" href="classphysx_1_1_px_broad_phase_callback.html">PxBroadPhaseCallback</a> *callback)</td></tr>
<tr class="memdesc:a9f115b6be26fd492c312a032e6096f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a broad-phase user callback object.  <br /></td></tr>
<tr class="separator:a9f115b6be26fd492c312a032e6096f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff9f96bf4266393bbf15abc146b7d0b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_broad_phase_callback.html">PxBroadPhaseCallback</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a0ff9f96bf4266393bbf15abc146b7d0b">getBroadPhaseCallback</a> () const</td></tr>
<tr class="memdesc:a0ff9f96bf4266393bbf15abc146b7d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the <a class="el" href="classphysx_1_1_px_broad_phase_callback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> pointer set with <a class="el" href="classphysx_1_1_np_scene.html#a9f115b6be26fd492c312a032e6096f1f" title="Sets a broad-phase user callback object.">setBroadPhaseCallback()</a>.  <br /></td></tr>
<tr class="separator:a0ff9f96bf4266393bbf15abc146b7d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a7ada27b5045396732671746f3f598"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a29a7ada27b5045396732671746f3f598">setCCDMaxPasses</a> (PxU32 ccdMaxPasses)</td></tr>
<tr class="memdesc:a29a7ada27b5045396732671746f3f598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of CCD passes.  <br /></td></tr>
<tr class="separator:a29a7ada27b5045396732671746f3f598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5316908b5bfa5dab28df9d5bcab07021"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a5316908b5bfa5dab28df9d5bcab07021">getCCDMaxPasses</a> () const</td></tr>
<tr class="memdesc:a5316908b5bfa5dab28df9d5bcab07021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum number of CCD passes.  <br /></td></tr>
<tr class="separator:a5316908b5bfa5dab28df9d5bcab07021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5d78bc2221c7221b50ad6914fb3e5b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a3b5d78bc2221c7221b50ad6914fb3e5b">setCCDMaxSeparation</a> (const PxReal t)</td></tr>
<tr class="memdesc:a3b5d78bc2221c7221b50ad6914fb3e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum CCD separation.  <br /></td></tr>
<tr class="separator:a3b5d78bc2221c7221b50ad6914fb3e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3787f0da131b268dbc6918a4d10e402d"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a3787f0da131b268dbc6918a4d10e402d">getCCDMaxSeparation</a> () const</td></tr>
<tr class="memdesc:a3787f0da131b268dbc6918a4d10e402d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the maximum CCD separation.  <br /></td></tr>
<tr class="separator:a3787f0da131b268dbc6918a4d10e402d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2d2dee68ffeec00fe92516acffa355"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aef2d2dee68ffeec00fe92516acffa355">setCCDThreshold</a> (const PxReal t)</td></tr>
<tr class="memdesc:aef2d2dee68ffeec00fe92516acffa355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CCD threshold.  <br /></td></tr>
<tr class="separator:aef2d2dee68ffeec00fe92516acffa355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496ec70c2fa7e1219070747aa1f6628b"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a496ec70c2fa7e1219070747aa1f6628b">getCCDThreshold</a> () const</td></tr>
<tr class="memdesc:a496ec70c2fa7e1219070747aa1f6628b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the CCD threshold.  <br /></td></tr>
<tr class="separator:a496ec70c2fa7e1219070747aa1f6628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662fed3a64c14045f3df4e833ded9a58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a662fed3a64c14045f3df4e833ded9a58">setFilterShaderData</a> (const void *data, PxU32 dataSize)</td></tr>
<tr class="memdesc:a662fed3a64c14045f3df4e833ded9a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the shared global filter data which will get passed into the filter shader.  <br /></td></tr>
<tr class="separator:a662fed3a64c14045f3df4e833ded9a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b8cd7f046e9b62188ece65dd367bc2"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ae4b8cd7f046e9b62188ece65dd367bc2">getFilterShaderData</a> () const</td></tr>
<tr class="memdesc:ae4b8cd7f046e9b62188ece65dd367bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the shared global filter data in use for this scene.  <br /></td></tr>
<tr class="separator:ae4b8cd7f046e9b62188ece65dd367bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a3bf5b9a99fcee7eeffea2c34280dc"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a60a3bf5b9a99fcee7eeffea2c34280dc">getFilterShaderDataSize</a> () const</td></tr>
<tr class="memdesc:a60a3bf5b9a99fcee7eeffea2c34280dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the shared global filter data (<a class="el" href="classphysx_1_1_px_scene_desc.html#a5fd01054bfc88a5c30748ad712abfd88" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>)  <br /></td></tr>
<tr class="separator:a60a3bf5b9a99fcee7eeffea2c34280dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad6af74fbfb3d08fc994e5891990e57"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a7d989364d9339d1946b69ec9432f36ae">PxSimulationFilterShader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a2ad6af74fbfb3d08fc994e5891990e57">getFilterShader</a> () const</td></tr>
<tr class="memdesc:a2ad6af74fbfb3d08fc994e5891990e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the custom collision filter shader in use for this scene.  <br /></td></tr>
<tr class="separator:a2ad6af74fbfb3d08fc994e5891990e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59765ccc071f85c69351ab4d5c100774"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_simulation_filter_callback.html">PxSimulationFilterCallback</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a59765ccc071f85c69351ab4d5c100774">getFilterCallback</a> () const</td></tr>
<tr class="memdesc:a59765ccc071f85c69351ab4d5c100774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the custom collision filter callback in use for this scene.  <br /></td></tr>
<tr class="separator:a59765ccc071f85c69351ab4d5c100774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcd29a20d673677b2ae2994db915fda"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#abbcd29a20d673677b2ae2994db915fda">resetFiltering</a> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;actor)</td></tr>
<tr class="memdesc:abbcd29a20d673677b2ae2994db915fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the object to reset interactions and re-run collision filters in the next simulation step.  <br /></td></tr>
<tr class="separator:abbcd29a20d673677b2ae2994db915fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937195856f655e0eee5be694d19002e1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a937195856f655e0eee5be694d19002e1">resetFiltering</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> &amp;actor, <a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> *const *shapes, PxU32 shapeCount)</td></tr>
<tr class="memdesc:a937195856f655e0eee5be694d19002e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the object to reset interactions and re-run collision filters for specified shapes in the next simulation step.  <br /></td></tr>
<tr class="separator:a937195856f655e0eee5be694d19002e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf0baf23bdc4a3d3e39a068839a52f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_pair_filtering_mode.html#acb3b16b245524f65af0b4c19335eaf27">PxPairFilteringMode::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aeaf0baf23bdc4a3d3e39a068839a52f5">getKinematicKinematicFilteringMode</a> () const</td></tr>
<tr class="memdesc:aeaf0baf23bdc4a3d3e39a068839a52f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pair filtering mode for kinematic-kinematic pairs.  <br /></td></tr>
<tr class="separator:aeaf0baf23bdc4a3d3e39a068839a52f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf729829fc20a88d1dfcc5ca7e601370"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_pair_filtering_mode.html#acb3b16b245524f65af0b4c19335eaf27">PxPairFilteringMode::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#abf729829fc20a88d1dfcc5ca7e601370">getStaticKinematicFilteringMode</a> () const</td></tr>
<tr class="memdesc:abf729829fc20a88d1dfcc5ca7e601370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pair filtering mode for static-kinematic pairs.  <br /></td></tr>
<tr class="separator:abf729829fc20a88d1dfcc5ca7e601370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409975323f89f53ab9d8066b903f969c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_physics.html">PxPhysics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a409975323f89f53ab9d8066b903f969c">getPhysics</a> ()</td></tr>
<tr class="memdesc:a409975323f89f53ab9d8066b903f969c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this method to retrieve the Physics SDK.  <br /></td></tr>
<tr class="separator:a409975323f89f53ab9d8066b903f969c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b874fe4d75ec6b6502c547a8bce5a8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8">simulate</a> (PxReal elapsedTime, <a class="el" href="classphysx_1_1_px_base_task.html">physx::PxBaseTask</a> *completionTask, void *scratchBlock, PxU32 scratchBlockSize, bool controlSimulation)</td></tr>
<tr class="memdesc:ac1b874fe4d75ec6b6502c547a8bce5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the simulation by an elapsedTime time.  <br /></td></tr>
<tr class="separator:ac1b874fe4d75ec6b6502c547a8bce5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2ce2ad1dd72a470c319d6cc7a3fc22"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a1f2ce2ad1dd72a470c319d6cc7a3fc22">advance</a> (<a class="el" href="classphysx_1_1_px_base_task.html">physx::PxBaseTask</a> *completionTask)</td></tr>
<tr class="memdesc:a1f2ce2ad1dd72a470c319d6cc7a3fc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamics phase of the simulation pipeline.  <br /></td></tr>
<tr class="separator:a1f2ce2ad1dd72a470c319d6cc7a3fc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01baed715f874e77ba9e1c020346ee89"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a01baed715f874e77ba9e1c020346ee89">collide</a> (PxReal elapsedTime, <a class="el" href="classphysx_1_1_px_base_task.html">physx::PxBaseTask</a> *completionTask, void *scratchBlock, PxU32 scratchBlockSize, bool controlSimulation=true)</td></tr>
<tr class="memdesc:a01baed715f874e77ba9e1c020346ee89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs collision detection for the scene over elapsedTime.  <br /></td></tr>
<tr class="separator:a01baed715f874e77ba9e1c020346ee89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac393a255bb6fcad89ae8452f5682abd3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ac393a255bb6fcad89ae8452f5682abd3">checkResults</a> (bool block)</td></tr>
<tr class="memdesc:ac393a255bb6fcad89ae8452f5682abd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This checks to see if the simulation run has completed.  <br /></td></tr>
<tr class="separator:ac393a255bb6fcad89ae8452f5682abd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd6f8daecd6559e3eda76b192b1ef4b"><td class="memItemLeft" align="right" valign="top"><a id="a8cd6f8daecd6559e3eda76b192b1ef4b" name="a8cd6f8daecd6559e3eda76b192b1ef4b"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkCollision</b> (bool block)</td></tr>
<tr class="separator:a8cd6f8daecd6559e3eda76b192b1ef4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df162bc45ede72a477a0380bdf4a40f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a7df162bc45ede72a477a0380bdf4a40f">fetchCollision</a> (bool block)</td></tr>
<tr class="separator:a7df162bc45ede72a477a0380bdf4a40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459128504c8dff8c4d6af42d1028208d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults</a> (bool block, PxU32 *errorState)</td></tr>
<tr class="separator:a459128504c8dff8c4d6af42d1028208d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2213e7c29eb03a0ee9ec237fb0bfb7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aee2213e7c29eb03a0ee9ec237fb0bfb7">fetchResultsStart</a> (const <a class="el" href="structphysx_1_1_px_contact_pair_header.html">PxContactPairHeader</a> *&amp;contactPairs, PxU32 &amp;nbContactPairs, bool block=false)</td></tr>
<tr class="separator:aee2213e7c29eb03a0ee9ec237fb0bfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f2765833fdfa739d68c687a97f807a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a09f2765833fdfa739d68c687a97f807a">processCallbacks</a> (<a class="el" href="classphysx_1_1_px_base_task.html">physx::PxBaseTask</a> *continuation)</td></tr>
<tr class="separator:a09f2765833fdfa739d68c687a97f807a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e22152e9e62b5e3429640acb5dd939f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a6e22152e9e62b5e3429640acb5dd939f">fetchResultsFinish</a> (PxU32 *errorState=0)</td></tr>
<tr class="separator:a6e22152e9e62b5e3429640acb5dd939f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9679bd2933594aecd892bd9e890b2eae"><td class="memItemLeft" align="right" valign="top"><a id="a9679bd2933594aecd892bd9e890b2eae" name="a9679bd2933594aecd892bd9e890b2eae"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>flush</b> (bool sendPendingReports)</td></tr>
<tr class="separator:a9679bd2933594aecd892bd9e890b2eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad60c8aaea2ce9544fb3d987dc7e9986"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aad60c8aaea2ce9544fb3d987dc7e9986">flushSimulation</a> (bool sendPendingReports)</td></tr>
<tr class="memdesc:aad60c8aaea2ce9544fb3d987dc7e9986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear internal buffers and free memory.  <br /></td></tr>
<tr class="separator:aad60c8aaea2ce9544fb3d987dc7e9986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64368fd3bce3e261a4cd2790432e333"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classphysx_1_1_px_render_buffer.html">PxRenderBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ab64368fd3bce3e261a4cd2790432e333">getRenderBuffer</a> ()</td></tr>
<tr class="memdesc:ab64368fd3bce3e261a4cd2790432e333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the render buffer.  <br /></td></tr>
<tr class="separator:ab64368fd3bce3e261a4cd2790432e333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5ffb28a99ee7845ceb09951cc1eaec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a5e5ffb28a99ee7845ceb09951cc1eaec">setSolverBatchSize</a> (PxU32 solverBatchSize)</td></tr>
<tr class="memdesc:a5e5ffb28a99ee7845ceb09951cc1eaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of actors required to spawn a separate rigid body solver thread.  <br /></td></tr>
<tr class="separator:a5e5ffb28a99ee7845ceb09951cc1eaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e15a81d064f2113e97c6425505b900"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#af7e15a81d064f2113e97c6425505b900">getSolverBatchSize</a> (void) const</td></tr>
<tr class="memdesc:af7e15a81d064f2113e97c6425505b900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of actors required to spawn a separate rigid body solver thread.  <br /></td></tr>
<tr class="separator:af7e15a81d064f2113e97c6425505b900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b18319c90e091728482b0c7e142031"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aa5b18319c90e091728482b0c7e142031">setSolverArticulationBatchSize</a> (PxU32 solverBatchSize)</td></tr>
<tr class="memdesc:aa5b18319c90e091728482b0c7e142031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of articulations required to spawn a separate rigid body solver thread.  <br /></td></tr>
<tr class="separator:aa5b18319c90e091728482b0c7e142031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94badc79f35955ba1c91e24cbcc38213"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a94badc79f35955ba1c91e24cbcc38213">getSolverArticulationBatchSize</a> (void) const</td></tr>
<tr class="memdesc:a94badc79f35955ba1c91e24cbcc38213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of articulations required to spawn a separate rigid body solver thread.  <br /></td></tr>
<tr class="separator:a94badc79f35955ba1c91e24cbcc38213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfe009ab48d0c572f63d4a8e74b827d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a3cfe009ab48d0c572f63d4a8e74b827d">setVisualizationParameter</a> (<a class="el" href="structphysx_1_1_px_visualization_parameter.html#aa447b94a67f50a6573d90f68812ad47e">PxVisualizationParameter::Enum</a> param, PxReal value)</td></tr>
<tr class="memdesc:a3cfe009ab48d0c572f63d4a8e74b827d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that lets you set debug visualization parameters.  <br /></td></tr>
<tr class="separator:a3cfe009ab48d0c572f63d4a8e74b827d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526bf8a471eb0cd2bdbd827e7e022089"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a526bf8a471eb0cd2bdbd827e7e022089">getVisualizationParameter</a> (<a class="el" href="structphysx_1_1_px_visualization_parameter.html#aa447b94a67f50a6573d90f68812ad47e">PxVisualizationParameter::Enum</a> param) const</td></tr>
<tr class="memdesc:a526bf8a471eb0cd2bdbd827e7e022089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that lets you query debug visualization parameters.  <br /></td></tr>
<tr class="separator:a526bf8a471eb0cd2bdbd827e7e022089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e090f275f6f3794f737bf54ffc3201"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a53e090f275f6f3794f737bf54ffc3201">setVisualizationCullingBox</a> (const <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a> &amp;box)</td></tr>
<tr class="memdesc:a53e090f275f6f3794f737bf54ffc3201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a box in world space to which visualization geometry will be (conservatively) culled. Use a non-empty culling box to enable the feature, and an empty culling box to disable it.  <br /></td></tr>
<tr class="separator:a53e090f275f6f3794f737bf54ffc3201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf384537a1340be67465c3877b788f3e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#abf384537a1340be67465c3877b788f3e">getVisualizationCullingBox</a> () const</td></tr>
<tr class="memdesc:abf384537a1340be67465c3877b788f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the visualization culling box.  <br /></td></tr>
<tr class="separator:abf384537a1340be67465c3877b788f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b34b33b5613df07966b9b33c18bb1ac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_task_manager.html">PxTaskManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a4b34b33b5613df07966b9b33c18bb1ac">getTaskManager</a> () const</td></tr>
<tr class="memdesc:a4b34b33b5613df07966b9b33c18bb1ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the task manager associated with this scene.  <br /></td></tr>
<tr class="separator:a4b34b33b5613df07966b9b33c18bb1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b8ad4997c863aadcfbaa923115b546"><td class="memItemLeft" align="right" valign="top"><a id="ac2b8ad4997c863aadcfbaa923115b546" name="ac2b8ad4997c863aadcfbaa923115b546"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkBeginWrite</b> () const</td></tr>
<tr class="separator:ac2b8ad4997c863aadcfbaa923115b546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45856f6287b0b4dbda1a2d44e9f0d110"><td class="memItemLeft" align="right" valign="top"><a id="a45856f6287b0b4dbda1a2d44e9f0d110" name="a45856f6287b0b4dbda1a2d44e9f0d110"></a>
virtual PxCudaContextManager *&#160;</td><td class="memItemRight" valign="bottom"><b>getCudaContextManager</b> ()</td></tr>
<tr class="separator:a45856f6287b0b4dbda1a2d44e9f0d110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165d89debaed76c460cad53931a25bd2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a165d89debaed76c460cad53931a25bd2">setNbContactDataBlocks</a> (PxU32 numBlocks)</td></tr>
<tr class="memdesc:a165d89debaed76c460cad53931a25bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the cache blocks that can be used during <a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a>.  <br /></td></tr>
<tr class="separator:a165d89debaed76c460cad53931a25bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46447105dc218cc7cc21334435c1a49a"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a46447105dc218cc7cc21334435c1a49a">getNbContactDataBlocksUsed</a> () const</td></tr>
<tr class="memdesc:a46447105dc218cc7cc21334435c1a49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of cache blocks currently used by the scene  <br /></td></tr>
<tr class="separator:a46447105dc218cc7cc21334435c1a49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318d6decd73dd9e46cf3681f73ddb7c7"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a318d6decd73dd9e46cf3681f73ddb7c7">getMaxNbContactDataBlocksUsed</a> () const</td></tr>
<tr class="memdesc:a318d6decd73dd9e46cf3681f73ddb7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the maximum number of cache blocks used by the scene  <br /></td></tr>
<tr class="separator:a318d6decd73dd9e46cf3681f73ddb7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa098bf2b3022c3cda9f9b159ecbedb41"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aa098bf2b3022c3cda9f9b159ecbedb41">getContactReportStreamBufferSize</a> () const</td></tr>
<tr class="memdesc:aa098bf2b3022c3cda9f9b159ecbedb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of <a class="el" href="classphysx_1_1_px_scene_desc.html#a6823c8c84bfe0dacb35a7b40057e1037" title="Size of the contact report stream (in bytes).">PxSceneDesc::contactReportStreamBufferSize</a> that was set when creating the scene with <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a>.  <br /></td></tr>
<tr class="separator:aa098bf2b3022c3cda9f9b159ecbedb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e516892594e8af8123fc8b6b35d082f"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a2e516892594e8af8123fc8b6b35d082f">getTimestamp</a> () const</td></tr>
<tr class="memdesc:a2e516892594e8af8123fc8b6b35d082f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the scene's internal timestamp, increased each time a simulation step is completed.  <br /></td></tr>
<tr class="separator:a2e516892594e8af8123fc8b6b35d082f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004cab06974483375cb464438add52a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_cpu_dispatcher.html">PxCpuDispatcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a004cab06974483375cb464438add52a8">getCpuDispatcher</a> () const</td></tr>
<tr class="memdesc:a004cab06974483375cb464438add52a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cpu dispatcher that was set in <a class="el" href="classphysx_1_1_px_scene_desc.html#ac15840b592f420cea5fb5df591910b6b" title="The CPU task dispatcher for the scene.">PxSceneDesc::cpuDispatcher</a> when creating the scene with <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a>.  <br /></td></tr>
<tr class="separator:a004cab06974483375cb464438add52a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1a9f251799640a163457de8a3a3051"><td class="memItemLeft" align="right" valign="top">virtual PxCudaContextManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a4f1a9f251799640a163457de8a3a3051">getCudaContextManager</a> () const</td></tr>
<tr class="memdesc:a4f1a9f251799640a163457de8a3a3051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the CUDA context manager that was set in <a class="el" href="classphysx_1_1_px_scene_desc.html#aced016002da6adf9ed0735a1d0166792" title="The CUDA context manager for the scene.">PxSceneDesc::cudaContextManager</a> when creating the scene with <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a>.  <br /></td></tr>
<tr class="separator:a4f1a9f251799640a163457de8a3a3051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c7c47dec975c65db44e0adcc516455"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_broad_phase_type.html#ac80bf98cad52e689308c4e2b367b8a2f">PxBroadPhaseType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#af2c7c47dec975c65db44e0adcc516455">getBroadPhaseType</a> () const</td></tr>
<tr class="memdesc:af2c7c47dec975c65db44e0adcc516455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns broad-phase type.  <br /></td></tr>
<tr class="separator:af2c7c47dec975c65db44e0adcc516455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5531198c74271c240f3b5e6fbe5eeb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aef5531198c74271c240f3b5e6fbe5eeb">getBroadPhaseCaps</a> (<a class="el" href="structphysx_1_1_px_broad_phase_caps.html">PxBroadPhaseCaps</a> &amp;caps) const</td></tr>
<tr class="memdesc:aef5531198c74271c240f3b5e6fbe5eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets broad-phase caps.  <br /></td></tr>
<tr class="separator:aef5531198c74271c240f3b5e6fbe5eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4702a789d42ef9cbb87ac2265bfab03"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ac4702a789d42ef9cbb87ac2265bfab03">getNbBroadPhaseRegions</a> () const</td></tr>
<tr class="memdesc:ac4702a789d42ef9cbb87ac2265bfab03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of regions currently registered in the broad-phase.  <br /></td></tr>
<tr class="separator:ac4702a789d42ef9cbb87ac2265bfab03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bf39e2d1d05a874a85389ac7cb8a6b"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a91bf39e2d1d05a874a85389ac7cb8a6b">getBroadPhaseRegions</a> (<a class="el" href="structphysx_1_1_px_broad_phase_region_info.html">PxBroadPhaseRegionInfo</a> *userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const</td></tr>
<tr class="memdesc:a91bf39e2d1d05a874a85389ac7cb8a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets broad-phase regions.  <br /></td></tr>
<tr class="separator:a91bf39e2d1d05a874a85389ac7cb8a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5efb25bce20a8f80cc2b2fee9191e1d"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ad5efb25bce20a8f80cc2b2fee9191e1d">addBroadPhaseRegion</a> (const <a class="el" href="structphysx_1_1_px_broad_phase_region.html">PxBroadPhaseRegion</a> &amp;region, bool populateRegion)</td></tr>
<tr class="memdesc:ad5efb25bce20a8f80cc2b2fee9191e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new broad-phase region.  <br /></td></tr>
<tr class="separator:ad5efb25bce20a8f80cc2b2fee9191e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8841de685cd0becffac6f67840b26da8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a8841de685cd0becffac6f67840b26da8">removeBroadPhaseRegion</a> (PxU32 handle)</td></tr>
<tr class="memdesc:a8841de685cd0becffac6f67840b26da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a new broad-phase region.  <br /></td></tr>
<tr class="separator:a8841de685cd0becffac6f67840b26da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf8118db7ad1428634d19a77d3fef25"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aacf8118db7ad1428634d19a77d3fef25">addActors</a> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> *const *actors, PxU32 nbActors)</td></tr>
<tr class="memdesc:aacf8118db7ad1428634d19a77d3fef25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds actors to this scene. Only supports actors of type <a class="el" href="classphysx_1_1_px_rigid_static.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK.">PxRigidStatic</a> and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>.  <br /></td></tr>
<tr class="separator:aacf8118db7ad1428634d19a77d3fef25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29044c15f87df0ce0915591243dde92"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ab29044c15f87df0ce0915591243dde92">addActors</a> (const <a class="el" href="classphysx_1_1_px_pruning_structure.html">PxPruningStructure</a> &amp;prunerStructure)</td></tr>
<tr class="memdesc:ab29044c15f87df0ce0915591243dde92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a pruning structure together with its actors to this scene. Only supports actors of type <a class="el" href="classphysx_1_1_px_rigid_static.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK.">PxRigidStatic</a> and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>.  <br /></td></tr>
<tr class="separator:ab29044c15f87df0ce0915591243dde92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc80373596abbe5469ea1dd7a8955fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aebc80373596abbe5469ea1dd7a8955fd">removeActors</a> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> *const *actors, PxU32 nbActors, bool wakeOnLostTouch)</td></tr>
<tr class="memdesc:aebc80373596abbe5469ea1dd7a8955fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes actors from this scene. Only supports actors of type <a class="el" href="classphysx_1_1_px_rigid_static.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK.">PxRigidStatic</a> and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>.  <br /></td></tr>
<tr class="separator:aebc80373596abbe5469ea1dd7a8955fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9d0cf0d3f68b0ce1b1f790783e4dfe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aaa9d0cf0d3f68b0ce1b1f790783e4dfe">lockRead</a> (const char *file=NULL, PxU32 line=0)</td></tr>
<tr class="memdesc:aaa9d0cf0d3f68b0ce1b1f790783e4dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the scene for reading from the calling thread.  <br /></td></tr>
<tr class="separator:aaa9d0cf0d3f68b0ce1b1f790783e4dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b41d59d5df44ec8a9b78bcf00f4a05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ab3b41d59d5df44ec8a9b78bcf00f4a05">unlockRead</a> ()</td></tr>
<tr class="memdesc:ab3b41d59d5df44ec8a9b78bcf00f4a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the scene from reading.  <br /></td></tr>
<tr class="separator:ab3b41d59d5df44ec8a9b78bcf00f4a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89177e9e4be212c2e15e0b3d03063013"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a89177e9e4be212c2e15e0b3d03063013">lockWrite</a> (const char *file=NULL, PxU32 line=0)</td></tr>
<tr class="memdesc:a89177e9e4be212c2e15e0b3d03063013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the scene for writing from this thread.  <br /></td></tr>
<tr class="separator:a89177e9e4be212c2e15e0b3d03063013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a6471e862677ab570a6db395cfd6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ab63a6471e862677ab570a6db395cfd6b">unlockWrite</a> ()</td></tr>
<tr class="memdesc:ab63a6471e862677ab570a6db395cfd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the scene from writing.  <br /></td></tr>
<tr class="separator:ab63a6471e862677ab570a6db395cfd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5b223a16d7b6b8f868ca3aa3226b9d"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a8d5b223a16d7b6b8f868ca3aa3226b9d">getWakeCounterResetValue</a> () const</td></tr>
<tr class="memdesc:a8d5b223a16d7b6b8f868ca3aa3226b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wake counter reset value.  <br /></td></tr>
<tr class="separator:a8d5b223a16d7b6b8f868ca3aa3226b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a75233131b78e93f4f45fa01416e40d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a4a75233131b78e93f4f45fa01416e40d">shiftOrigin</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;shift)</td></tr>
<tr class="memdesc:a4a75233131b78e93f4f45fa01416e40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the scene origin by the specified vector.  <br /></td></tr>
<tr class="separator:a4a75233131b78e93f4f45fa01416e40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e92ec0389a95e8c47b251cfe3542671"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_pvd_scene_client.html">PxPvdSceneClient</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a8e92ec0389a95e8c47b251cfe3542671">getScenePvdClient</a> ()</td></tr>
<tr class="memdesc:a8e92ec0389a95e8c47b251cfe3542671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Pvd client associated with the scene.  <br /></td></tr>
<tr class="separator:a8e92ec0389a95e8c47b251cfe3542671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42adaf083250b91424e7de7e036c123"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ad42adaf083250b91424e7de7e036c123">copyArticulationData</a> (void *data, void *index, <a class="el" href="classphysx_1_1_px_articulation_gpu_data_type.html#aaee7a9365f0795810cf259e1bbf57aa9">PxArticulationGpuDataType::Enum</a> dataType, const PxU32 nbCopyArticulations, void *copyEvent)</td></tr>
<tr class="memdesc:ad42adaf083250b91424e7de7e036c123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy GPU articulation data from the internal GPU buffer to a user-provided device buffer.  <br /></td></tr>
<tr class="separator:ad42adaf083250b91424e7de7e036c123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d6b03517ead7a491a605ebe5a58e03"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a37d6b03517ead7a491a605ebe5a58e03">applyArticulationData</a> (void *data, void *index, <a class="el" href="classphysx_1_1_px_articulation_gpu_data_type.html#aaee7a9365f0795810cf259e1bbf57aa9">PxArticulationGpuDataType::Enum</a> dataType, const PxU32 nbUpdatedArticulations, void *waitEvent, void *signalEvent)</td></tr>
<tr class="memdesc:a37d6b03517ead7a491a605ebe5a58e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply GPU articulation data from a user-provided device buffer to the internal GPU buffer.  <br /></td></tr>
<tr class="separator:a37d6b03517ead7a491a605ebe5a58e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94412b28f4f3f0c5b8357951b09e17f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ae94412b28f4f3f0c5b8357951b09e17f">copyContactData</a> (void *data, const PxU32 numContactPatches, void *numContactPairs, void *copyEvent)</td></tr>
<tr class="memdesc:ae94412b28f4f3f0c5b8357951b09e17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy contact data from the internal GPU buffer to a user-provided device buffer.  <br /></td></tr>
<tr class="separator:ae94412b28f4f3f0c5b8357951b09e17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ae2cce2628b4ec64b448a23c94f5ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a18ae2cce2628b4ec64b448a23c94f5ae">copySoftBodyData</a> (void **data, void *dataSizes, void *softBodyIndices, <a class="el" href="classphysx_1_1_px_soft_body_data_flag.html#ab195f2b67a93c45e6edd6c65e5603d12">PxSoftBodyDataFlag::Enum</a> flag, const PxU32 nbCopySoftBodies, const PxU32 maxSize, void *copyEvent)</td></tr>
<tr class="memdesc:a18ae2cce2628b4ec64b448a23c94f5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy GPU softbody data from the internal GPU buffer to a user-provided device buffer.  <br /></td></tr>
<tr class="separator:a18ae2cce2628b4ec64b448a23c94f5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8f6366f6d94623b96c0b319b17e947"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a3e8f6366f6d94623b96c0b319b17e947">applySoftBodyData</a> (void **data, void *dataSizes, void *softBodyIndices, <a class="el" href="classphysx_1_1_px_soft_body_data_flag.html#ab195f2b67a93c45e6edd6c65e5603d12">PxSoftBodyDataFlag::Enum</a> flag, const PxU32 nbUpdatedSoftBodies, const PxU32 maxSize, void *applyEvent)</td></tr>
<tr class="memdesc:a3e8f6366f6d94623b96c0b319b17e947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply user-provided data to the internal softbody system.  <br /></td></tr>
<tr class="separator:a3e8f6366f6d94623b96c0b319b17e947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0afa17c61e8b79c19cc95c7c1b094da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ae0afa17c61e8b79c19cc95c7c1b094da">copyBodyData</a> (<a class="el" href="structphysx_1_1_px_gpu_body_data.html">PxGpuBodyData</a> *data, <a class="el" href="structphysx_1_1_px_gpu_actor_pair.html">PxGpuActorPair</a> *index, const PxU32 nbCopyActors, void *copyEvent)</td></tr>
<tr class="memdesc:ae0afa17c61e8b79c19cc95c7c1b094da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy GPU rigid body data from the internal GPU buffer to a user-provided device buffer.  <br /></td></tr>
<tr class="separator:ae0afa17c61e8b79c19cc95c7c1b094da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4413fd6822b11933047b7d7a15acda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a4a4413fd6822b11933047b7d7a15acda">applyActorData</a> (void *data, <a class="el" href="structphysx_1_1_px_gpu_actor_pair.html">PxGpuActorPair</a> *index, PxActorCacheFlag::Enum flag, const PxU32 nbUpdatedActors, void *waitEvent, void *signalEvent)</td></tr>
<tr class="memdesc:a4a4413fd6822b11933047b7d7a15acda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply user-provided data to rigid body.  <br /></td></tr>
<tr class="separator:a4a4413fd6822b11933047b7d7a15acda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb23a770a42516f3a3affd29efaca137"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#afb23a770a42516f3a3affd29efaca137">computeDenseJacobians</a> (const <a class="el" href="structphysx_1_1_px_index_data_pair.html">PxIndexDataPair</a> *indices, PxU32 nbIndices, void *computeEvent)</td></tr>
<tr class="memdesc:afb23a770a42516f3a3affd29efaca137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute dense Jacobian matrices for specified articulations on the GPU.  <br /></td></tr>
<tr class="separator:afb23a770a42516f3a3affd29efaca137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c012dbc95ac4ed53e58b1c11df58546"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a5c012dbc95ac4ed53e58b1c11df58546">computeGeneralizedMassMatrices</a> (const <a class="el" href="structphysx_1_1_px_index_data_pair.html">PxIndexDataPair</a> *indices, PxU32 nbIndices, void *computeEvent)</td></tr>
<tr class="memdesc:a5c012dbc95ac4ed53e58b1c11df58546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the joint-space inertia matrices that maps joint accelerations to joint forces: forces = M * accelerations on the GPU.  <br /></td></tr>
<tr class="separator:a5c012dbc95ac4ed53e58b1c11df58546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eae02ca6642d17f802f7b59d6ba2c5d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a5eae02ca6642d17f802f7b59d6ba2c5d">computeGeneralizedGravityForces</a> (const <a class="el" href="structphysx_1_1_px_index_data_pair.html">PxIndexDataPair</a> *indices, PxU32 nbIndices, void *computeEvent)</td></tr>
<tr class="memdesc:a5eae02ca6642d17f802f7b59d6ba2c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the joint DOF forces required to counteract gravitational forces for the given articulation pose.  <br /></td></tr>
<tr class="separator:a5eae02ca6642d17f802f7b59d6ba2c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7162c3675190cd5c0d11d3ef62fe92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#abd7162c3675190cd5c0d11d3ef62fe92">computeCoriolisAndCentrifugalForces</a> (const <a class="el" href="structphysx_1_1_px_index_data_pair.html">PxIndexDataPair</a> *indices, PxU32 nbIndices, void *computeEvent)</td></tr>
<tr class="memdesc:abd7162c3675190cd5c0d11d3ef62fe92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the joint DOF forces required to counteract coriolis and centrifugal forces for the given articulation pose.  <br /></td></tr>
<tr class="separator:abd7162c3675190cd5c0d11d3ef62fe92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd51494a980d157ebf940565135b99a3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#abd51494a980d157ebf940565135b99a3">applyParticleBufferData</a> (const PxU32 *indices, const <a class="el" href="structphysx_1_1_px_gpu_particle_buffer_index_pair.html">PxGpuParticleBufferIndexPair</a> *bufferIndexPairs, const <a class="el" href="classphysx_1_1_px_flags.html">PxParticleBufferFlags</a> *flags, PxU32 nbUpdatedBuffers, void *waitEvent, void *signalEvent)</td></tr>
<tr class="memdesc:abd51494a980d157ebf940565135b99a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply user-provided data to particle buffers.  <br /></td></tr>
<tr class="separator:abd51494a980d157ebf940565135b99a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed20367cae9708c2ba05a631307cec0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_solver_type.html#a0544603c699b5fc70915ae1e41ba61e6">PxSolverType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a8ed20367cae9708c2ba05a631307cec0">getSolverType</a> () const</td></tr>
<tr class="memdesc:a8ed20367cae9708c2ba05a631307cec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solver model.  <br /></td></tr>
<tr class="separator:a8ed20367cae9708c2ba05a631307cec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751721ed8b3507c78648a4f4015b8b22"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_pxs_simulation_controller.html">PxsSimulationController</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a751721ed8b3507c78648a4f4015b8b22">getSimulationController</a> ()</td></tr>
<tr class="separator:a751721ed8b3507c78648a4f4015b8b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6a5b35350e638ad26fcb195bb0f565"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a4a6a5b35350e638ad26fcb195bb0f565">setActiveActors</a> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> **actors, PxU32 nbActors)</td></tr>
<tr class="separator:a4a6a5b35350e638ad26fcb195bb0f565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af256266034c802d8f30804fbd5d8948d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#af256266034c802d8f30804fbd5d8948d">getFrozenActors</a> (PxU32 &amp;nbActorsOut)</td></tr>
<tr class="separator:af256266034c802d8f30804fbd5d8948d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfe24681f5d4d93900287156ba13bbe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a7dfe24681f5d4d93900287156ba13bbe">setFrozenActorFlag</a> (const bool buildFrozenActors)</td></tr>
<tr class="separator:a7dfe24681f5d4d93900287156ba13bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd685287fdff3efd65c164491aaa4dba"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#abd685287fdff3efd65c164491aaa4dba">forceSceneQueryRebuild</a> ()</td></tr>
<tr class="separator:abd685287fdff3efd65c164491aaa4dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b9c00978b3c130034c42d853444906"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a38b9c00978b3c130034c42d853444906">frameEnd</a> ()</td></tr>
<tr class="separator:a38b9c00978b3c130034c42d853444906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac7601df289d7b6f2d04a9caa1b059"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#abbac7601df289d7b6f2d04a9caa1b059">setDynamicTreeRebuildRateHint</a> (PxU32 dynamicTreeRebuildRateHint)</td></tr>
<tr class="memdesc:abbac7601df289d7b6f2d04a9caa1b059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the rebuild rate of the dynamic tree pruning structures.  <br /></td></tr>
<tr class="separator:abbac7601df289d7b6f2d04a9caa1b059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4895ebc7606b70bff52c29bca6bfaacc"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a4895ebc7606b70bff52c29bca6bfaacc">getDynamicTreeRebuildRateHint</a> () const</td></tr>
<tr class="memdesc:a4895ebc7606b70bff52c29bca6bfaacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the rebuild rate of the dynamic tree pruning structures.  <br /></td></tr>
<tr class="separator:a4895ebc7606b70bff52c29bca6bfaacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43306bf149c77bffadc54bfbb99c17e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#af43306bf149c77bffadc54bfbb99c17e">forceRebuildDynamicTree</a> (PxU32 prunerIndex)</td></tr>
<tr class="memdesc:af43306bf149c77bffadc54bfbb99c17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces dynamic trees to be immediately rebuilt.  <br /></td></tr>
<tr class="separator:af43306bf149c77bffadc54bfbb99c17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9f0d6bdfb888134270afcd4bc65017"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a0d9f0d6bdfb888134270afcd4bc65017">setUpdateMode</a> (<a class="el" href="structphysx_1_1_px_scene_query_update_mode.html#a3d0e848308f503deeb42f966e9fcb99f">PxSceneQueryUpdateMode::Enum</a> updateMode)</td></tr>
<tr class="memdesc:a0d9f0d6bdfb888134270afcd4bc65017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets scene query update mode.  <br /></td></tr>
<tr class="separator:a0d9f0d6bdfb888134270afcd4bc65017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab460ec8a1b24641fe9c9aefdbb53a48b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_scene_query_update_mode.html#a3d0e848308f503deeb42f966e9fcb99f">PxSceneQueryUpdateMode::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ab460ec8a1b24641fe9c9aefdbb53a48b">getUpdateMode</a> () const</td></tr>
<tr class="memdesc:ab460ec8a1b24641fe9c9aefdbb53a48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets scene query update mode.  <br /></td></tr>
<tr class="separator:ab460ec8a1b24641fe9c9aefdbb53a48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2384338a892dd50bb369a84f0e4b58f1"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a2384338a892dd50bb369a84f0e4b58f1">getStaticTimestamp</a> () const</td></tr>
<tr class="memdesc:a2384338a892dd50bb369a84f0e4b58f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the system's internal scene query timestamp, increased each time a change to the static scene query structure is performed.  <br /></td></tr>
<tr class="separator:a2384338a892dd50bb369a84f0e4b58f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca66ea5a07bdff190345b6b15e4c5322"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aca66ea5a07bdff190345b6b15e4c5322">flushUpdates</a> ()</td></tr>
<tr class="memdesc:aca66ea5a07bdff190345b6b15e4c5322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes any changes to the scene query representation.  <br /></td></tr>
<tr class="separator:aca66ea5a07bdff190345b6b15e4c5322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeac119625abbdfc4ff70b36e2f612d8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aaeac119625abbdfc4ff70b36e2f612d8">raycast</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;origin, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;unitDir, const PxReal distance, <a class="el" href="namespacephysx.html#ac822ad888817f5b13417799d9161470c">PxRaycastCallback</a> &amp;hitCall, PxHitFlags hitFlags, const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;filterData, <a class="el" href="classphysx_1_1_px_query_filter_callback.html">PxQueryFilterCallback</a> *filterCall, const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *cache, PxGeometryQueryFlags flags) const</td></tr>
<tr class="memdesc:aaeac119625abbdfc4ff70b36e2f612d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a raycast against objects in the scene, returns results in a PxRaycastBuffer object or via a custom user callback implementation inheriting from PxRaycastCallback.  <br /></td></tr>
<tr class="separator:aaeac119625abbdfc4ff70b36e2f612d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c28d68f0ef41541fd3c040c42b20ab"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a96c28d68f0ef41541fd3c040c42b20ab">sweep</a> (const <a class="el" href="classphysx_1_1_px_geometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;pose, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;unitDir, const PxReal distance, <a class="el" href="namespacephysx.html#aeb5288dec811f06fc7d10620f388dd9d">PxSweepCallback</a> &amp;hitCall, PxHitFlags hitFlags, const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;filterData, <a class="el" href="classphysx_1_1_px_query_filter_callback.html">PxQueryFilterCallback</a> *filterCall, const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *cache, const PxReal inflation, PxGeometryQueryFlags flags) const</td></tr>
<tr class="memdesc:a96c28d68f0ef41541fd3c040c42b20ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sweep test against objects in the scene, returns results in a PxSweepBuffer object or via a custom user callback implementation inheriting from PxSweepCallback.  <br /></td></tr>
<tr class="separator:a96c28d68f0ef41541fd3c040c42b20ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705475136b9d2df3b18b12924b347a7b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a705475136b9d2df3b18b12924b347a7b">overlap</a> (const <a class="el" href="classphysx_1_1_px_geometry.html">PxGeometry</a> &amp;geometry, const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;transform, <a class="el" href="namespacephysx.html#ab1f519b85cba7aabc47ebaf00c505ada">PxOverlapCallback</a> &amp;hitCall, const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;filterData, <a class="el" href="classphysx_1_1_px_query_filter_callback.html">PxQueryFilterCallback</a> *filterCall, const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *cache, PxGeometryQueryFlags flags) const</td></tr>
<tr class="memdesc:a705475136b9d2df3b18b12924b347a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an overlap test of a given geometry against objects in the scene, returns results in a PxOverlapBuffer object or via a custom user callback implementation inheriting from PxOverlapCallback.  <br /></td></tr>
<tr class="separator:a705475136b9d2df3b18b12924b347a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11e696d44f18c302d55ee8496bdf8cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_pruning_structure_type.html#a726793bb8900a198e0f9d9507acfc4ca">PxPruningStructureType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ab11e696d44f18c302d55ee8496bdf8cf">getStaticStructure</a> () const</td></tr>
<tr class="memdesc:ab11e696d44f18c302d55ee8496bdf8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of <a class="el" href="classphysx_1_1_px_scene_query_desc.html#a4f1303e59d71733a16aae16ebcc33b68" title="Defines the structure used to store static objects (PxRigidStatic actors).">PxSceneQueryDesc::staticStructure</a> that was set when creating the scene with <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a>.  <br /></td></tr>
<tr class="separator:ab11e696d44f18c302d55ee8496bdf8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39092847ef955b78947f4c5f008bd25"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_pruning_structure_type.html#a726793bb8900a198e0f9d9507acfc4ca">PxPruningStructureType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ac39092847ef955b78947f4c5f008bd25">getDynamicStructure</a> () const</td></tr>
<tr class="memdesc:ac39092847ef955b78947f4c5f008bd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of <a class="el" href="classphysx_1_1_px_scene_query_desc.html#a3e03342176fbfe85c9df684a7a4226c6" title="Defines the structure used to store dynamic objects (non-PxRigidStatic actors).">PxSceneQueryDesc::dynamicStructure</a> that was set when creating the scene with <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a>.  <br /></td></tr>
<tr class="separator:ac39092847ef955b78947f4c5f008bd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af0a1f6951c3ff59a21c0689405f450"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a2af0a1f6951c3ff59a21c0689405f450">sceneQueriesUpdate</a> (<a class="el" href="classphysx_1_1_px_base_task.html">physx::PxBaseTask</a> *completionTask, bool controlSimulation)</td></tr>
<tr class="memdesc:a2af0a1f6951c3ff59a21c0689405f450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes scene queries update tasks.  <br /></td></tr>
<tr class="separator:a2af0a1f6951c3ff59a21c0689405f450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8b0913ef05f2f973a55e67f2548509"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#a6f8b0913ef05f2f973a55e67f2548509">checkQueries</a> (bool block)</td></tr>
<tr class="memdesc:a6f8b0913ef05f2f973a55e67f2548509"><td class="mdescLeft">&#160;</td><td class="mdescRight">This checks to see if the scene queries update has completed.  <br /></td></tr>
<tr class="separator:a6f8b0913ef05f2f973a55e67f2548509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2120338a94c1753af89e2a06a31ddb7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ae2120338a94c1753af89e2a06a31ddb7">fetchQueries</a> (bool block)</td></tr>
<tr class="separator:ae2120338a94c1753af89e2a06a31ddb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bef405026a9254f9d58f4397a653d73"><td class="memItemLeft" align="right" valign="top"><a id="a9bef405026a9254f9d58f4397a653d73" name="a9bef405026a9254f9d58f4397a653d73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NpScene</b> (const <a class="el" href="classphysx_1_1_px_scene_desc.html">PxSceneDesc</a> &amp;desc, <a class="el" href="classphysx_1_1_np_physics.html">NpPhysics</a> &amp;)</td></tr>
<tr class="separator:a9bef405026a9254f9d58f4397a653d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a32a2e099ba92d680c1c7f812f3e32"><td class="memItemLeft" align="right" valign="top"><a id="aa7a32a2e099ba92d680c1c7f812f3e32" name="aa7a32a2e099ba92d680c1c7f812f3e32"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_np_scene_queries.html">NpSceneQueries</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getNpSQ</b> ()</td></tr>
<tr class="separator:aa7a32a2e099ba92d680c1c7f812f3e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839ab60cbf7a813c796ae17094fa72e4"><td class="memItemLeft" align="right" valign="top"><a id="a839ab60cbf7a813c796ae17094fa72e4" name="a839ab60cbf7a813c796ae17094fa72e4"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> const <a class="el" href="classphysx_1_1_np_scene_queries.html">NpSceneQueries</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getNpSQ</b> () const</td></tr>
<tr class="separator:a839ab60cbf7a813c796ae17094fa72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe0a31040f55615b870ad6e01f64e38"><td class="memItemLeft" align="right" valign="top"><a id="aafe0a31040f55615b870ad6e01f64e38" name="aafe0a31040f55615b870ad6e01f64e38"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_scene_query_system.html">PxSceneQuerySystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSQAPI</b> ()</td></tr>
<tr class="separator:aafe0a31040f55615b870ad6e01f64e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0d2625a7731b4142fbb4414d1b20b9"><td class="memItemLeft" align="right" valign="top"><a id="a8d0d2625a7731b4142fbb4414d1b20b9" name="a8d0d2625a7731b4142fbb4414d1b20b9"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> const <a class="el" href="classphysx_1_1_px_scene_query_system.html">PxSceneQuerySystem</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getSQAPI</b> () const</td></tr>
<tr class="separator:a8d0d2625a7731b4142fbb4414d1b20b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c0da5989a460a9db5b6c0c89c0dcea"><td class="memItemLeft" align="right" valign="top"><a id="a33c0da5989a460a9db5b6c0c89c0dcea" name="a33c0da5989a460a9db5b6c0c89c0dcea"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> PxU64&#160;</td><td class="memItemRight" valign="bottom"><b>getContextId</b> () const</td></tr>
<tr class="separator:a33c0da5989a460a9db5b6c0c89c0dcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110d31e60b0876f42e6d25fd3a4f6725"><td class="memItemLeft" align="right" valign="top"><a id="a110d31e60b0876f42e6d25fd3a4f6725" name="a110d31e60b0876f42e6d25fd3a4f6725"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_task_manager.html">PxTaskManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTaskManagerFast</b> () const</td></tr>
<tr class="separator:a110d31e60b0876f42e6d25fd3a4f6725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ec92d6c21a3bf2627da0ba0a5235f5"><td class="memItemLeft" align="right" valign="top"><a id="a58ec92d6c21a3bf2627da0ba0a5235f5" name="a58ec92d6c21a3bf2627da0ba0a5235f5"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> Sc::SimulationStage::Enum&#160;</td><td class="memItemRight" valign="bottom"><b>getSimulationStage</b> () const</td></tr>
<tr class="separator:a58ec92d6c21a3bf2627da0ba0a5235f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad267dc2ea885fa4f10425019b707db1f"><td class="memItemLeft" align="right" valign="top"><a id="ad267dc2ea885fa4f10425019b707db1f" name="ad267dc2ea885fa4f10425019b707db1f"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setSimulationStage</b> (Sc::SimulationStage::Enum stage)</td></tr>
<tr class="separator:ad267dc2ea885fa4f10425019b707db1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621467413d7a8514d82011bb1ac77bdf"><td class="memItemLeft" align="right" valign="top"><a id="a621467413d7a8514d82011bb1ac77bdf" name="a621467413d7a8514d82011bb1ac77bdf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addActorInternal</b> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;actor, const <a class="el" href="classphysx_1_1_px_b_v_h.html">PxBVH</a> *bvh)</td></tr>
<tr class="separator:a621467413d7a8514d82011bb1ac77bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be2778a232a9a101aa40ba363b96fd8"><td class="memItemLeft" align="right" valign="top"><a id="a0be2778a232a9a101aa40ba363b96fd8" name="a0be2778a232a9a101aa40ba363b96fd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeActorInternal</b> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;actor, bool wakeOnLostTouch, bool removeFromAggregate)</td></tr>
<tr class="separator:a0be2778a232a9a101aa40ba363b96fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592a230c777f17839475c4a2ecfb9946"><td class="memItemLeft" align="right" valign="top"><a id="a592a230c777f17839475c4a2ecfb9946" name="a592a230c777f17839475c4a2ecfb9946"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addActorsInternal</b> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> *const *<a class="el" href="group__foundation.html#ga3b15bb2f7697b2bed10eb5477909fbe4">PX_RESTRICT</a> actors, PxU32 nbActors, const <a class="el" href="classphysx_1_1_sq_1_1_pruning_structure.html">Sq::PruningStructure</a> *ps=NULL)</td></tr>
<tr class="separator:a592a230c777f17839475c4a2ecfb9946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c033f8acd44dae46dcf3ef2225dca5"><td class="memItemLeft" align="right" valign="top"><a id="a27c033f8acd44dae46dcf3ef2225dca5" name="a27c033f8acd44dae46dcf3ef2225dca5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addArticulationInternal</b> (<a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> &amp;)</td></tr>
<tr class="separator:a27c033f8acd44dae46dcf3ef2225dca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba64c4f7b78676a6c8e5098402225ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#aba64c4f7b78676a6c8e5098402225ed5">removeArticulationInternal</a> (<a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> &amp;, bool wakeOnLostTouch, bool removeFromAggregate)</td></tr>
<tr class="separator:aba64c4f7b78676a6c8e5098402225ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0842adbdb1ebca64afc0ba01b9db532f"><td class="memItemLeft" align="right" valign="top"><a id="a0842adbdb1ebca64afc0ba01b9db532f" name="a0842adbdb1ebca64afc0ba01b9db532f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addMaterial</b> (const <a class="el" href="classphysx_1_1_np_material.html">NpMaterial</a> &amp;mat)</td></tr>
<tr class="separator:a0842adbdb1ebca64afc0ba01b9db532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367449b9b04657aeb707446d77305a77"><td class="memItemLeft" align="right" valign="top"><a id="a367449b9b04657aeb707446d77305a77" name="a367449b9b04657aeb707446d77305a77"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateMaterial</b> (const <a class="el" href="classphysx_1_1_np_material.html">NpMaterial</a> &amp;mat)</td></tr>
<tr class="separator:a367449b9b04657aeb707446d77305a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bab59786b302d44e4be95b38debef9"><td class="memItemLeft" align="right" valign="top"><a id="a99bab59786b302d44e4be95b38debef9" name="a99bab59786b302d44e4be95b38debef9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeMaterial</b> (const <a class="el" href="classphysx_1_1_np_material.html">NpMaterial</a> &amp;mat)</td></tr>
<tr class="separator:a99bab59786b302d44e4be95b38debef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a359058a00d7b803ff623d00cd764b"><td class="memItemLeft" align="right" valign="top"><a id="a80a359058a00d7b803ff623d00cd764b" name="a80a359058a00d7b803ff623d00cd764b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>executeScene</b> (<a class="el" href="classphysx_1_1_px_base_task.html">PxBaseTask</a> *continuation)</td></tr>
<tr class="separator:a80a359058a00d7b803ff623d00cd764b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92745bd44493fdac17264a18c4ab543f"><td class="memItemLeft" align="right" valign="top"><a id="a92745bd44493fdac17264a18c4ab543f" name="a92745bd44493fdac17264a18c4ab543f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>executeCollide</b> (<a class="el" href="classphysx_1_1_px_base_task.html">PxBaseTask</a> *continuation)</td></tr>
<tr class="separator:a92745bd44493fdac17264a18c4ab543f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83eb785de64a1ea85de971cc16dc9672"><td class="memItemLeft" align="right" valign="top"><a id="a83eb785de64a1ea85de971cc16dc9672" name="a83eb785de64a1ea85de971cc16dc9672"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>executeAdvance</b> (<a class="el" href="classphysx_1_1_px_base_task.html">PxBaseTask</a> *continuation)</td></tr>
<tr class="separator:a83eb785de64a1ea85de971cc16dc9672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec42ab6224e46bda6df88005ae918451"><td class="memItemLeft" align="right" valign="top"><a id="aec42ab6224e46bda6df88005ae918451" name="aec42ab6224e46bda6df88005ae918451"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>constraintBreakEventNotify</b> (<a class="el" href="classphysx_1_1_px_constraint.html">PxConstraint</a> *const *constraints, PxU32 count)</td></tr>
<tr class="separator:aec42ab6224e46bda6df88005ae918451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2c087decbaaca4aab4db06f0620b09"><td class="memItemLeft" align="right" valign="top"><a id="a1b2c087decbaaca4aab4db06f0620b09" name="a1b2c087decbaaca4aab4db06f0620b09"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>loadFromDesc</b> (const <a class="el" href="classphysx_1_1_px_scene_desc.html">PxSceneDesc</a> &amp;)</td></tr>
<tr class="separator:a1b2c087decbaaca4aab4db06f0620b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f0158cff19ae79d635b434671db7ed"><td class="memTemplParams" colspan="2"><a id="a19f0158cff19ae79d635b434671db7ed" name="a19f0158cff19ae79d635b434671db7ed"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19f0158cff19ae79d635b434671db7ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>removeFromRigidActorList</b> (T &amp;)</td></tr>
<tr class="separator:a19f0158cff19ae79d635b434671db7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f646bf0150824966498ba74d29946a"><td class="memItemLeft" align="right" valign="top"><a id="ae6f646bf0150824966498ba74d29946a" name="ae6f646bf0150824966498ba74d29946a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromRigidDynamicList</b> (<a class="el" href="classphysx_1_1_np_rigid_dynamic.html">NpRigidDynamic</a> &amp;)</td></tr>
<tr class="separator:ae6f646bf0150824966498ba74d29946a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebc195833a828402b9be17d5f934fa8"><td class="memItemLeft" align="right" valign="top"><a id="acebc195833a828402b9be17d5f934fa8" name="acebc195833a828402b9be17d5f934fa8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromRigidStaticList</b> (<a class="el" href="classphysx_1_1_np_rigid_static.html">NpRigidStatic</a> &amp;)</td></tr>
<tr class="separator:acebc195833a828402b9be17d5f934fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5e9f159680d1d4cbd956725f8de34a"><td class="memItemLeft" align="right" valign="top"><a id="add5e9f159680d1d4cbd956725f8de34a" name="add5e9f159680d1d4cbd956725f8de34a"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromArticulationList</b> (<a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> &amp;)</td></tr>
<tr class="separator:add5e9f159680d1d4cbd956725f8de34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f35b9186a2af4d4cd9c7e7e62f0b16"><td class="memItemLeft" align="right" valign="top"><a id="ac1f35b9186a2af4d4cd9c7e7e62f0b16" name="ac1f35b9186a2af4d4cd9c7e7e62f0b16"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromSoftBodyList</b> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> &amp;)</td></tr>
<tr class="separator:ac1f35b9186a2af4d4cd9c7e7e62f0b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9b2c9596739ad357e8c2fdf016586d"><td class="memItemLeft" align="right" valign="top"><a id="aee9b2c9596739ad357e8c2fdf016586d" name="aee9b2c9596739ad357e8c2fdf016586d"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromFEMClothList</b> (PxFEMCloth &amp;)</td></tr>
<tr class="separator:aee9b2c9596739ad357e8c2fdf016586d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163df00e0be3b59f9f4341336c8cf90a"><td class="memItemLeft" align="right" valign="top"><a id="a163df00e0be3b59f9f4341336c8cf90a" name="a163df00e0be3b59f9f4341336c8cf90a"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromParticleSystemList</b> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> &amp;)</td></tr>
<tr class="separator:a163df00e0be3b59f9f4341336c8cf90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a03354f00143a6027ce1088dcbf9a49"><td class="memItemLeft" align="right" valign="top"><a id="a5a03354f00143a6027ce1088dcbf9a49" name="a5a03354f00143a6027ce1088dcbf9a49"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromParticleSystemList</b> (PxFLIPParticleSystem &amp;)</td></tr>
<tr class="separator:a5a03354f00143a6027ce1088dcbf9a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f67ecb8a8586af83b1ef9dbf874b71"><td class="memItemLeft" align="right" valign="top"><a id="a35f67ecb8a8586af83b1ef9dbf874b71" name="a35f67ecb8a8586af83b1ef9dbf874b71"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromParticleSystemList</b> (PxMPMParticleSystem &amp;)</td></tr>
<tr class="separator:a35f67ecb8a8586af83b1ef9dbf874b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66191cb3a1fc453ee21dbf9c2d7a9b7f"><td class="memItemLeft" align="right" valign="top"><a id="a66191cb3a1fc453ee21dbf9c2d7a9b7f" name="a66191cb3a1fc453ee21dbf9c2d7a9b7f"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromParticleSystemList</b> (PxCustomParticleSystem &amp;)</td></tr>
<tr class="separator:a66191cb3a1fc453ee21dbf9c2d7a9b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b93334db074803ce53b5e4232cab8f9"><td class="memItemLeft" align="right" valign="top"><a id="a6b93334db074803ce53b5e4232cab8f9" name="a6b93334db074803ce53b5e4232cab8f9"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromHairSystemList</b> (PxHairSystem &amp;)</td></tr>
<tr class="separator:a6b93334db074803ce53b5e4232cab8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950508933e46cf9749dbbfb92fc3468e"><td class="memItemLeft" align="right" valign="top"><a id="a950508933e46cf9749dbbfb92fc3468e" name="a950508933e46cf9749dbbfb92fc3468e"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromAggregateList</b> (<a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> &amp;)</td></tr>
<tr class="separator:a950508933e46cf9749dbbfb92fc3468e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c496e06dfe3447c1fe7cc0db14cf7d"><td class="memItemLeft" align="right" valign="top"><a id="aa5c496e06dfe3447c1fe7cc0db14cf7d" name="aa5c496e06dfe3447c1fe7cc0db14cf7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addDirtyConstraint</b> (<a class="el" href="classphysx_1_1_np_constraint.html">NpConstraint</a> *constraint)</td></tr>
<tr class="separator:aa5c496e06dfe3447c1fe7cc0db14cf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb13a9cda233574b56630c9e59913cf3"><td class="memItemLeft" align="right" valign="top"><a id="abb13a9cda233574b56630c9e59913cf3" name="abb13a9cda233574b56630c9e59913cf3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addToConstraintList</b> (<a class="el" href="classphysx_1_1_px_constraint.html">PxConstraint</a> &amp;)</td></tr>
<tr class="separator:abb13a9cda233574b56630c9e59913cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd759e0309bd92149daacf5985108f9"><td class="memItemLeft" align="right" valign="top"><a id="affd759e0309bd92149daacf5985108f9" name="affd759e0309bd92149daacf5985108f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromConstraintList</b> (<a class="el" href="classphysx_1_1_px_constraint.html">PxConstraint</a> &amp;)</td></tr>
<tr class="separator:affd759e0309bd92149daacf5985108f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9f6135a2bffe5a25a85eb7c13540e3"><td class="memItemLeft" align="right" valign="top"><a id="a9a9f6135a2bffe5a25a85eb7c13540e3" name="a9a9f6135a2bffe5a25a85eb7c13540e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addArticulationLink</b> (<a class="el" href="classphysx_1_1_np_articulation_link.html">NpArticulationLink</a> &amp;link)</td></tr>
<tr class="separator:a9a9f6135a2bffe5a25a85eb7c13540e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330f106acaf86bd1153c79b7491e1827"><td class="memItemLeft" align="right" valign="top"><a id="a330f106acaf86bd1153c79b7491e1827" name="a330f106acaf86bd1153c79b7491e1827"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addArticulationLinkBody</b> (<a class="el" href="classphysx_1_1_np_articulation_link.html">NpArticulationLink</a> &amp;link)</td></tr>
<tr class="separator:a330f106acaf86bd1153c79b7491e1827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94158c351dfab060368e851655b3be8"><td class="memItemLeft" align="right" valign="top"><a id="aa94158c351dfab060368e851655b3be8" name="aa94158c351dfab060368e851655b3be8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addArticulationLinkConstraint</b> (<a class="el" href="classphysx_1_1_np_articulation_link.html">NpArticulationLink</a> &amp;link)</td></tr>
<tr class="separator:aa94158c351dfab060368e851655b3be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1decf1ef72d0c1b1a4666ca621e8a7b"><td class="memItemLeft" align="right" valign="top"><a id="ad1decf1ef72d0c1b1a4666ca621e8a7b" name="ad1decf1ef72d0c1b1a4666ca621e8a7b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeArticulationLink</b> (<a class="el" href="classphysx_1_1_np_articulation_link.html">NpArticulationLink</a> &amp;link, bool wakeOnLostTouch)</td></tr>
<tr class="separator:ad1decf1ef72d0c1b1a4666ca621e8a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ecd64e888033934553db18a029fee4"><td class="memItemLeft" align="right" valign="top"><a id="ad9ecd64e888033934553db18a029fee4" name="ad9ecd64e888033934553db18a029fee4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addArticulationAttachment</b> (<a class="el" href="classphysx_1_1_np_articulation_attachment.html">NpArticulationAttachment</a> &amp;attachment)</td></tr>
<tr class="separator:ad9ecd64e888033934553db18a029fee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba7959ddab5ce1a4897c7e3c194107d"><td class="memItemLeft" align="right" valign="top"><a id="a3ba7959ddab5ce1a4897c7e3c194107d" name="a3ba7959ddab5ce1a4897c7e3c194107d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeArticulationAttachment</b> (<a class="el" href="classphysx_1_1_np_articulation_attachment.html">NpArticulationAttachment</a> &amp;attachment)</td></tr>
<tr class="separator:a3ba7959ddab5ce1a4897c7e3c194107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88aff6ab4f4c19075bd2b678f634dfc6"><td class="memItemLeft" align="right" valign="top"><a id="a88aff6ab4f4c19075bd2b678f634dfc6" name="a88aff6ab4f4c19075bd2b678f634dfc6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addArticulationTendonJoint</b> (<a class="el" href="classphysx_1_1_np_articulation_tendon_joint.html">NpArticulationTendonJoint</a> &amp;joint)</td></tr>
<tr class="separator:a88aff6ab4f4c19075bd2b678f634dfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9554656859843793e499eff4b2d8f5"><td class="memItemLeft" align="right" valign="top"><a id="a5d9554656859843793e499eff4b2d8f5" name="a5d9554656859843793e499eff4b2d8f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeArticulationTendonJoint</b> (<a class="el" href="classphysx_1_1_np_articulation_tendon_joint.html">NpArticulationTendonJoint</a> &amp;joint)</td></tr>
<tr class="separator:a5d9554656859843793e499eff4b2d8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aca68ed2e6ee23ffdd0eaf79c6b8ae6"><td class="memItemLeft" align="right" valign="top"><a id="a4aca68ed2e6ee23ffdd0eaf79c6b8ae6" name="a4aca68ed2e6ee23ffdd0eaf79c6b8ae6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeArticulationTendons</b> (<a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> &amp;articulation)</td></tr>
<tr class="separator:a4aca68ed2e6ee23ffdd0eaf79c6b8ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8a2f2850aeadf880dfc233d8154999"><td class="memItemLeft" align="right" valign="top"><a id="a6b8a2f2850aeadf880dfc233d8154999" name="a6b8a2f2850aeadf880dfc233d8154999"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeArticulationSensors</b> (<a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> &amp;articulation)</td></tr>
<tr class="separator:a6b8a2f2850aeadf880dfc233d8154999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a1d5fe65452b238833b64cf453a04b"><td class="memItemLeft" align="right" valign="top"><a id="a62a1d5fe65452b238833b64cf453a04b" name="a62a1d5fe65452b238833b64cf453a04b"></a>
StartWriteResult::Enum&#160;</td><td class="memItemRight" valign="bottom"><b>startWrite</b> (bool allowReentry)</td></tr>
<tr class="separator:a62a1d5fe65452b238833b64cf453a04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690b0a40335cfb16b2732228f20f1293"><td class="memItemLeft" align="right" valign="top"><a id="a690b0a40335cfb16b2732228f20f1293" name="a690b0a40335cfb16b2732228f20f1293"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stopWrite</b> (bool allowReentry)</td></tr>
<tr class="separator:a690b0a40335cfb16b2732228f20f1293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bc2918a0d7b809c829a88a56406c4e"><td class="memItemLeft" align="right" valign="top"><a id="a37bc2918a0d7b809c829a88a56406c4e" name="a37bc2918a0d7b809c829a88a56406c4e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>startRead</b> () const</td></tr>
<tr class="separator:a37bc2918a0d7b809c829a88a56406c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ff786e1eb9d9b6e1e419168d881843"><td class="memItemLeft" align="right" valign="top"><a id="a72ff786e1eb9d9b6e1e419168d881843" name="a72ff786e1eb9d9b6e1e419168d881843"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>stopRead</b> () const</td></tr>
<tr class="separator:a72ff786e1eb9d9b6e1e419168d881843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e918cc63db9738a010599cb827db12d"><td class="memItemLeft" align="right" valign="top"><a id="a8e918cc63db9738a010599cb827db12d" name="a8e918cc63db9738a010599cb827db12d"></a>
PxU32&#160;</td><td class="memItemRight" valign="bottom"><b>getReadWriteErrorCount</b> () const</td></tr>
<tr class="separator:a8e918cc63db9738a010599cb827db12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106836e0fa289db21d231746119d041c"><td class="memItemLeft" align="right" valign="top"><a id="a106836e0fa289db21d231746119d041c" name="a106836e0fa289db21d231746119d041c"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>updatePhysXIndicator</b> ()</td></tr>
<tr class="separator:a106836e0fa289db21d231746119d041c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd5eea56aff84ea0fc449f7255bedca"><td class="memItemLeft" align="right" valign="top"><a id="a3dd5eea56aff84ea0fc449f7255bedca" name="a3dd5eea56aff84ea0fc449f7255bedca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scAddAggregate</b> (<a class="el" href="classphysx_1_1_np_aggregate.html">NpAggregate</a> &amp;)</td></tr>
<tr class="separator:a3dd5eea56aff84ea0fc449f7255bedca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6c2c80a7897a719fa998efe483cfab"><td class="memItemLeft" align="right" valign="top"><a id="aad6c2c80a7897a719fa998efe483cfab" name="aad6c2c80a7897a719fa998efe483cfab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scRemoveAggregate</b> (<a class="el" href="classphysx_1_1_np_aggregate.html">NpAggregate</a> &amp;)</td></tr>
<tr class="separator:aad6c2c80a7897a719fa998efe483cfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4035a73b902122d6730ca06688abac59"><td class="memItemLeft" align="right" valign="top"><a id="a4035a73b902122d6730ca06688abac59" name="a4035a73b902122d6730ca06688abac59"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scSwitchRigidToNoSim</b> (<a class="el" href="classphysx_1_1_np_actor.html">NpActor</a> &amp;)</td></tr>
<tr class="separator:a4035a73b902122d6730ca06688abac59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb9a6e197de2687a09feba946180271"><td class="memItemLeft" align="right" valign="top"><a id="adfb9a6e197de2687a09feba946180271" name="adfb9a6e197de2687a09feba946180271"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scSwitchRigidFromNoSim</b> (<a class="el" href="classphysx_1_1_np_actor.html">NpActor</a> &amp;)</td></tr>
<tr class="separator:adfb9a6e197de2687a09feba946180271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709877a040aaa304d5c523a7da364d2a"><td class="memItemLeft" align="right" valign="top"><a id="a709877a040aaa304d5c523a7da364d2a" name="a709877a040aaa304d5c523a7da364d2a"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAPIReadForbidden</b> () const</td></tr>
<tr class="separator:a709877a040aaa304d5c523a7da364d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb86fb4920347f9a0add73b247cb208"><td class="memItemLeft" align="right" valign="top"><a id="a9eb86fb4920347f9a0add73b247cb208" name="a9eb86fb4920347f9a0add73b247cb208"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setAPIReadToForbidden</b> ()</td></tr>
<tr class="separator:a9eb86fb4920347f9a0add73b247cb208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03ef5ee3395401b1c94e0d2b5456c4b"><td class="memItemLeft" align="right" valign="top"><a id="ab03ef5ee3395401b1c94e0d2b5456c4b" name="ab03ef5ee3395401b1c94e0d2b5456c4b"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setAPIReadToAllowed</b> ()</td></tr>
<tr class="separator:ab03ef5ee3395401b1c94e0d2b5456c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e21fa2b21cad7b337910ef80a9425ed"><td class="memItemLeft" align="right" valign="top"><a id="a2e21fa2b21cad7b337910ef80a9425ed" name="a2e21fa2b21cad7b337910ef80a9425ed"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>isCollisionPhaseActive</b> () const</td></tr>
<tr class="separator:a2e21fa2b21cad7b337910ef80a9425ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772d84059abcfd12d26001e70b6fc0b0"><td class="memItemLeft" align="right" valign="top"><a id="a772d84059abcfd12d26001e70b6fc0b0" name="a772d84059abcfd12d26001e70b6fc0b0"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAPIWriteForbidden</b> () const</td></tr>
<tr class="separator:a772d84059abcfd12d26001e70b6fc0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe5068bbdfafbe9fe41a13ea985aab3"><td class="memItemLeft" align="right" valign="top"><a id="aabe5068bbdfafbe9fe41a13ea985aab3" name="aabe5068bbdfafbe9fe41a13ea985aab3"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setAPIWriteToForbidden</b> ()</td></tr>
<tr class="separator:aabe5068bbdfafbe9fe41a13ea985aab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4f329bd16d03b54ab1a06f450c7abf"><td class="memItemLeft" align="right" valign="top"><a id="a4c4f329bd16d03b54ab1a06f450c7abf" name="a4c4f329bd16d03b54ab1a06f450c7abf"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setAPIWriteToAllowed</b> ()</td></tr>
<tr class="separator:a4c4f329bd16d03b54ab1a06f450c7abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4fecdc00c0a3c653ebd8f81d248d67"><td class="memItemLeft" align="right" valign="top"><a id="a5d4fecdc00c0a3c653ebd8f81d248d67" name="a5d4fecdc00c0a3c653ebd8f81d248d67"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> const <a class="el" href="classphysx_1_1_sc_1_1_scene.html">Sc::Scene</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getScScene</b> () const</td></tr>
<tr class="separator:a5d4fecdc00c0a3c653ebd8f81d248d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747fce79eea6cd6a1b4db75335d215b7"><td class="memItemLeft" align="right" valign="top"><a id="a747fce79eea6cd6a1b4db75335d215b7" name="a747fce79eea6cd6a1b4db75335d215b7"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_sc_1_1_scene.html">Sc::Scene</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getScScene</b> ()</td></tr>
<tr class="separator:a747fce79eea6cd6a1b4db75335d215b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9743cac0052a5cfd875b51a259ebb84"><td class="memItemLeft" align="right" valign="top"><a id="ae9743cac0052a5cfd875b51a259ebb84" name="ae9743cac0052a5cfd875b51a259ebb84"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> PxU32&#160;</td><td class="memItemRight" valign="bottom"><b>getFlagsFast</b> () const</td></tr>
<tr class="separator:ae9743cac0052a5cfd875b51a259ebb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e36b7c71c1a355293f681f7b1b3c0b"><td class="memItemLeft" align="right" valign="top"><a id="a59e36b7c71c1a355293f681f7b1b3c0b" name="a59e36b7c71c1a355293f681f7b1b3c0b"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> PxReal&#160;</td><td class="memItemRight" valign="bottom"><b>getWakeCounterResetValueInternal</b> () const</td></tr>
<tr class="separator:a59e36b7c71c1a355293f681f7b1b3c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee60a2a5b4b4a9b59db1232a481dd15"><td class="memItemLeft" align="right" valign="top"><a id="a5ee60a2a5b4b4a9b59db1232a481dd15" name="a5ee60a2a5b4b4a9b59db1232a481dd15"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scAddActor</b> (<a class="el" href="classphysx_1_1_np_rigid_static.html">NpRigidStatic</a> &amp;, bool noSim, <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a> *uninflatedBounds, const <a class="el" href="classphysx_1_1_gu_1_1_b_v_h.html">Gu::BVH</a> *bvh)</td></tr>
<tr class="separator:a5ee60a2a5b4b4a9b59db1232a481dd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0510cf03ad7620ee8fbf9101bbf6dba9"><td class="memItemLeft" align="right" valign="top"><a id="a0510cf03ad7620ee8fbf9101bbf6dba9" name="a0510cf03ad7620ee8fbf9101bbf6dba9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scRemoveActor</b> (<a class="el" href="classphysx_1_1_np_rigid_static.html">NpRigidStatic</a> &amp;, bool wakeOnLostTouch, bool noSim)</td></tr>
<tr class="separator:a0510cf03ad7620ee8fbf9101bbf6dba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52522e96464ab0456e5da94a8f7dc726"><td class="memItemLeft" align="right" valign="top"><a id="a52522e96464ab0456e5da94a8f7dc726" name="a52522e96464ab0456e5da94a8f7dc726"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scAddActor</b> (<a class="el" href="classphysx_1_1_np_rigid_dynamic.html">NpRigidDynamic</a> &amp;, bool noSim, <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a> *uninflatedBounds, const <a class="el" href="classphysx_1_1_gu_1_1_b_v_h.html">Gu::BVH</a> *bvh)</td></tr>
<tr class="separator:a52522e96464ab0456e5da94a8f7dc726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f37486bd06a8519675ddde0df5801f"><td class="memItemLeft" align="right" valign="top"><a id="a05f37486bd06a8519675ddde0df5801f" name="a05f37486bd06a8519675ddde0df5801f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scRemoveActor</b> (<a class="el" href="classphysx_1_1_np_rigid_dynamic.html">NpRigidDynamic</a> &amp;, bool wakeOnLostTouch, bool noSim)</td></tr>
<tr class="separator:a05f37486bd06a8519675ddde0df5801f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1513264403594f78239da14ec5bb6b"><td class="memItemLeft" align="right" valign="top"><a id="a0d1513264403594f78239da14ec5bb6b" name="a0d1513264403594f78239da14ec5bb6b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scAddActor</b> (<a class="el" href="classphysx_1_1_np_articulation_link.html">NpArticulationLink</a> &amp;, bool noSim, <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a> *uninflatedBounds, const <a class="el" href="classphysx_1_1_gu_1_1_b_v_h.html">Gu::BVH</a> *bvh)</td></tr>
<tr class="separator:a0d1513264403594f78239da14ec5bb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5509a2b6ae19557403e6965eb181396"><td class="memItemLeft" align="right" valign="top"><a id="ad5509a2b6ae19557403e6965eb181396" name="ad5509a2b6ae19557403e6965eb181396"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scRemoveActor</b> (<a class="el" href="classphysx_1_1_np_articulation_link.html">NpArticulationLink</a> &amp;, bool wakeOnLostTouch, bool noSim)</td></tr>
<tr class="separator:ad5509a2b6ae19557403e6965eb181396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9a100431f1f9e78d69669ba63b1c72"><td class="memItemLeft" align="right" valign="top"><a id="a0e9a100431f1f9e78d69669ba63b1c72" name="a0e9a100431f1f9e78d69669ba63b1c72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scAddArticulation</b> (<a class="el" href="classphysx_1_1_np_articulation_reduced_coordinate.html">NpArticulationReducedCoordinate</a> &amp;)</td></tr>
<tr class="separator:a0e9a100431f1f9e78d69669ba63b1c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c90fc077fb3b1b583147153a0d435c"><td class="memItemLeft" align="right" valign="top"><a id="ab1c90fc077fb3b1b583147153a0d435c" name="ab1c90fc077fb3b1b583147153a0d435c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scRemoveArticulation</b> (<a class="el" href="classphysx_1_1_np_articulation_reduced_coordinate.html">NpArticulationReducedCoordinate</a> &amp;)</td></tr>
<tr class="separator:ab1c90fc077fb3b1b583147153a0d435c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1034cfa756b7e293e38130df35a7522e"><td class="memItemLeft" align="right" valign="top"><a id="a1034cfa756b7e293e38130df35a7522e" name="a1034cfa756b7e293e38130df35a7522e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scAddArticulationJoint</b> (<a class="el" href="classphysx_1_1_np_articulation_joint_reduced_coordinate.html">NpArticulationJointReducedCoordinate</a> &amp;)</td></tr>
<tr class="separator:a1034cfa756b7e293e38130df35a7522e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c72ea03d902e330b00fbb119e43a36"><td class="memItemLeft" align="right" valign="top"><a id="a45c72ea03d902e330b00fbb119e43a36" name="a45c72ea03d902e330b00fbb119e43a36"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scRemoveArticulationJoint</b> (<a class="el" href="classphysx_1_1_np_articulation_joint_reduced_coordinate.html">NpArticulationJointReducedCoordinate</a> &amp;)</td></tr>
<tr class="separator:a45c72ea03d902e330b00fbb119e43a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ceab9f4b1dd2f460d1fb02a6f20446b"><td class="memItemLeft" align="right" valign="top"><a id="a7ceab9f4b1dd2f460d1fb02a6f20446b" name="a7ceab9f4b1dd2f460d1fb02a6f20446b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scAddArticulationSpatialTendon</b> (<a class="el" href="classphysx_1_1_np_articulation_spatial_tendon.html">NpArticulationSpatialTendon</a> &amp;)</td></tr>
<tr class="separator:a7ceab9f4b1dd2f460d1fb02a6f20446b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b76a64e902fc1c9dc1023648e392089"><td class="memItemLeft" align="right" valign="top"><a id="a5b76a64e902fc1c9dc1023648e392089" name="a5b76a64e902fc1c9dc1023648e392089"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scRemoveArticulationSpatialTendon</b> (<a class="el" href="classphysx_1_1_np_articulation_spatial_tendon.html">NpArticulationSpatialTendon</a> &amp;)</td></tr>
<tr class="separator:a5b76a64e902fc1c9dc1023648e392089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf573a25c2ed53c80dff2edc3535e01a"><td class="memItemLeft" align="right" valign="top"><a id="aaf573a25c2ed53c80dff2edc3535e01a" name="aaf573a25c2ed53c80dff2edc3535e01a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scAddArticulationFixedTendon</b> (<a class="el" href="classphysx_1_1_np_articulation_fixed_tendon.html">NpArticulationFixedTendon</a> &amp;)</td></tr>
<tr class="separator:aaf573a25c2ed53c80dff2edc3535e01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5e80b4f41e3c697012425984b58739"><td class="memItemLeft" align="right" valign="top"><a id="a0c5e80b4f41e3c697012425984b58739" name="a0c5e80b4f41e3c697012425984b58739"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scRemoveArticulationFixedTendon</b> (<a class="el" href="classphysx_1_1_np_articulation_fixed_tendon.html">NpArticulationFixedTendon</a> &amp;)</td></tr>
<tr class="separator:a0c5e80b4f41e3c697012425984b58739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930d41a05198d967626e89b3f66cf623"><td class="memItemLeft" align="right" valign="top"><a id="a930d41a05198d967626e89b3f66cf623" name="a930d41a05198d967626e89b3f66cf623"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scAddArticulationSensor</b> (<a class="el" href="classphysx_1_1_np_articulation_sensor.html">NpArticulationSensor</a> &amp;)</td></tr>
<tr class="separator:a930d41a05198d967626e89b3f66cf623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8b5086c06c1067d0f3d45e28f1f7b3"><td class="memItemLeft" align="right" valign="top"><a id="aed8b5086c06c1067d0f3d45e28f1f7b3" name="aed8b5086c06c1067d0f3d45e28f1f7b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scRemoveArticulationSensor</b> (<a class="el" href="classphysx_1_1_np_articulation_sensor.html">NpArticulationSensor</a> &amp;)</td></tr>
<tr class="separator:aed8b5086c06c1067d0f3d45e28f1f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec67f40152e3bfd1e794e2340c872a3"><td class="memItemLeft" align="right" valign="top"><a id="a9ec67f40152e3bfd1e794e2340c872a3" name="a9ec67f40152e3bfd1e794e2340c872a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>createInOmniPVD</b> (const <a class="el" href="classphysx_1_1_px_scene_desc.html">PxSceneDesc</a> &amp;desc)</td></tr>
<tr class="separator:a9ec67f40152e3bfd1e794e2340c872a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0318984909152c8c621f4a26e544b38"><td class="memItemLeft" align="right" valign="top"><a id="aa0318984909152c8c621f4a26e544b38" name="aa0318984909152c8c621f4a26e544b38"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>updatePvdProperties</b> ()</td></tr>
<tr class="separator:aa0318984909152c8c621f4a26e544b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebef3289e06e1d008102aa6f4f3a3c3"><td class="memItemLeft" align="right" valign="top"><a id="a2ebef3289e06e1d008102aa6f4f3a3c3" name="a2ebef3289e06e1d008102aa6f4f3a3c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateConstants</b> (const <a class="el" href="classphysx_1_1_px_array.html">PxArray</a>&lt; <a class="el" href="classphysx_1_1_np_constraint.html">NpConstraint</a> * &gt; &amp;constraints)</td></tr>
<tr class="separator:a2ebef3289e06e1d008102aa6f4f3a3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74c542fb650cdbf58fc63e861599121"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_pxg_dynamics_memory_config.html">PxgDynamicsMemoryConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_scene.html#ac74c542fb650cdbf58fc63e861599121">getGpuDynamicsConfig</a> () const</td></tr>
<tr class="separator:ac74c542fb650cdbf58fc63e861599121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3958f740ba4227601d4eb952e498efa0"><td class="memItemLeft" align="right" valign="top"><a id="a3958f740ba4227601d4eb952e498efa0" name="a3958f740ba4227601d4eb952e498efa0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3958f740ba4227601d4eb952e498efa0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>removeFromRigidActorList</b> (<a class="el" href="classphysx_1_1_np_rigid_dynamic.html">NpRigidDynamic</a> &amp;rigidDynamic)</td></tr>
<tr class="separator:a3958f740ba4227601d4eb952e498efa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945d315f4a13dd44528834a17ea280ce"><td class="memItemLeft" align="right" valign="top"><a id="a945d315f4a13dd44528834a17ea280ce" name="a945d315f4a13dd44528834a17ea280ce"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a945d315f4a13dd44528834a17ea280ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>removeFromRigidActorList</b> (<a class="el" href="classphysx_1_1_np_rigid_static.html">NpRigidStatic</a> &amp;rigidStatic)</td></tr>
<tr class="separator:a945d315f4a13dd44528834a17ea280ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3426b9d4a5c66c05e9209f4fbcf89f2"><td class="memItemLeft" align="right" valign="top"><a id="af3426b9d4a5c66c05e9209f4fbcf89f2" name="af3426b9d4a5c66c05e9209f4fbcf89f2"></a>
virtual <a class="el" href="classphysx_1_1_pxs_simulation_controller.html">PxsSimulationController</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSimulationController</b> ()=0</td></tr>
<tr class="separator:af3426b9d4a5c66c05e9209f4fbcf89f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b54af45acc1bc7e3f75fd7eef982be"><td class="memItemLeft" align="right" valign="top"><a id="ae8b54af45acc1bc7e3f75fd7eef982be" name="ae8b54af45acc1bc7e3f75fd7eef982be"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setActiveActors</b> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> **actors, PxU32 nbActors)=0</td></tr>
<tr class="separator:ae8b54af45acc1bc7e3f75fd7eef982be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbd9624a4e5f6e8bcb5c9b50add295c"><td class="memItemLeft" align="right" valign="top"><a id="acbbd9624a4e5f6e8bcb5c9b50add295c" name="acbbd9624a4e5f6e8bcb5c9b50add295c"></a>
virtual <a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>getFrozenActors</b> (PxU32 &amp;nbActorsOut)=0</td></tr>
<tr class="separator:acbbd9624a4e5f6e8bcb5c9b50add295c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e9572afc0bab160b7a4abcd954a414"><td class="memItemLeft" align="right" valign="top"><a id="a98e9572afc0bab160b7a4abcd954a414" name="a98e9572afc0bab160b7a4abcd954a414"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setFrozenActorFlag</b> (const bool buildFrozenActors)=0</td></tr>
<tr class="separator:a98e9572afc0bab160b7a4abcd954a414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68c05e309776c6ab32d78d05a6d462"><td class="memItemLeft" align="right" valign="top"><a id="a1a68c05e309776c6ab32d78d05a6d462" name="a1a68c05e309776c6ab32d78d05a6d462"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>forceSceneQueryRebuild</b> ()=0</td></tr>
<tr class="separator:a1a68c05e309776c6ab32d78d05a6d462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b138c68cfd73b4ac6424e1701315d9b"><td class="memItemLeft" align="right" valign="top"><a id="a1b138c68cfd73b4ac6424e1701315d9b" name="a1b138c68cfd73b4ac6424e1701315d9b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>frameEnd</b> ()=0</td></tr>
<tr class="separator:a1b138c68cfd73b4ac6424e1701315d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_scene"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_scene')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_scene.html">physx::PxScene</a></td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_scene_s_q_system"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_scene_s_q_system')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_scene_s_q_system.html">physx::PxSceneSQSystem</a></td></tr>
<tr class="memitem:a520753c97b118170545dc6ecab1fc9a9 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_scene_s_q_system.html#a520753c97b118170545dc6ecab1fc9a9">setSceneQueryUpdateMode</a> (<a class="el" href="structphysx_1_1_px_scene_query_update_mode.html#a3d0e848308f503deeb42f966e9fcb99f">PxSceneQueryUpdateMode::Enum</a> updateMode)</td></tr>
<tr class="memdesc:a520753c97b118170545dc6ecab1fc9a9 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets scene query update mode.  <br /></td></tr>
<tr class="separator:a520753c97b118170545dc6ecab1fc9a9 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e47acfb4d1518ad291920acf6e57268 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="structphysx_1_1_px_scene_query_update_mode.html#a3d0e848308f503deeb42f966e9fcb99f">PxSceneQueryUpdateMode::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_scene_s_q_system.html#a3e47acfb4d1518ad291920acf6e57268">getSceneQueryUpdateMode</a> () const</td></tr>
<tr class="memdesc:a3e47acfb4d1518ad291920acf6e57268 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets scene query update mode.  <br /></td></tr>
<tr class="separator:a3e47acfb4d1518ad291920acf6e57268 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc50caf9bfb60da35aebab6567f1d350 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_scene_s_q_system.html#afc50caf9bfb60da35aebab6567f1d350">getSceneQueryStaticTimestamp</a> () const</td></tr>
<tr class="memdesc:afc50caf9bfb60da35aebab6567f1d350 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the scene's internal scene query timestamp, increased each time a change to the static scene query structure is performed.  <br /></td></tr>
<tr class="separator:afc50caf9bfb60da35aebab6567f1d350 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae168d6f967bc600f6ea944fec135e7b0 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_scene_s_q_system.html#ae168d6f967bc600f6ea944fec135e7b0">flushQueryUpdates</a> ()</td></tr>
<tr class="memdesc:ae168d6f967bc600f6ea944fec135e7b0 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes any changes to the scene query representation.  <br /></td></tr>
<tr class="separator:ae168d6f967bc600f6ea944fec135e7b0 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b3e6bdf0a755baadd8f911ec3081e1 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_scene_s_q_system.html#a56b3e6bdf0a755baadd8f911ec3081e1">forceDynamicTreeRebuild</a> (bool rebuildStaticStructure, bool rebuildDynamicStructure)</td></tr>
<tr class="memdesc:a56b3e6bdf0a755baadd8f911ec3081e1 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces dynamic trees to be immediately rebuilt.  <br /></td></tr>
<tr class="separator:a56b3e6bdf0a755baadd8f911ec3081e1 inherit pub_methods_classphysx_1_1_px_scene_s_q_system"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scene Query</div></td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_user_allocated"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_user_allocated')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_user_allocated.html">physx::PxUserAllocated</a></td></tr>
<tr class="memitem:ac6a9a67e2851ca793aab3e5cd5d40dc9 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="ac6a9a67e2851ca793aab3e5cd5d40dc9" name="ac6a9a67e2851ca793aab3e5cd5d40dc9"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t, void *address)</td></tr>
<tr class="separator:ac6a9a67e2851ca793aab3e5cd5d40dc9 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046ea5070dbf9afdd2a7861e92e94d81 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="a046ea5070dbf9afdd2a7861e92e94d81" name="a046ea5070dbf9afdd2a7861e92e94d81"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *, void *)</td></tr>
<tr class="separator:a046ea5070dbf9afdd2a7861e92e94d81 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bae0296ddfbc31b60216e2ba92abd2 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="ae4bae0296ddfbc31b60216e2ba92abd2" name="ae4bae0296ddfbc31b60216e2ba92abd2"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:ae4bae0296ddfbc31b60216e2ba92abd2 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new</b> (size_t size, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:ae4bae0296ddfbc31b60216e2ba92abd2 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a10b191838ea8c32665b016efdc8f3 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="a63a10b191838ea8c32665b016efdc8f3" name="a63a10b191838ea8c32665b016efdc8f3"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a63a10b191838ea8c32665b016efdc8f3 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new</b> (size_t size, size_t, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:a63a10b191838ea8c32665b016efdc8f3 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5b943c992e48740700b211db97c551 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="aba5b943c992e48740700b211db97c551" name="aba5b943c992e48740700b211db97c551"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:aba5b943c992e48740700b211db97c551 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new[]</b> (size_t size, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:aba5b943c992e48740700b211db97c551 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290c0241798e99dd5aa3268ab4409e5d inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="a290c0241798e99dd5aa3268ab4409e5d" name="a290c0241798e99dd5aa3268ab4409e5d"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a290c0241798e99dd5aa3268ab4409e5d inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new[]</b> (size_t size, size_t, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:a290c0241798e99dd5aa3268ab4409e5d inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75170caed9ba30211dac6786a2bd6a0b inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="a75170caed9ba30211dac6786a2bd6a0b" name="a75170caed9ba30211dac6786a2bd6a0b"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a75170caed9ba30211dac6786a2bd6a0b inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator delete</b> (void *ptr, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:a75170caed9ba30211dac6786a2bd6a0b inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac388e14397c75698987292f6e366603e inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="ac388e14397c75698987292f6e366603e" name="ac388e14397c75698987292f6e366603e"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:ac388e14397c75698987292f6e366603e inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:ac388e14397c75698987292f6e366603e inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f3a3f96013ef224beb23fbdc73d758 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="a14f3a3f96013ef224beb23fbdc73d758" name="a14f3a3f96013ef224beb23fbdc73d758"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr)</td></tr>
<tr class="separator:a14f3a3f96013ef224beb23fbdc73d758 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec6f784dc7cbe8d3542f22e8c5ec3fa inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="a5ec6f784dc7cbe8d3542f22e8c5ec3fa" name="a5ec6f784dc7cbe8d3542f22e8c5ec3fa"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr)</td></tr>
<tr class="separator:a5ec6f784dc7cbe8d3542f22e8c5ec3fa inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a05314918fa4b151ecd57123296636b18"><td class="memItemLeft" align="right" valign="top"><a id="a05314918fa4b151ecd57123296636b18" name="a05314918fa4b151ecd57123296636b18"></a>
<a class="el" href="classphysx_1_1_cm_1_1_i_d_pool.html">Cm::IDPool</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mRigidActorIndexPool</b></td></tr>
<tr class="separator:a05314918fa4b151ecd57123296636b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classphysx_1_1_px_scene"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classphysx_1_1_px_scene')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classphysx_1_1_px_scene.html">physx::PxScene</a></td></tr>
<tr class="memitem:a5af3c7d813e3666f2574a3bf861c807d inherit pub_attribs_classphysx_1_1_px_scene"><td class="memItemLeft" align="right" valign="top"><a id="a5af3c7d813e3666f2574a3bf861c807d" name="a5af3c7d813e3666f2574a3bf861c807d"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>userData</b></td></tr>
<tr class="memdesc:a5af3c7d813e3666f2574a3bf861c807d inherit pub_attribs_classphysx_1_1_px_scene"><td class="mdescLeft">&#160;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object. <br /></td></tr>
<tr class="separator:a5af3c7d813e3666f2574a3bf861c807d inherit pub_attribs_classphysx_1_1_px_scene"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_scene"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_scene')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_scene.html">physx::PxScene</a></td></tr>
<tr class="memitem:a27506dc9665363f539508873763a569f inherit pro_methods_classphysx_1_1_px_scene"><td class="memItemLeft" align="right" valign="top"><a id="a27506dc9665363f539508873763a569f" name="a27506dc9665363f539508873763a569f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PxScene</b> ()</td></tr>
<tr class="separator:a27506dc9665363f539508873763a569f inherit pro_methods_classphysx_1_1_px_scene"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f4ee6e3fc0e4190f7e4d0ef6ad715f inherit pro_methods_classphysx_1_1_px_scene"><td class="memItemLeft" align="right" valign="top"><a id="ac3f4ee6e3fc0e4190f7e4d0ef6ad715f" name="ac3f4ee6e3fc0e4190f7e4d0ef6ad715f"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PxScene</b> ()</td></tr>
<tr class="separator:ac3f4ee6e3fc0e4190f7e4d0ef6ad715f inherit pro_methods_classphysx_1_1_px_scene"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5b4d92e311fd404ebaba740244e55a8e" name="a5b4d92e311fd404ebaba740244e55a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4d92e311fd404ebaba740244e55a8e">&#9670;&#160;</a></span>addActor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::addActor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_b_v_h.html">PxBVH</a> *&#160;</td>
          <td class="paramname"><em>bvh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an actor to this scene. </p>
<dl class="section note"><dt>Note</dt><dd>If the actor is already assigned to a scene (see <a class="el" href="classphysx_1_1_px_actor.html#a002cfb766d7d8aa71f174980fe7b1c6b" title="Retrieves the scene which this actor belongs to.">PxActor::getScene</a>), the call is ignored and an error is issued. </dd>
<dd>
If the actor has an invalid constraint, in checked builds the call is ignored and an error is issued.</dd>
<dd>
You can not add individual articulation links (see #PxArticulationLink) to the scene. Use <a class="el" href="classphysx_1_1_np_scene.html#a9f737006011f8f2b1dba7ff55b98c6cc" title="Adds an articulation to this scene.">addArticulation()</a> instead.</dd>
<dd>
If the actor is a <a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> then each assigned <a class="el" href="classphysx_1_1_px_constraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> object will get added to the scene automatically if it connects to another actor that is part of the scene already.</dd>
<dd>
When a BVH is provided the actor shapes are grouped together. The scene query pruning structure inside PhysX SDK will store/update one bound per actor. The scene queries against such an actor will query actor bounds and then make a local space query against the provided BVH, which is in actor's local space.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>Actor to add to scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bvh</td><td>BVH for actor shapes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a>, <a class="el" href="classphysx_1_1_px_constraint.html#a1519158a49c415e46194309cdd9ffe80" title="whether the constraint is valid.">PxConstraint::isValid()</a>, <a class="el" href="classphysx_1_1_px_b_v_h.html" title="Class representing a bounding volume hierarchy.">PxBVH</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a3c871471a47e8ebfc38883cba3e72443">physx::PxScene</a>.</p>

</div>
</div>
<a id="ab29044c15f87df0ce0915591243dde92" name="ab29044c15f87df0ce0915591243dde92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29044c15f87df0ce0915591243dde92">&#9670;&#160;</a></span>addActors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::addActors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_pruning_structure.html">PxPruningStructure</a> &amp;&#160;</td>
          <td class="paramname"><em>pruningStructure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a pruning structure together with its actors to this scene. Only supports actors of type <a class="el" href="classphysx_1_1_px_rigid_static.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK.">PxRigidStatic</a> and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This method only supports actors of type <a class="el" href="classphysx_1_1_px_rigid_static.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK.">PxRigidStatic</a> and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>. For other actors, use <a class="el" href="classphysx_1_1_np_scene.html#a5b4d92e311fd404ebaba740244e55a8e" title="Adds an actor to this scene.">addActor()</a> instead. For articulation links, use <a class="el" href="classphysx_1_1_np_scene.html#a9f737006011f8f2b1dba7ff55b98c6cc" title="Adds an articulation to this scene.">addArticulation()</a>.</dd>
<dd>
If an actor in the pruning structure contains an invalid constraint, in checked builds the call is ignored and an error is issued. </dd>
<dd>
For all actors in the pruning structure each assigned <a class="el" href="classphysx_1_1_px_constraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> object will get added to the scene automatically if it connects to another actor that is part of the scene already.</dd>
<dd>
This method is optimized for high performance.</dd>
<dd>
Merging a <a class="el" href="classphysx_1_1_px_pruning_structure.html" title="A precomputed pruning structure to accelerate scene queries against newly added actors.">PxPruningStructure</a> into an active scene query optimization AABB tree might unbalance the tree. A typical use case for <a class="el" href="classphysx_1_1_px_pruning_structure.html" title="A precomputed pruning structure to accelerate scene queries against newly added actors.">PxPruningStructure</a> is a large world scenario where blocks of closely positioned actors get streamed in. The merge process finds the best node in the active scene query optimization AABB tree and inserts the <a class="el" href="classphysx_1_1_px_pruning_structure.html" title="A precomputed pruning structure to accelerate scene queries against newly added actors.">PxPruningStructure</a>. Therefore using <a class="el" href="classphysx_1_1_px_pruning_structure.html" title="A precomputed pruning structure to accelerate scene queries against newly added actors.">PxPruningStructure</a> for actors scattered throughout the world will result in an unbalanced tree.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pruningStructure</td><td>Pruning structure for a set of actors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_physics.html#ab8fe4cefbe410f7eb031ab1fb687a507" title="Creates a pruning structure from actors.">PxPhysics::createPruningStructure</a>, <a class="el" href="classphysx_1_1_px_pruning_structure.html" title="A precomputed pruning structure to accelerate scene queries against newly added actors.">PxPruningStructure</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a4a68798543ebb1a0e5047d1bd0e2b92c">physx::PxScene</a>.</p>

</div>
</div>
<a id="aacf8118db7ad1428634d19a77d3fef25" name="aacf8118db7ad1428634d19a77d3fef25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf8118db7ad1428634d19a77d3fef25">&#9670;&#160;</a></span>addActors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::addActors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> *const *&#160;</td>
          <td class="paramname"><em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>nbActors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds actors to this scene. Only supports actors of type <a class="el" href="classphysx_1_1_px_rigid_static.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK.">PxRigidStatic</a> and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This method only supports actors of type <a class="el" href="classphysx_1_1_px_rigid_static.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK.">PxRigidStatic</a> and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>. For other actors, use <a class="el" href="classphysx_1_1_np_scene.html#a5b4d92e311fd404ebaba740244e55a8e" title="Adds an actor to this scene.">addActor()</a> instead. For articulation links, use <a class="el" href="classphysx_1_1_np_scene.html#a9f737006011f8f2b1dba7ff55b98c6cc" title="Adds an articulation to this scene.">addArticulation()</a>.</dd>
<dd>
If one of the actors is already assigned to a scene (see <a class="el" href="classphysx_1_1_px_actor.html#a002cfb766d7d8aa71f174980fe7b1c6b" title="Retrieves the scene which this actor belongs to.">PxActor::getScene</a>), the call is ignored and an error is issued.</dd>
<dd>
If an actor in the array contains an invalid constraint, in checked builds the call is ignored and an error is issued. </dd>
<dd>
If an actor in the array is a <a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> then each assigned <a class="el" href="classphysx_1_1_px_constraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> object will get added to the scene automatically if it connects to another actor that is part of the scene already.</dd>
<dd>
this method is optimized for high performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actors</td><td>Array of actors to add to scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbActors</td><td>Number of actors in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a>, <a class="el" href="classphysx_1_1_px_constraint.html#a1519158a49c415e46194309cdd9ffe80" title="whether the constraint is valid.">PxConstraint::isValid()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#abded5eb410086ee93a2e076f15f98ce6">physx::PxScene</a>.</p>

</div>
</div>
<a id="abb2bf7a910274994ba1e7a789269808f" name="abb2bf7a910274994ba1e7a789269808f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2bf7a910274994ba1e7a789269808f">&#9670;&#160;</a></span>addAggregate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::addAggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> &amp;&#160;</td>
          <td class="paramname"><em>aggregate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an aggregate to this scene. </p>
<dl class="section note"><dt>Note</dt><dd>If the aggregate is already assigned to a scene (see <a class="el" href="classphysx_1_1_px_aggregate.html#a4cb67c7f94b6b36778fe418cdfcc1c6c" title="Retrieves the scene which this aggregate belongs to.">PxAggregate::getScene</a>), the call is ignored and an error is issued. </dd>
<dd>
If the aggregate contains an actor with an invalid constraint, in checked builds the call is ignored and an error is issued.</dd>
<dd>
If the aggregate already contains actors, those actors are added to the scene as well.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aggregate</td><td>Aggregate to add to scene. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_aggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a>, <a class="el" href="classphysx_1_1_px_constraint.html#a1519158a49c415e46194309cdd9ffe80" title="whether the constraint is valid.">PxConstraint::isValid()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ae16963ca826ee71d46f21bbe682bc331">physx::PxScene</a>.</p>

</div>
</div>
<a id="a9f737006011f8f2b1dba7ff55b98c6cc" name="a9f737006011f8f2b1dba7ff55b98c6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f737006011f8f2b1dba7ff55b98c6cc">&#9670;&#160;</a></span>addArticulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::addArticulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> &amp;&#160;</td>
          <td class="paramname"><em>articulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an articulation to this scene. </p>
<dl class="section note"><dt>Note</dt><dd>If the articulation is already assigned to a scene (see <a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html#a2e9206aa9afa5b7d543816362e1067f4" title="Returns the scene which this articulation belongs to.">PxArticulationReducedCoordinate::getScene</a>), the call is ignored and an error is issued.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">articulation</td><td>The articulation to add to the scene. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html" title="A tree structure of bodies connected by joints that is treated as a unit by the dynamics solver....">PxArticulationReducedCoordinate</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aacaf4ac75ab81a08b2eef712bbc109ba">physx::PxScene</a>.</p>

</div>
</div>
<a id="ad5efb25bce20a8f80cc2b2fee9191e1d" name="ad5efb25bce20a8f80cc2b2fee9191e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5efb25bce20a8f80cc2b2fee9191e1d">&#9670;&#160;</a></span>addBroadPhaseRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::addBroadPhaseRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_broad_phase_region.html">PxBroadPhaseRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>populateRegion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new broad-phase region. </p>
<p>The bounds for the new region must be non-empty, otherwise an error occurs and the call is ignored.</p>
<p>Note that by default, objects already existing in the SDK that might touch this region will not be automatically added to the region. In other words the newly created region will be empty, and will only be populated with new objects when they are added to the simulation, or with already existing objects when they are updated.</p>
<p>It is nonetheless possible to override this default behavior and let the SDK populate the new region automatically with already existing objects overlapping the incoming region. This has a cost though, and it should only be used when the game can not guarantee that all objects within the new region will be added to the simulation after the region itself.</p>
<p>Objects automatically move from one region to another during their lifetime. The system keeps tracks of what regions a given object is in. It is legal for an object to be in an arbitrary number of regions. However if an object leaves all regions, or is created outside of all regions, several things happen:</p><ul>
<li>collisions get disabled for this object</li>
<li>if a <a class="el" href="classphysx_1_1_px_broad_phase_callback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> object is provided, an "out-of-bounds" event is generated via that callback</li>
<li>if a <a class="el" href="classphysx_1_1_px_broad_phase_callback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> object is not provided, a warning/error message is sent to the error stream</li>
</ul>
<p>If an object goes out-of-bounds and user deletes it during the same frame, neither the out-of-bounds event nor the error message is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">region</td><td>User-provided region data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">populateRegion</td><td>Automatically populate new region with already existing objects overlapping it </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle for newly created region, or 0xffffffff in case of failure. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_broad_phase_region.html" title="&quot;Region of interest&quot; for the broad-phase.">PxBroadPhaseRegion</a> <a class="el" href="classphysx_1_1_px_broad_phase_callback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ae315e6a672ac6b4980d876b40f390e47">physx::PxScene</a>.</p>

</div>
</div>
<a id="aefc9783086db1f704b0a5778ca4e4300" name="aefc9783086db1f704b0a5778ca4e4300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc9783086db1f704b0a5778ca4e4300">&#9670;&#160;</a></span>addCollection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::addCollection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_collection.html">PxCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds objects in the collection to this scene. </p>
<p>This function adds the following types of objects to this scene: <a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> (except <a class="el" href="classphysx_1_1_px_articulation_link.html" title="A component of an articulation that represents a rigid body.">PxArticulationLink</a>), <a class="el" href="classphysx_1_1_px_aggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a>, <a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html" title="A tree structure of bodies connected by joints that is treated as a unit by the dynamics solver....">PxArticulationReducedCoordinate</a>. This method is typically used after deserializing the collection in order to populate the scene with deserialized objects.</p>
<dl class="section note"><dt>Note</dt><dd>If the collection contains an actor with an invalid constraint, in checked builds the call is ignored and an error is issued.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">collection</td><td>Objects to add to this scene. See #PxCollection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_collection.html" title="Collection class for serialization.">PxCollection</a>, <a class="el" href="classphysx_1_1_px_constraint.html#a1519158a49c415e46194309cdd9ffe80" title="whether the constraint is valid.">PxConstraint::isValid()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#af5d941dd5432cf1d7b1b0d9f4edc0d06">physx::PxScene</a>.</p>

</div>
</div>
<a id="a1f2ce2ad1dd72a470c319d6cc7a3fc22" name="a1f2ce2ad1dd72a470c319d6cc7a3fc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2ce2ad1dd72a470c319d6cc7a3fc22">&#9670;&#160;</a></span>advance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_base_task.html">physx::PxBaseTask</a> *&#160;</td>
          <td class="paramname"><em>completionTask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs dynamics phase of the simulation pipeline. </p>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="classphysx_1_1_np_scene.html#a1f2ce2ad1dd72a470c319d6cc7a3fc22" title="Performs dynamics phase of the simulation pipeline.">advance()</a> should follow calls to <a class="el" href="classphysx_1_1_np_scene.html#a7df162bc45ede72a477a0380bdf4a40f">fetchCollision()</a>. An error message will be issued if this sequence is not followed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">completionTask</td><td>if non-NULL, this task will have its refcount incremented in <a class="el" href="classphysx_1_1_np_scene.html#a1f2ce2ad1dd72a470c319d6cc7a3fc22" title="Performs dynamics phase of the simulation pipeline.">advance()</a>, then decremented when the scene is ready to have fetchResults called. So the task will not run until the application also calls removeReference(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a76a2ce1440f1911d418d42dd4321e38a">physx::PxScene</a>.</p>

</div>
</div>
<a id="a4a4413fd6822b11933047b7d7a15acda" name="a4a4413fd6822b11933047b7d7a15acda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4413fd6822b11933047b7d7a15acda">&#9670;&#160;</a></span>applyActorData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::applyActorData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_gpu_actor_pair.html">PxGpuActorPair</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxActorCacheFlag::Enum&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU32&#160;</td>
          <td class="paramname"><em>nbUpdatedActors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>waitEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>signalEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply user-provided data to rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User-provided gpu data buffer which should be sized appropriately for the particular data that is requested. Further details provided in the user guide. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>User provided <a class="el" href="structphysx_1_1_px_gpu_actor_pair.html" title="Pair correspondence used for matching array indices with body node indices.">PxGpuActorPair</a> buffer. This buffer stores pairs of indices: the <a class="el" href="classphysx_1_1_px_node_index.html" title="PxNodeIndex.">PxNodeIndex</a> corresponding to the rigid body and an index corresponding to the location in the user buffer that this value should be placed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Flag defining which data the user wants to write to the rigid body </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbUpdatedActors</td><td>The number of updated rigid body </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitEvent</td><td>User-provided event for the rigid body stream to wait for data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalEvent</td><td>User-provided event for the rigid body stream to signal when the read from the user buffer has completed </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a26d90411249aac9084a14ea8a45436c7">physx::PxScene</a>.</p>

</div>
</div>
<a id="a37d6b03517ead7a491a605ebe5a58e03" name="a37d6b03517ead7a491a605ebe5a58e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d6b03517ead7a491a605ebe5a58e03">&#9670;&#160;</a></span>applyArticulationData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::applyArticulationData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_articulation_gpu_data_type.html#aaee7a9365f0795810cf259e1bbf57aa9">PxArticulationGpuDataType::Enum</a>&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU32&#160;</td>
          <td class="paramname"><em>nbUpdatedArticulations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>waitEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>signalEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply GPU articulation data from a user-provided device buffer to the internal GPU buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User-provided gpu data buffer which should be sized appropriately for the particular data that is requested. Further details provided in the user guide. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>User-provided gpu index buffer. This buffer stores the articulation indices which the user wants to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataType</td><td>Enum specifying the type of data the user wants to write to the articulations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbUpdatedArticulations</td><td>Number of articulations that data should be written to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitEvent</td><td>User-provided event for the articulation stream to wait for data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalEvent</td><td>User-provided event for the articulation stream to signal when the data read from the user buffer has completed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#af2561d02f919155cbe6e6eb67b38c22c">physx::PxScene</a>.</p>

</div>
</div>
<a id="abd51494a980d157ebf940565135b99a3" name="abd51494a980d157ebf940565135b99a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd51494a980d157ebf940565135b99a3">&#9670;&#160;</a></span>applyParticleBufferData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::applyParticleBufferData </td>
          <td>(</td>
          <td class="paramtype">const PxU32 *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_gpu_particle_buffer_index_pair.html">PxGpuParticleBufferIndexPair</a> *&#160;</td>
          <td class="paramname"><em>bufferIndexPair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_flags.html">PxParticleBufferFlags</a> *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>nbUpdatedBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>waitEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>signalEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply user-provided data to particle buffers. </p>
<p>This function should be used if the particle buffer flags are already on the device. Otherwise, use <a class="el" href="classphysx_1_1_px_particle_buffer.html#a2b0994c4a64051c48cb72ae1383ae56e" title="Raise dirty flags on this particle buffer to communicate that the corresponding data has been updated...">PxParticleBuffer::raiseFlags()</a> from the CPU.</p>
<p>This assumes the data has been changed directly in the <a class="el" href="classphysx_1_1_px_particle_buffer.html" title="The shared base class for all particle buffers, can be instantiated directly to simulate granular and...">PxParticleBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>User-provided index buffer that indexes into the BufferIndexPair and flags list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferIndexPair</td><td>User-provided index pair buffer specifying the unique id and GPU particle system for each <a class="el" href="classphysx_1_1_px_particle_buffer.html" title="The shared base class for all particle buffers, can be instantiated directly to simulate granular and...">PxParticleBuffer</a>. See <a class="el" href="structphysx_1_1_px_gpu_particle_buffer_index_pair.html" title="A pair of particle buffer unique id and GPU particle system index.">PxGpuParticleBufferIndexPair</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags to mark what data needs to be updated. See PxParticleBufferFlags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbUpdatedBuffers</td><td>The number of particle buffers to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">waitEvent</td><td>User-provided event for the particle stream to wait for data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signalEvent</td><td>User-provided event for the particle stream to signal when the data read from the user buffer has completed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#acea709a38d583212b71fbb1a98d41c68">physx::PxScene</a>.</p>

</div>
</div>
<a id="a3e8f6366f6d94623b96c0b319b17e947" name="a3e8f6366f6d94623b96c0b319b17e947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8f6366f6d94623b96c0b319b17e947">&#9670;&#160;</a></span>applySoftBodyData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::applySoftBodyData </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>softBodyIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body_data_flag.html#ab195f2b67a93c45e6edd6c65e5603d12">PxSoftBodyDataFlag::Enum</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU32&#160;</td>
          <td class="paramname"><em>nbUpdatedSoftBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU32&#160;</td>
          <td class="paramname"><em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>applyEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply user-provided data to the internal softbody system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User-provided gpu buffer containing a pointer to another gpu buffer for every softbody to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSizes</td><td>The size of every buffer in bytes <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softBodyIndices</td><td>User provided gpu index buffer. This buffer stores the updated softbody index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Flag defining which data the user wants to write to the softbody system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSize</td><td>The largest size stored in dataSizes. Used internally to decide how many threads to launch for the copy process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbUpdatedSoftBodies</td><td>The number of updated softbodies </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">applyEvent</td><td>User-provided event for the softbody stream to wait for data </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a6a3b4c1c90d28a388544595f303b624f">physx::PxScene</a>.</p>

</div>
</div>
<a id="a6f8b0913ef05f2f973a55e67f2548509" name="a6f8b0913ef05f2f973a55e67f2548509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f8b0913ef05f2f973a55e67f2548509">&#9670;&#160;</a></span>checkQueries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::checkQueries </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This checks to see if the scene queries update has completed. </p>
<p>This does not cause the data available for reading to be updated with the results of the scene queries update, it is simply a status check. The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>When set to true will block until the condition is met. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the results are available.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#a2af0a1f6951c3ff59a21c0689405f450" title="Executes scene queries update tasks.">sceneQueriesUpdate()</a> <a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_s_q_system.html#a4ba9aa92fbb9aa29beeba8432a5d5364">physx::PxSceneSQSystem</a>.</p>

</div>
</div>
<a id="ac393a255bb6fcad89ae8452f5682abd3" name="ac393a255bb6fcad89ae8452f5682abd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac393a255bb6fcad89ae8452f5682abd3">&#9670;&#160;</a></span>checkResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::checkResults </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This checks to see if the simulation run has completed. </p>
<p>This does not cause the data available for reading to be updated with the results of the simulation, it is simply a status check. The bool will allow it to either return immediately or block waiting for the condition to be met so that it can return true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>When set to true will block until the condition is met. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the results are available.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a> <a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a00815a1a64deefe5ddee8ac955a7a327">physx::PxScene</a>.</p>

</div>
</div>
<a id="a01baed715f874e77ba9e1c020346ee89" name="a01baed715f874e77ba9e1c020346ee89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01baed715f874e77ba9e1c020346ee89">&#9670;&#160;</a></span>collide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::collide </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>elapsedTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_base_task.html">physx::PxBaseTask</a> *&#160;</td>
          <td class="paramname"><em>completionTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scratchMemBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>scratchMemBlockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>controlSimulation</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs collision detection for the scene over elapsedTime. </p>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="classphysx_1_1_np_scene.html#a01baed715f874e77ba9e1c020346ee89" title="Performs collision detection for the scene over elapsedTime.">collide()</a> should be the first method called to simulate a frame.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elapsedTime</td><td>Amount of time to advance simulation by. The parameter has to be larger than 0, else the resulting behavior will be undefined. <b>Range:</b> (0, PX_MAX_F32) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">completionTask</td><td>if non-NULL, this task will have its refcount incremented in <a class="el" href="classphysx_1_1_np_scene.html#a01baed715f874e77ba9e1c020346ee89" title="Performs collision detection for the scene over elapsedTime.">collide()</a>, then decremented when the scene is ready to have fetchResults called. So the task will not run until the application also calls removeReference(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scratchMemBlock</td><td>a memory region for physx to use for temporary data during simulation. This block may be reused by the application after fetchResults returns. Must be aligned on a 16-byte boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scratchMemBlockSize</td><td>the size of the scratch memory block. Must be a multiple of 16K. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controlSimulation</td><td>if true, the scene controls its <a class="el" href="classphysx_1_1_px_task_manager.html" title="The PxTaskManager interface.">PxTaskManager</a> simulation state. Leave true unless the application is calling the <a class="el" href="classphysx_1_1_px_task_manager.html" title="The PxTaskManager interface.">PxTaskManager</a> start/stopSimulation() methods itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a9c63e5a0e592a434b8647c98e569aed4">physx::PxScene</a>.</p>

</div>
</div>
<a id="abd7162c3675190cd5c0d11d3ef62fe92" name="abd7162c3675190cd5c0d11d3ef62fe92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7162c3675190cd5c0d11d3ef62fe92">&#9670;&#160;</a></span>computeCoriolisAndCentrifugalForces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::computeCoriolisAndCentrifugalForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_index_data_pair.html">PxIndexDataPair</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>nbIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>computeEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the joint DOF forces required to counteract coriolis and centrifugal forces for the given articulation pose. </p>
<p>The size of the result can vary by articulation, since it depends on the number of links and degrees-of-freedom.</p>
<p>The size is determined using this formula: sizeof(float) * dofCount</p>
<p>The user must ensure that adequate space is provided for each articulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>User-provided gpu buffer of (index, data) pairs. The entries map a GPU articulation index to a GPU block of memory where the returned matrix will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbIndices</td><td>The number of (index, data) pairs provided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">computeEvent</td><td>User-provided event for the user to sync data. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aa8c45304fff4117b5e9909a1d336d832">physx::PxScene</a>.</p>

</div>
</div>
<a id="afb23a770a42516f3a3affd29efaca137" name="afb23a770a42516f3a3affd29efaca137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb23a770a42516f3a3affd29efaca137">&#9670;&#160;</a></span>computeDenseJacobians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::computeDenseJacobians </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_index_data_pair.html">PxIndexDataPair</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>nbIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>computeEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute dense Jacobian matrices for specified articulations on the GPU. </p>
<p>The size of Jacobians can vary by articulation, since it depends on the number of links, degrees-of-freedom, and whether the base is fixed.</p>
<p>The size is determined using these formulas: nCols = (fixedBase ? 0 : 6) + dofCount nRows = (fixedBase ? 0 : 6) + (linkCount - 1) * 6;</p>
<p>The user must ensure that adequate space is provided for each Jacobian matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>User-provided gpu buffer of (index, data) pairs. The entries map a GPU articulation index to a GPU block of memory where the returned Jacobian will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbIndices</td><td>The number of (index, data) pairs provided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">computeEvent</td><td>User-provided event for the user to sync data. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#acece3275a859deae54284eb6b1035c88">physx::PxScene</a>.</p>

</div>
</div>
<a id="a5eae02ca6642d17f802f7b59d6ba2c5d" name="a5eae02ca6642d17f802f7b59d6ba2c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eae02ca6642d17f802f7b59d6ba2c5d">&#9670;&#160;</a></span>computeGeneralizedGravityForces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::computeGeneralizedGravityForces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_index_data_pair.html">PxIndexDataPair</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>nbIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>computeEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the joint DOF forces required to counteract gravitational forces for the given articulation pose. </p>
<p>The size of the result can vary by articulation, since it depends on the number of links and degrees-of-freedom.</p>
<p>The size is determined using this formula: sizeof(float) * dofCount</p>
<p>The user must ensure that adequate space is provided for each articulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>User-provided gpu buffer of (index, data) pairs. The entries map a GPU articulation index to a GPU block of memory where the returned matrix will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbIndices</td><td>The number of (index, data) pairs provided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">computeEvent</td><td>User-provided event for the user to sync data. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a41841d6fa47ae1af996a2bf7e1060d54">physx::PxScene</a>.</p>

</div>
</div>
<a id="a5c012dbc95ac4ed53e58b1c11df58546" name="a5c012dbc95ac4ed53e58b1c11df58546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c012dbc95ac4ed53e58b1c11df58546">&#9670;&#160;</a></span>computeGeneralizedMassMatrices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::computeGeneralizedMassMatrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_index_data_pair.html">PxIndexDataPair</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>nbIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>computeEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the joint-space inertia matrices that maps joint accelerations to joint forces: forces = M * accelerations on the GPU. </p>
<p>The size of matrices can vary by articulation, since it depends on the number of links and degrees-of-freedom.</p>
<p>The size is determined using this formula: sizeof(float) * dofCount * dofCount</p>
<p>The user must ensure that adequate space is provided for each mass matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>User-provided gpu buffer of (index, data) pairs. The entries map a GPU articulation index to a GPU block of memory where the returned matrix will be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbIndices</td><td>The number of (index, data) pairs provided. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">computeEvent</td><td>User-provided event for the user to sync data. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a40fc541a943b1e614b46072759ba86d1">physx::PxScene</a>.</p>

</div>
</div>
<a id="ad42adaf083250b91424e7de7e036c123" name="ad42adaf083250b91424e7de7e036c123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42adaf083250b91424e7de7e036c123">&#9670;&#160;</a></span>copyArticulationData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::copyArticulationData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_articulation_gpu_data_type.html#aaee7a9365f0795810cf259e1bbf57aa9">PxArticulationGpuDataType::Enum</a>&#160;</td>
          <td class="paramname"><em>dataType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU32&#160;</td>
          <td class="paramname"><em>nbCopyArticulations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>copyEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy GPU articulation data from the internal GPU buffer to a user-provided device buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User-provided gpu data buffer which should be sized appropriately for the particular data that is requested. Further details provided in the user guide. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>User-provided gpu index buffer. This buffer stores the articulation indices which the user wants to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataType</td><td>Enum specifying the type of data the user wants to read back from the articulations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbCopyArticulations</td><td>Number of articulations that data should be copied from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copyEvent</td><td>User-provided event for the articulation stream to signal when the data copy to the user buffer has completed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a65e56835aace090a67a772f78d753e13">physx::PxScene</a>.</p>

</div>
</div>
<a id="ae0afa17c61e8b79c19cc95c7c1b094da" name="ae0afa17c61e8b79c19cc95c7c1b094da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0afa17c61e8b79c19cc95c7c1b094da">&#9670;&#160;</a></span>copyBodyData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::copyBodyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_gpu_body_data.html">PxGpuBodyData</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_gpu_actor_pair.html">PxGpuActorPair</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU32&#160;</td>
          <td class="paramname"><em>nbCopyActors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>copyEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy GPU rigid body data from the internal GPU buffer to a user-provided device buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User-provided gpu data buffer which should nbCopyActors * sizeof(PxGpuBodyData). The only data it can copy is <a class="el" href="structphysx_1_1_px_gpu_body_data.html" title="State of a body used when interfacing with the GPU rigid body pipeline.">PxGpuBodyData</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>User provided node <a class="el" href="structphysx_1_1_px_gpu_actor_pair.html" title="Pair correspondence used for matching array indices with body node indices.">PxGpuActorPair</a> buffer. This buffer stores pairs of indices: the <a class="el" href="classphysx_1_1_px_node_index.html" title="PxNodeIndex.">PxNodeIndex</a> corresponding to the rigid body and an index corresponding to the location in the user buffer that this value should be placed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbCopyActors</td><td>The number of rigid body to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copyEvent</td><td>User-provided event for the user to sync data. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a1ef568eaab1af1ae484a04bfa0814f4e">physx::PxScene</a>.</p>

</div>
</div>
<a id="ae94412b28f4f3f0c5b8357951b09e17f" name="ae94412b28f4f3f0c5b8357951b09e17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94412b28f4f3f0c5b8357951b09e17f">&#9670;&#160;</a></span>copyContactData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::copyContactData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU32&#160;</td>
          <td class="paramname"><em>maxContactPairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>numContactPairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>copyEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy contact data from the internal GPU buffer to a user-provided device buffer. </p>
<dl class="section note"><dt>Note</dt><dd>The contact data contains pointers to internal state and is only valid until the next call to <a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User-provided gpu data buffer, which should be the size of <a class="el" href="structphysx_1_1_px_gpu_contact_pair.html" title="Contains contact information for a contact reported by the direct-GPU contact report API....">PxGpuContactPair</a> * numContactPairs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxContactPairs</td><td>The maximum number of pairs that the buffer can contain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numContactPairs</td><td>The actual number of contact pairs that were written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copyEvent</td><td>User-provided event for the user to sync data </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#afa66fe716d4af1c6e1acfbed96a7439b">physx::PxScene</a>.</p>

</div>
</div>
<a id="a18ae2cce2628b4ec64b448a23c94f5ae" name="a18ae2cce2628b4ec64b448a23c94f5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ae2cce2628b4ec64b448a23c94f5ae">&#9670;&#160;</a></span>copySoftBodyData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::copySoftBodyData </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dataSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>softBodyIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body_data_flag.html#ab195f2b67a93c45e6edd6c65e5603d12">PxSoftBodyDataFlag::Enum</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU32&#160;</td>
          <td class="paramname"><em>nbCopySoftBodies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxU32&#160;</td>
          <td class="paramname"><em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>copyEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy GPU softbody data from the internal GPU buffer to a user-provided device buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>User-provided gpu buffer containing a pointer to another gpu buffer for every softbody to process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSizes</td><td>The size of every buffer in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softBodyIndices</td><td>User provided gpu index buffer. This buffer stores the softbody index which the user want to copy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSize</td><td>The largest size stored in dataSizes. Used internally to decide how many threads to launch for the copy process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Flag defining which data the user wants to read back from the softbody system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbCopySoftBodies</td><td>The number of softbodies to be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copyEvent</td><td>User-provided event for the user to sync data </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a1f5fa1d1c53b25ac3a25aa4bb8ba62fc">physx::PxScene</a>.</p>

</div>
</div>
<a id="a83681b49b69acfb10decdc486b3a4a95" name="a83681b49b69acfb10decdc486b3a4a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83681b49b69acfb10decdc486b3a4a95">&#9670;&#160;</a></span>createClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a> NpScene::createClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves a new client ID. </p>
<p>PX_DEFAULT_CLIENT is always available as the default clientID. Additional clients are returned by this function. Clients cannot be released once created. An error is reported when more than a supported number of clients (currently 128) are created.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7" title="An ID to identify different clients for multiclient support.">PxClientID</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ae75ca5f161f84b23b451ab731cc66452">physx::PxScene</a>.</p>

</div>
</div>
<a id="a7df162bc45ede72a477a0380bdf4a40f" name="a7df162bc45ede72a477a0380bdf4a40f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df162bc45ede72a477a0380bdf4a40f">&#9670;&#160;</a></span>fetchCollision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::fetchCollision </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method must be called after <a class="el" href="classphysx_1_1_np_scene.html#a01baed715f874e77ba9e1c020346ee89" title="Performs collision detection for the scene over elapsedTime.">collide()</a> and before <a class="el" href="classphysx_1_1_np_scene.html#a1f2ce2ad1dd72a470c319d6cc7a3fc22" title="Performs dynamics phase of the simulation pipeline.">advance()</a>. It will wait for the collision phase to finish. If the user makes an illegal simulation call, the SDK will issue an error message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>When set to true will block until the condition is met, which is collision must finish running. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a51880f72e10cc177af59aaf4e61e412f">physx::PxScene</a>.</p>

</div>
</div>
<a id="ae2120338a94c1753af89e2a06a31ddb7" name="ae2120338a94c1753af89e2a06a31ddb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2120338a94c1753af89e2a06a31ddb7">&#9670;&#160;</a></span>fetchQueries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::fetchQueries </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method must be called after sceneQueriesUpdate. It will wait for the scene queries update to finish. If the user makes an illegal scene queries update call, the SDK will issue an error message.</p>
<p>If a new AABB tree build finished, then during fetchQueries the current tree within the pruning structure is swapped with the new tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>When set to true will block until the condition is met, which is tree built task must finish running. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_s_q_system.html#ab9988bca9a0285d591a8a2b2423531f8">physx::PxSceneSQSystem</a>.</p>

</div>
</div>
<a id="a459128504c8dff8c4d6af42d1028208d" name="a459128504c8dff8c4d6af42d1028208d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459128504c8dff8c4d6af42d1028208d">&#9670;&#160;</a></span>fetchResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::fetchResults </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 *&#160;</td>
          <td class="paramname"><em>errorState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the big brother to <a class="el" href="classphysx_1_1_np_scene.html#ac393a255bb6fcad89ae8452f5682abd3" title="This checks to see if the simulation run has completed.">checkResults()</a> it basically does the following:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> ( <a class="code hl_function" href="classphysx_1_1_np_scene.html#ac393a255bb6fcad89ae8452f5682abd3">checkResults</a>(block) )</div>
<div class="line">{</div>
<div class="line">    fire appropriate callbacks</div>
<div class="line">    swap buffers</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span></div>
<div class="ttc" id="aclassphysx_1_1_np_scene_html_ac393a255bb6fcad89ae8452f5682abd3"><div class="ttname"><a href="classphysx_1_1_np_scene.html#ac393a255bb6fcad89ae8452f5682abd3">physx::NpScene::checkResults</a></div><div class="ttdeci">virtual bool checkResults(bool block)</div><div class="ttdoc">This checks to see if the simulation run has completed.</div><div class="ttdef"><b>Definition:</b> NpSceneFetchResults.cpp:84</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>When set to true will block until results are available. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">errorState</td><td>Used to retrieve hardware error codes. A non zero value indicates an error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the results have been fetched.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a> <a class="el" href="classphysx_1_1_np_scene.html#ac393a255bb6fcad89ae8452f5682abd3" title="This checks to see if the simulation run has completed.">checkResults()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a0933fe0846ed7ee44b36accddcd16e94">physx::PxScene</a>.</p>

</div>
</div>
<a id="a6e22152e9e62b5e3429640acb5dd939f" name="a6e22152e9e62b5e3429640acb5dd939f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e22152e9e62b5e3429640acb5dd939f">&#9670;&#160;</a></span>fetchResultsFinish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::fetchResultsFinish </td>
          <td>(</td>
          <td class="paramtype">PxU32 *&#160;</td>
          <td class="paramname"><em>errorState</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This call performs the second section of fetchResults.</p>
<p>It must be called after <a class="el" href="classphysx_1_1_np_scene.html#aee2213e7c29eb03a0ee9ec237fb0bfb7">fetchResultsStart()</a> returns and contact reports have been processed.</p>
<p>Note that once <a class="el" href="classphysx_1_1_np_scene.html#a6e22152e9e62b5e3429640acb5dd939f">fetchResultsFinish()</a> has been called, the contact streams returned in <a class="el" href="classphysx_1_1_np_scene.html#aee2213e7c29eb03a0ee9ec237fb0bfb7">fetchResultsStart()</a> will be invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">errorState</td><td>Used to retrieve hardware error codes. A non zero value indicates an error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a> <a class="el" href="classphysx_1_1_np_scene.html#ac393a255bb6fcad89ae8452f5682abd3" title="This checks to see if the simulation run has completed.">checkResults()</a> <a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a> <a class="el" href="classphysx_1_1_np_scene.html#aee2213e7c29eb03a0ee9ec237fb0bfb7">fetchResultsStart()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a0ae7010057a111b0e06bbeefd58d3dfd">physx::PxScene</a>.</p>

</div>
</div>
<a id="aee2213e7c29eb03a0ee9ec237fb0bfb7" name="aee2213e7c29eb03a0ee9ec237fb0bfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2213e7c29eb03a0ee9ec237fb0bfb7">&#9670;&#160;</a></span>fetchResultsStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::fetchResultsStart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_contact_pair_header.html">PxContactPairHeader</a> *&amp;&#160;</td>
          <td class="paramname"><em>contactPairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>nbContactPairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This call performs the first section of fetchResults, and returns a pointer to the contact streams output by the simulation. It can be used to process contact pairs in parallel, which is often a limiting factor for <a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a> performance.</p>
<p>After calling this function and processing the contact streams, call <a class="el" href="classphysx_1_1_np_scene.html#a6e22152e9e62b5e3429640acb5dd939f">fetchResultsFinish()</a>. Note that writes to the simulation are not permitted between the start of <a class="el" href="classphysx_1_1_np_scene.html#aee2213e7c29eb03a0ee9ec237fb0bfb7">fetchResultsStart()</a> and the end of <a class="el" href="classphysx_1_1_np_scene.html#a6e22152e9e62b5e3429640acb5dd939f">fetchResultsFinish()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>When set to true will block until results are available. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">contactPairs</td><td>an array of pointers to contact pair headers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nbContactPairs</td><td>the number of contact pairs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the results have been fetched.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a> <a class="el" href="classphysx_1_1_np_scene.html#ac393a255bb6fcad89ae8452f5682abd3" title="This checks to see if the simulation run has completed.">checkResults()</a> <a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a> <a class="el" href="classphysx_1_1_np_scene.html#a6e22152e9e62b5e3429640acb5dd939f">fetchResultsFinish()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aa9a758dd45293d33273ecc9d9994cb89">physx::PxScene</a>.</p>

</div>
</div>
<a id="aad60c8aaea2ce9544fb3d987dc7e9986" name="aad60c8aaea2ce9544fb3d987dc7e9986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad60c8aaea2ce9544fb3d987dc7e9986">&#9670;&#160;</a></span>flushSimulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::flushSimulation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sendPendingReports</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear internal buffers and free memory. </p>
<p>This method can be used to clear buffers and free internal memory without having to destroy the scene. Can be useful if the physics data gets streamed in and a checkpoint with a clean state should be created.</p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to call this method while the simulation is running. The call will fail.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sendPendingReports</td><td>When set to true pending reports will be sent out before the buffers get cleaned up (for instance lost touch contact/trigger reports due to deleted objects). </td></tr>
  </table>
  </dd>
</dl>
<p>!! TODO: Shrink all NpObject lists?</p>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a8f4860c4aec012d77af67f3234b2815f">physx::PxScene</a>.</p>

</div>
</div>
<a id="aca66ea5a07bdff190345b6b15e4c5322" name="aca66ea5a07bdff190345b6b15e4c5322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca66ea5a07bdff190345b6b15e4c5322">&#9670;&#160;</a></span>flushUpdates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::flushUpdates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flushes any changes to the scene query representation. </p>
<p>This method updates the state of the scene query representation to match changes in the scene state.</p>
<p>By default, these changes are buffered until the next query is submitted. Calling this function will not change the results from scene queries, but can be used to ensure that a query will not perform update work in the course of its execution.</p>
<p>A thread performing updates will hold a write lock on the query structure, and thus stall other querying threads. In multithread scenarios it can be useful to explicitly schedule the period where this lock may be held for a significant period, so that subsequent queries issued from multiple threads will not block. </p>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_query_system_base.html#ad61d17a6a620b2725a4b5693fb974fa0">physx::PxSceneQuerySystemBase</a>.</p>

</div>
</div>
<a id="af43306bf149c77bffadc54bfbb99c17e" name="af43306bf149c77bffadc54bfbb99c17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43306bf149c77bffadc54bfbb99c17e">&#9670;&#160;</a></span>forceRebuildDynamicTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::forceRebuildDynamicTree </td>
          <td>(</td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>prunerIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces dynamic trees to be immediately rebuilt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prunerIndex</td><td>Index of pruner containing the dynamic tree to rebuild</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classphysx_1_1_px_scene.html" title="A scene is a collection of bodies and constraints which can interact.">PxScene</a> will call this function with the PX_SCENE_PRUNER_STATIC or PX_SCENE_PRUNER_DYNAMIC value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_query_desc.html#aa9b4f3adb72c59a63e19c09e0c110ab6" title="Hint for how much work should be done per simulation frame to rebuild the pruning structures.">PxSceneQueryDesc.dynamicTreeRebuildRateHint</a> <a class="el" href="classphysx_1_1_np_scene.html#abbac7601df289d7b6f2d04a9caa1b059" title="Sets the rebuild rate of the dynamic tree pruning structures.">setDynamicTreeRebuildRateHint()</a> <a class="el" href="classphysx_1_1_np_scene.html#a4895ebc7606b70bff52c29bca6bfaacc" title="Retrieves the rebuild rate of the dynamic tree pruning structures.">getDynamicTreeRebuildRateHint()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_query_system_base.html#a65e62b9efb89422155884b759f7c9999">physx::PxSceneQuerySystemBase</a>.</p>

</div>
</div>
<a id="abd685287fdff3efd65c164491aaa4dba" name="abd685287fdff3efd65c164491aaa4dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd685287fdff3efd65c164491aaa4dba">&#9670;&#160;</a></span>forceSceneQueryRebuild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::forceSceneQueryRebuild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classphysx_1_1_np_scene_accessor.html">physx::NpSceneAccessor</a>.</p>

</div>
</div>
<a id="a38b9c00978b3c130034c42d853444906" name="a38b9c00978b3c130034c42d853444906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b9c00978b3c130034c42d853444906">&#9670;&#160;</a></span>frameEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::frameEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classphysx_1_1_np_scene_accessor.html">physx::NpSceneAccessor</a>.</p>

</div>
</div>
<a id="a93b7b941085e406907bb85e993fcaa11" name="a93b7b941085e406907bb85e993fcaa11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b7b941085e406907bb85e993fcaa11">&#9670;&#160;</a></span>getActiveActors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> ** NpScene::getActiveActors </td>
          <td>(</td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>nbActorsOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the <a class="el" href="classphysx_1_1_px_scene.html" title="A scene is a collection of bodies and constraints which can interact.">PxScene</a> for a list of the PxActors whose transforms have been updated during the previous simulation step. Only includes actors of type <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> and <a class="el" href="classphysx_1_1_px_articulation_link.html" title="A component of an articulation that represents a rigid body.">PxArticulationLink</a>. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structphysx_1_1_px_scene_flag.html#a1a7984bb50590b1a2ce5ca5fe6469e50a179e56177ae026574bbd35d49c9d7f8c" title="Enable Active Actors Notification.">PxSceneFlag::eENABLE_ACTIVE_ACTORS</a> must be set.</dd>
<dd>
Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored and NULL will be returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">nbActorsOut</td><td>The number of actors returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the list of active PxActors generated during the last call to <a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ab74dd3a6fb860f84418bac13605b669a">physx::PxScene</a>.</p>

</div>
</div>
<a id="af3d78ebac2b9075c068456acec30bdbf" name="af3d78ebac2b9075c068456acec30bdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d78ebac2b9075c068456acec30bdbf">&#9670;&#160;</a></span>getActors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getActors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#abb179bd82b9dca8e4c30ae19447fa5a7">PxActorTypeFlags</a>&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> **&#160;</td>
          <td class="paramname"><em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve an array of all the actors of certain types in the scene. For supported types, see PxActorTypeFlags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">types</td><td>Combination of actor types to retrieve. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">userBuffer</td><td>The buffer to receive actor pointers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of provided user buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Index of first actor pointer to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of actors written to the buffer.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#ad77b3c021b3c6f7125fee3b351555206" title="Retrieve the number of actors of certain types in the scene. For supported types, see PxActorTypeFlag...">getNbActors()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aaa10d487fd3ce56dd773b9dea011f75a">physx::PxScene</a>.</p>

</div>
</div>
<a id="a4a843d6652a7cd7e956775f926a6e2cb" name="a4a843d6652a7cd7e956775f926a6e2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a843d6652a7cd7e956775f926a6e2cb">&#9670;&#160;</a></span>getAggregates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getAggregates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> **&#160;</td>
          <td class="paramname"><em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve all the aggregates in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">userBuffer</td><td>The buffer to receive aggregates pointers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of provided user buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Index of first aggregate pointer to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of aggregates written to the buffer.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#a91fb85e7ae86fa4945d15ce1059a2b43" title="Returns the number of aggregates in the scene.">getNbAggregates()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a265d99e832aa65d750ece7f6eb3fbf70">physx::PxScene</a>.</p>

</div>
</div>
<a id="a648d102cfc6de073ef23243e225ce414" name="a648d102cfc6de073ef23243e225ce414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648d102cfc6de073ef23243e225ce414">&#9670;&#160;</a></span>getArticulations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getArticulations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> **&#160;</td>
          <td class="paramname"><em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve all the articulations in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">userBuffer</td><td>The buffer to receive articulations pointers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of provided user buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Index of first articulations pointer to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of articulations written to the buffer.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#aa5aeb14d2f5e6560f3a2935abed82ef3" title="Returns the number of articulations in the scene.">getNbArticulations()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ade53eb4e46f99b62db730872d45af59f">physx::PxScene</a>.</p>

</div>
</div>
<a id="a6cddad2ad26773e073d27b61e7749ebd" name="a6cddad2ad26773e073d27b61e7749ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cddad2ad26773e073d27b61e7749ebd">&#9670;&#160;</a></span>getBounceThresholdVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxReal NpScene::getBounceThresholdVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bounce threshold velocity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#aad54d9d20e485740a84a7bbfffdefe11" title="A contact with a relative velocity below this will not bounce. A typical value for simulation....">PxSceneDesc.bounceThresholdVelocity</a>, <a class="el" href="classphysx_1_1_np_scene.html#ace3655560e5dac5ba7c3977d67ddb3df" title="Set the bounce threshold velocity. Collision speeds below this threshold will not cause a bounce.">setBounceThresholdVelocity</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a723e443bbbd08ebdb489c067a507f7fd">physx::PxScene</a>.</p>

</div>
</div>
<a id="a0ff9f96bf4266393bbf15abc146b7d0b" name="a0ff9f96bf4266393bbf15abc146b7d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff9f96bf4266393bbf15abc146b7d0b">&#9670;&#160;</a></span>getBroadPhaseCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_broad_phase_callback.html">PxBroadPhaseCallback</a> * NpScene::getBroadPhaseCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the <a class="el" href="classphysx_1_1_px_broad_phase_callback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> pointer set with <a class="el" href="classphysx_1_1_np_scene.html#a9f115b6be26fd492c312a032e6096f1f" title="Sets a broad-phase user callback object.">setBroadPhaseCallback()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The current broad-phase callback pointer. See #PxBroadPhaseCallback.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_broad_phase_callback.html" title="Broad-phase callback to receive broad-phase related events.">PxBroadPhaseCallback</a> <a class="el" href="classphysx_1_1_np_scene.html#a9f115b6be26fd492c312a032e6096f1f" title="Sets a broad-phase user callback object.">setBroadPhaseCallback()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a33d5c6a4e7e1d3377b5855623c372ad0">physx::PxScene</a>.</p>

</div>
</div>
<a id="aef5531198c74271c240f3b5e6fbe5eeb" name="aef5531198c74271c240f3b5e6fbe5eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5531198c74271c240f3b5e6fbe5eeb">&#9670;&#160;</a></span>getBroadPhaseCaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::getBroadPhaseCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_broad_phase_caps.html">PxBroadPhaseCaps</a> &amp;&#160;</td>
          <td class="paramname"><em>caps</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets broad-phase caps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">caps</td><td>Broad-phase caps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a82c9e105b671af3c9fa9acefff519468">physx::PxScene</a>.</p>

</div>
</div>
<a id="a91bf39e2d1d05a874a85389ac7cb8a6b" name="a91bf39e2d1d05a874a85389ac7cb8a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bf39e2d1d05a874a85389ac7cb8a6b">&#9670;&#160;</a></span>getBroadPhaseRegions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getBroadPhaseRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_broad_phase_region_info.html">PxBroadPhaseRegionInfo</a> *&#160;</td>
          <td class="paramname"><em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets broad-phase regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">userBuffer</td><td>Returned broad-phase regions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of userBuffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Index of first desired region, in [0 ; getNbRegions()[ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of written out regions </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a1815418288d9aaf4f0bc447f7658cf71">physx::PxScene</a>.</p>

</div>
</div>
<a id="af2c7c47dec975c65db44e0adcc516455" name="af2c7c47dec975c65db44e0adcc516455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2c7c47dec975c65db44e0adcc516455">&#9670;&#160;</a></span>getBroadPhaseType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structphysx_1_1_px_broad_phase_type.html#ac80bf98cad52e689308c4e2b367b8a2f">PxBroadPhaseType::Enum</a> NpScene::getBroadPhaseType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns broad-phase type. </p>
<dl class="section return"><dt>Returns</dt><dd>Broad-phase type </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a9ec5e7b679916544d4eda9295d1d590e">physx::PxScene</a>.</p>

</div>
</div>
<a id="a8474ccb43f9b2d5bba614ae5256410d3" name="a8474ccb43f9b2d5bba614ae5256410d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8474ccb43f9b2d5bba614ae5256410d3">&#9670;&#160;</a></span>getCCDContactModifyCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_c_c_d_contact_modify_callback.html">PxCCDContactModifyCallback</a> * NpScene::getCCDContactModifyCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the <a class="el" href="classphysx_1_1_px_c_c_d_contact_modify_callback.html" title="An interface class that the user can implement in order to modify CCD contact constraints.">PxCCDContactModifyCallback</a> pointer set with <a class="el" href="classphysx_1_1_np_scene.html#a6a394872deaa7dbd44d6240bd8e8dafc" title="Sets a user callback object, which receives callbacks on all contacts generated for specified actors.">setContactModifyCallback()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The current user contact modify callback pointer. See #PxContactModifyCallback.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_contact_modify_callback.html" title="An interface class that the user can implement in order to modify contact constraints.">PxContactModifyCallback</a> <a class="el" href="classphysx_1_1_np_scene.html#a6a394872deaa7dbd44d6240bd8e8dafc" title="Sets a user callback object, which receives callbacks on all contacts generated for specified actors.">setContactModifyCallback()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a2f8ba6d689432e37529e8d5473421e03">physx::PxScene</a>.</p>

</div>
</div>
<a id="a5316908b5bfa5dab28df9d5bcab07021" name="a5316908b5bfa5dab28df9d5bcab07021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5316908b5bfa5dab28df9d5bcab07021">&#9670;&#160;</a></span>getCCDMaxPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getCCDMaxPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum number of CCD passes. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of CCD passes.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a735fcf1c8af0365502ddac996b0e196d" title="Maximum number of CCD passes.">PxSceneDesc::ccdMaxPasses</a> <a class="el" href="classphysx_1_1_np_scene.html#a29a7ada27b5045396732671746f3f598" title="Sets the maximum number of CCD passes.">setCCDMaxPasses()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aac0d404ef5e918e9ed75b09d87458e2e">physx::PxScene</a>.</p>

</div>
</div>
<a id="a3787f0da131b268dbc6918a4d10e402d" name="a3787f0da131b268dbc6918a4d10e402d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3787f0da131b268dbc6918a4d10e402d">&#9670;&#160;</a></span>getCCDMaxSeparation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxReal NpScene::getCCDMaxSeparation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the maximum CCD separation. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum CCD separation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#aea10c3fc8a745d51ae69e7b4fb330609" title="A threshold for speculative CCD. Used to control whether bias, restitution or a combination of the tw...">PxSceneDesc::ccdMaxSeparation</a> <a class="el" href="classphysx_1_1_np_scene.html#a3b5d78bc2221c7221b50ad6914fb3e5b" title="Set the maximum CCD separation.">setCCDMaxSeparation()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a909c8c5d98ac414ad56ed9594f7600da">physx::PxScene</a>.</p>

</div>
</div>
<a id="a496ec70c2fa7e1219070747aa1f6628b" name="a496ec70c2fa7e1219070747aa1f6628b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496ec70c2fa7e1219070747aa1f6628b">&#9670;&#160;</a></span>getCCDThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxReal NpScene::getCCDThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the CCD threshold. </p>
<dl class="section return"><dt>Returns</dt><dd>The CCD threshold.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a2e5a82176b6a253d4efdca970594dcc5" title="CCD threshold.">PxSceneDesc::ccdThreshold</a> <a class="el" href="classphysx_1_1_np_scene.html#aef2d2dee68ffeec00fe92516acffa355" title="Set the CCD threshold.">setCCDThreshold()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a459c7d794cb630232a287d34c23682ec">physx::PxScene</a>.</p>

</div>
</div>
<a id="ac1e4dfe27afea8452cc39e10dd09f172" name="ac1e4dfe27afea8452cc39e10dd09f172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e4dfe27afea8452cc39e10dd09f172">&#9670;&#160;</a></span>getConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_constraint.html">PxConstraint</a> **&#160;</td>
          <td class="paramname"><em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve all the constraint shaders in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">userBuffer</td><td>The buffer to receive constraint shader pointers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of provided user buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Index of first constraint pointer to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of constraint shaders written to the buffer.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#af6873324086c08b7c73af1828052aba7" title="Returns the number of constraint shaders in the scene.">getNbConstraints()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a432d39d41b6c41e8c49ef4ab6b538591">physx::PxScene</a>.</p>

</div>
</div>
<a id="a179b420149b554519450a31462001072" name="a179b420149b554519450a31462001072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179b420149b554519450a31462001072">&#9670;&#160;</a></span>getContactModifyCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_contact_modify_callback.html">PxContactModifyCallback</a> * NpScene::getContactModifyCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the <a class="el" href="classphysx_1_1_px_contact_modify_callback.html" title="An interface class that the user can implement in order to modify contact constraints.">PxContactModifyCallback</a> pointer set with <a class="el" href="classphysx_1_1_np_scene.html#a6a394872deaa7dbd44d6240bd8e8dafc" title="Sets a user callback object, which receives callbacks on all contacts generated for specified actors.">setContactModifyCallback()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The current user contact modify callback pointer. See #PxContactModifyCallback.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_contact_modify_callback.html" title="An interface class that the user can implement in order to modify contact constraints.">PxContactModifyCallback</a> <a class="el" href="classphysx_1_1_np_scene.html#a6a394872deaa7dbd44d6240bd8e8dafc" title="Sets a user callback object, which receives callbacks on all contacts generated for specified actors.">setContactModifyCallback()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ab462deb73e775c3da4a469b037944caf">physx::PxScene</a>.</p>

</div>
</div>
<a id="aa098bf2b3022c3cda9f9b159ecbedb41" name="aa098bf2b3022c3cda9f9b159ecbedb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa098bf2b3022c3cda9f9b159ecbedb41">&#9670;&#160;</a></span>getContactReportStreamBufferSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getContactReportStreamBufferSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of <a class="el" href="classphysx_1_1_px_scene_desc.html#a6823c8c84bfe0dacb35a7b40057e1037" title="Size of the contact report stream (in bytes).">PxSceneDesc::contactReportStreamBufferSize</a> that was set when creating the scene with <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a6823c8c84bfe0dacb35a7b40057e1037" title="Size of the contact report stream (in bytes).">PxSceneDesc::contactReportStreamBufferSize</a>, <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a1a30425397a5190dfb312e51691ddca3">physx::PxScene</a>.</p>

</div>
</div>
<a id="a004cab06974483375cb464438add52a8" name="a004cab06974483375cb464438add52a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004cab06974483375cb464438add52a8">&#9670;&#160;</a></span>getCpuDispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_cpu_dispatcher.html">PxCpuDispatcher</a> * NpScene::getCpuDispatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cpu dispatcher that was set in <a class="el" href="classphysx_1_1_px_scene_desc.html#ac15840b592f420cea5fb5df591910b6b" title="The CPU task dispatcher for the scene.">PxSceneDesc::cpuDispatcher</a> when creating the scene with <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#ac15840b592f420cea5fb5df591910b6b" title="The CPU task dispatcher for the scene.">PxSceneDesc::cpuDispatcher</a>, <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a1f935c01c3ea470a60d786ce04565f96">physx::PxScene</a>.</p>

</div>
</div>
<a id="a4f1a9f251799640a163457de8a3a3051" name="a4f1a9f251799640a163457de8a3a3051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1a9f251799640a163457de8a3a3051">&#9670;&#160;</a></span>getCudaContextManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxCudaContextManager * NpScene::getCudaContextManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the CUDA context manager that was set in <a class="el" href="classphysx_1_1_px_scene_desc.html#aced016002da6adf9ed0735a1d0166792" title="The CUDA context manager for the scene.">PxSceneDesc::cudaContextManager</a> when creating the scene with <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a>. </p>
<p><b>Platform specific:</b> Applies to PC GPU only.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#aced016002da6adf9ed0735a1d0166792" title="The CUDA context manager for the scene.">PxSceneDesc::cudaContextManager</a>, <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a906859e04f571c05b61b9f5383c53de3">physx::PxScene</a>.</p>

</div>
</div>
<a id="a716d215dfdc868843a1b38ed24c944dd" name="a716d215dfdc868843a1b38ed24c944dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716d215dfdc868843a1b38ed24c944dd">&#9670;&#160;</a></span>getDominanceGroupPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structphysx_1_1_px_dominance_group_pair.html">PxDominanceGroupPair</a> NpScene::getDominanceGroupPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a>&#160;</td>
          <td class="paramname"><em>group1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a>&#160;</td>
          <td class="paramname"><em>group2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Samples the dominance matrix. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#ab5ff3fbd073192ed9998b632bf503715" title="Specifies the dominance behavior of contacts between two actors with two certain dominance groups.">setDominanceGroupPair()</a> <a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e" title="Group index which allows to specify 1- or 2-way interaction.">PxDominanceGroup</a> <a class="el" href="structphysx_1_1_px_dominance_group_pair.html" title="Expresses the dominance relationship of a contact. For the time being only three settings are permitt...">PxDominanceGroupPair</a> <a class="el" href="classphysx_1_1_px_actor.html#a3786b0f53c9a37074372d0ea62ce348d" title="Assigns dynamic actors a dominance group identifier.">PxActor::setDominanceGroup()</a> <a class="el" href="classphysx_1_1_px_actor.html#a4b7effc9b077780ffd713baa8869feae" title="Retrieves the value set with setDominanceGroup().">PxActor::getDominanceGroup()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a7b1467db122df732d4be686872a09fda">physx::PxScene</a>.</p>

</div>
</div>
<a id="ac39092847ef955b78947f4c5f008bd25" name="ac39092847ef955b78947f4c5f008bd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39092847ef955b78947f4c5f008bd25">&#9670;&#160;</a></span>getDynamicStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structphysx_1_1_px_pruning_structure_type.html#a726793bb8900a198e0f9d9507acfc4ca">PxPruningStructureType::Enum</a> NpScene::getDynamicStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of <a class="el" href="classphysx_1_1_px_scene_query_desc.html#a3e03342176fbfe85c9df684a7a4226c6" title="Defines the structure used to store dynamic objects (non-PxRigidStatic actors).">PxSceneQueryDesc::dynamicStructure</a> that was set when creating the scene with <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_query_desc.html#a3e03342176fbfe85c9df684a7a4226c6" title="Defines the structure used to store dynamic objects (non-PxRigidStatic actors).">PxSceneQueryDesc::dynamicStructure</a>, <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_s_q_system.html#a0de04bb17b73b5d25cbdfbb96143f3a5">physx::PxSceneSQSystem</a>.</p>

</div>
</div>
<a id="a4895ebc7606b70bff52c29bca6bfaacc" name="a4895ebc7606b70bff52c29bca6bfaacc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4895ebc7606b70bff52c29bca6bfaacc">&#9670;&#160;</a></span>getDynamicTreeRebuildRateHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getDynamicTreeRebuildRateHint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the rebuild rate of the dynamic tree pruning structures. </p>
<dl class="section return"><dt>Returns</dt><dd>The rebuild rate of the dynamic tree pruning structures.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_query_desc.html#aa9b4f3adb72c59a63e19c09e0c110ab6" title="Hint for how much work should be done per simulation frame to rebuild the pruning structures.">PxSceneQueryDesc.dynamicTreeRebuildRateHint</a> <a class="el" href="classphysx_1_1_np_scene.html#abbac7601df289d7b6f2d04a9caa1b059" title="Sets the rebuild rate of the dynamic tree pruning structures.">setDynamicTreeRebuildRateHint()</a> <a class="el" href="classphysx_1_1_np_scene.html#af43306bf149c77bffadc54bfbb99c17e" title="Forces dynamic trees to be immediately rebuilt.">forceRebuildDynamicTree()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_query_system_base.html#aee6cde9f7c7826d95a00fb7d129770ba">physx::PxSceneQuerySystemBase</a>.</p>

</div>
</div>
<a id="acf585f9ffa7e3981b81d95b3f9434b07" name="acf585f9ffa7e3981b81d95b3f9434b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf585f9ffa7e3981b81d95b3f9434b07">&#9670;&#160;</a></span>getFEMCloths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getFEMCloths </td>
          <td>(</td>
          <td class="paramtype">PxFEMCloth **&#160;</td>
          <td class="paramname"><em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve an array of all the FEM cloths in the scene. </p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">userBuffer</td><td>The buffer to write the FEM cloth pointers to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the provided user buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Index of first FEM cloth pointer to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of FEM cloths written to the buffer </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a306a5e66b5eff0ff0768d03249739d3e">physx::PxScene</a>.</p>

</div>
</div>
<a id="a59765ccc071f85c69351ab4d5c100774" name="a59765ccc071f85c69351ab4d5c100774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59765ccc071f85c69351ab4d5c100774">&#9670;&#160;</a></span>getFilterCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_simulation_filter_callback.html">PxSimulationFilterCallback</a> * NpScene::getFilterCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the custom collision filter callback in use for this scene. </p>
<dl class="section return"><dt>Returns</dt><dd>Filter callback class that defines the collision pair filtering.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a865a26b241fa075914305d5f7485993c" title="A custom collision filter callback which can be used to implement more complex filtering operations w...">PxSceneDesc.filterCallback</a> <a class="el" href="classphysx_1_1_px_simulation_filter_callback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ab7a0f68ef4e2b470481fd4b658427009">physx::PxScene</a>.</p>

</div>
</div>
<a id="a2ad6af74fbfb3d08fc994e5891990e57" name="a2ad6af74fbfb3d08fc994e5891990e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad6af74fbfb3d08fc994e5891990e57">&#9670;&#160;</a></span>getFilterShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacephysx.html#a7d989364d9339d1946b69ec9432f36ae">PxSimulationFilterShader</a> NpScene::getFilterShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the custom collision filter shader in use for this scene. </p>
<dl class="section return"><dt>Returns</dt><dd>Filter shader class that defines the collision pair filtering.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a7d5cdab2c509161ef88035e67ca7d8ae" title="The custom filter shader to use for collision filtering.">PxSceneDesc.filterShader</a> <a class="el" href="namespacephysx.html#a7d989364d9339d1946b69ec9432f36ae" title="Filter method to specify how a pair of potentially colliding objects should be processed.">PxSimulationFilterShader</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a6bc6b3f9bdd80bb2b2a1bdd77494d07b">physx::PxScene</a>.</p>

</div>
</div>
<a id="ae4b8cd7f046e9b62188ece65dd367bc2" name="ae4b8cd7f046e9b62188ece65dd367bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b8cd7f046e9b62188ece65dd367bc2">&#9670;&#160;</a></span>getFilterShaderData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * NpScene::getFilterShaderData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the shared global filter data in use for this scene. </p>
<dl class="section note"><dt>Note</dt><dd>The reference points to a copy of the original filter data specified in <a class="el" href="classphysx_1_1_px_scene_desc.html#a5fd01054bfc88a5c30748ad712abfd88" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a> or provided by <a class="el" href="classphysx_1_1_np_scene.html#a662fed3a64c14045f3df4e833ded9a58" title="Sets the shared global filter data which will get passed into the filter shader.">setFilterShaderData()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Shared filter data for filter shader.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#a60a3bf5b9a99fcee7eeffea2c34280dc" title="Gets the size of the shared global filter data (PxSceneDesc.filterShaderData)">getFilterShaderDataSize()</a> <a class="el" href="classphysx_1_1_np_scene.html#a662fed3a64c14045f3df4e833ded9a58" title="Sets the shared global filter data which will get passed into the filter shader.">setFilterShaderData()</a> <a class="el" href="classphysx_1_1_px_scene_desc.html#a5fd01054bfc88a5c30748ad712abfd88" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a> <a class="el" href="namespacephysx.html#a7d989364d9339d1946b69ec9432f36ae" title="Filter method to specify how a pair of potentially colliding objects should be processed.">PxSimulationFilterShader</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aa805b82e1df5d34ef67cb5694f929a4e">physx::PxScene</a>.</p>

</div>
</div>
<a id="a60a3bf5b9a99fcee7eeffea2c34280dc" name="a60a3bf5b9a99fcee7eeffea2c34280dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a3bf5b9a99fcee7eeffea2c34280dc">&#9670;&#160;</a></span>getFilterShaderDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getFilterShaderDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the shared global filter data (<a class="el" href="classphysx_1_1_px_scene_desc.html#a5fd01054bfc88a5c30748ad712abfd88" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a>) </p>
<dl class="section return"><dt>Returns</dt><dd>Size of shared filter data [bytes].</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#ae4b8cd7f046e9b62188ece65dd367bc2" title="Gets the shared global filter data in use for this scene.">getFilterShaderData()</a> <a class="el" href="classphysx_1_1_px_scene_desc.html#a78d667db925f7cc78c3d2211ae3683ca" title="Size (in bytes) of the shared global filter data filterShaderData.">PxSceneDesc.filterShaderDataSize</a> <a class="el" href="namespacephysx.html#a7d989364d9339d1946b69ec9432f36ae" title="Filter method to specify how a pair of potentially colliding objects should be processed.">PxSimulationFilterShader</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a91b681624566ec957aa12b18949fa70b">physx::PxScene</a>.</p>

</div>
</div>
<a id="a032146965d449d65ea35e93d039a27b7" name="a032146965d449d65ea35e93d039a27b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032146965d449d65ea35e93d039a27b7">&#9670;&#160;</a></span>getFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacephysx.html#a1ba7b23b18ff732b37a74fdd1496be2c">PxSceneFlags</a> NpScene::getFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the scene flags. </p>
<dl class="section return"><dt>Returns</dt><dd>The scene flags. See #PxSceneFlag</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_scene_flag.html" title="flags for configuring properties of the scene">PxSceneFlag</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a6bad9d4d3f76544997020d5b68371db7">physx::PxScene</a>.</p>

</div>
</div>
<a id="a250c2fd08143f1e91691a65b41526394" name="a250c2fd08143f1e91691a65b41526394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250c2fd08143f1e91691a65b41526394">&#9670;&#160;</a></span>getFrictionCorrelationDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxReal NpScene::getFrictionCorrelationDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the friction correlation distance. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a69991c05f58629b6c3cc775242e069c9" title="Friction correlation distance used to decide whether contacts are close enough to be merged into a si...">PxSceneDesc::frictionCorrelationDistance</a>, <a class="el" href="classphysx_1_1_np_scene.html#a911d803e082ba5c34b4f30bc3d6c4bb9" title="Set the friction correlation distance.">setFrictionCorrelationDistance</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a8f105bdcb52e3ac7314cef15f3a79956">physx::PxScene</a>.</p>

</div>
</div>
<a id="ac0770948af43be11d82add237afc0ad4" name="ac0770948af43be11d82add237afc0ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0770948af43be11d82add237afc0ad4">&#9670;&#160;</a></span>getFrictionOffsetThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxReal NpScene::getFrictionOffsetThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the friction offset threshold. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#afcd24ab471972d8faad7b1bbd6b2748e" title="A threshold of contact separation distance used to decide if a contact point will experience friction...">PxSceneDesc::frictionOffsetThreshold</a>, <a class="el" href="classphysx_1_1_np_scene.html#a7cb738f041a90dc9a22fe6494476860f" title="Set the friction offset threshold.">setFrictionOffsetThreshold</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aa8a70d9bd789aa01c7b6193aa017c7fd">physx::PxScene</a>.</p>

</div>
</div>
<a id="a423b5f90c744e70bf374e247aa662b26" name="a423b5f90c744e70bf374e247aa662b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423b5f90c744e70bf374e247aa662b26">&#9670;&#160;</a></span>getFrictionType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structphysx_1_1_px_friction_type.html#aa2bd47515042cacbc4e34cb163331a86">PxFrictionType::Enum</a> NpScene::getFrictionType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the friction model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_friction_type.html" title="Enum for selecting the friction algorithm used for simulation.">PxFrictionType</a>, <a class="el" href="classphysx_1_1_px_scene_desc.html#ac4de13f5423aa6c19c2b63d3c957de99" title="Selects the friction algorithm to use for simulation.">PxSceneDesc::frictionType</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#add661e81fe7255762e81ab9e18143bb5">physx::PxScene</a>.</p>

</div>
</div>
<a id="af256266034c802d8f30804fbd5d8948d" name="af256266034c802d8f30804fbd5d8948d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af256266034c802d8f30804fbd5d8948d">&#9670;&#160;</a></span>getFrozenActors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> ** NpScene::getFrozenActors </td>
          <td>(</td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>nbActorsOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classphysx_1_1_np_scene_accessor.html">physx::NpSceneAccessor</a>.</p>

</div>
</div>
<a id="ac74c542fb650cdbf58fc63e861599121" name="ac74c542fb650cdbf58fc63e861599121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74c542fb650cdbf58fc63e861599121">&#9670;&#160;</a></span>getGpuDynamicsConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structphysx_1_1_pxg_dynamics_memory_config.html">PxgDynamicsMemoryConfig</a> physx::NpScene::getGpuDynamicsConfig </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html">physx::PxScene</a>.</p>

</div>
</div>
<a id="afc5198b7257a8cffa856dcbe979f49f2" name="afc5198b7257a8cffa856dcbe979f49f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5198b7257a8cffa856dcbe979f49f2">&#9670;&#160;</a></span>getGravity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> NpScene::getGravity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the current gravity setting. </p>
<dl class="section return"><dt>Returns</dt><dd>The current gravity for the scene.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#a0cdc7e9623f1822ad460e4dc3bac2f41" title="Sets a constant gravity for the entire scene.">setGravity()</a> <a class="el" href="classphysx_1_1_px_scene_desc.html#a62505d66b9c4f00831cf31a7c4bf4046" title="Gravity vector.">PxSceneDesc.gravity</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#afaa47b320ad3ba4add15e93315025714">physx::PxScene</a>.</p>

</div>
</div>
<a id="a50505c3cc2c76aed10097df9a00d0898" name="a50505c3cc2c76aed10097df9a00d0898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50505c3cc2c76aed10097df9a00d0898">&#9670;&#160;</a></span>getHairSystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getHairSystems </td>
          <td>(</td>
          <td class="paramtype">PxHairSystem **&#160;</td>
          <td class="paramname"><em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve an array of all the hair systems in the scene. </p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">userBuffer</td><td>The buffer to write the actor pointers to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the provided user buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Index of first actor pointer to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of actors written to the buffer </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aa019e0a2445e28cd25fd1b0476ba4b39">physx::PxScene</a>.</p>

</div>
</div>
<a id="aeaf0baf23bdc4a3d3e39a068839a52f5" name="aeaf0baf23bdc4a3d3e39a068839a52f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf0baf23bdc4a3d3e39a068839a52f5">&#9670;&#160;</a></span>getKinematicKinematicFilteringMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structphysx_1_1_px_pair_filtering_mode.html#acb3b16b245524f65af0b4c19335eaf27">PxPairFilteringMode::Enum</a> NpScene::getKinematicKinematicFilteringMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pair filtering mode for kinematic-kinematic pairs. </p>
<dl class="section return"><dt>Returns</dt><dd>Filtering mode for kinematic-kinematic pairs.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_pair_filtering_mode.html">PxPairFilteringMode</a> <a class="el" href="classphysx_1_1_px_scene_desc.html" title="Descriptor class for scenes. See #PxScene.">PxSceneDesc</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#addd60e40d84c68cf6de954ae1600fc8e">physx::PxScene</a>.</p>

</div>
</div>
<a id="aacb77c09bb27fd93eee045ce1591b681" name="aacb77c09bb27fd93eee045ce1591b681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb77c09bb27fd93eee045ce1591b681">&#9670;&#160;</a></span>getLimits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_scene_limits.html">PxSceneLimits</a> NpScene::getLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current scene limits. </p>
<dl class="section return"><dt>Returns</dt><dd>Current scene limits. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_limits.html" title="Class used to retrieve limits(e.g. maximum number of bodies) for a scene. The limits are used as a hi...">PxSceneLimits</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a84d4fc4784e9a90dcfe52b3349c44a86">physx::PxScene</a>.</p>

</div>
</div>
<a id="a79a74b8b08c99a62ea9c987e38ddba35" name="a79a74b8b08c99a62ea9c987e38ddba35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a74b8b08c99a62ea9c987e38ddba35">&#9670;&#160;</a></span>getMaxBiasCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxReal NpScene::getMaxBiasCoefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the max bias coefficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The max bias coefficient.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#ad2b0b28bc190c1a4bbbda3ef115eb5e2" title="The maximum bias coefficient used in the constraint solver.">PxSceneDesc::maxBiasCoefficient</a> <a class="el" href="classphysx_1_1_np_scene.html#a213d2ef7f2baf9613b1de1fdd2d6ba05" title="Set the max bias coefficient.">setMaxBiasCoefficient()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a7b50aac5022a33341408ac4c33f19bcb">physx::PxScene</a>.</p>

</div>
</div>
<a id="a318d6decd73dd9e46cf3681f73ddb7c7" name="a318d6decd73dd9e46cf3681f73ddb7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318d6decd73dd9e46cf3681f73ddb7c7">&#9670;&#160;</a></span>getMaxNbContactDataBlocksUsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getMaxNbContactDataBlocksUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the maximum number of cache blocks used by the scene </p>
<p>This function may not be called while the scene is simulating</p>
<dl class="section return"><dt>Returns</dt><dd>the maximum number of cache blocks everused by the scene</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#aa24c162f0c558207a5d4e7e3c0243a8a" title="Setting to define the number of 16K blocks that will be initially reserved to store contact,...">PxSceneDesc.nbContactDataBlocks</a> <a class="el" href="classphysx_1_1_px_scene_desc.html#a23bbe23f16a7c7f8b5a0016a5abba02b" title="Setting to define the maximum number of 16K blocks that can be allocated to store contact,...">PxSceneDesc.maxNbContactDataBlocks</a> <a class="el" href="classphysx_1_1_np_scene.html#aad60c8aaea2ce9544fb3d987dc7e9986" title="Clear internal buffers and free memory.">flushSimulation()</a> <a class="el" href="classphysx_1_1_np_scene.html#a165d89debaed76c460cad53931a25bd2" title="set the cache blocks that can be used during simulate().">setNbContactDataBlocks()</a> <a class="el" href="classphysx_1_1_np_scene.html#a46447105dc218cc7cc21334435c1a49a" title="get the number of cache blocks currently used by the scene">getNbContactDataBlocksUsed()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a7510be50875a544ef4569ff7206fc9c9">physx::PxScene</a>.</p>

</div>
</div>
<a id="ad77b3c021b3c6f7125fee3b351555206" name="ad77b3c021b3c6f7125fee3b351555206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77b3c021b3c6f7125fee3b351555206">&#9670;&#160;</a></span>getNbActors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getNbActors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#abb179bd82b9dca8e4c30ae19447fa5a7">PxActorTypeFlags</a>&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of actors of certain types in the scene. For supported types, see PxActorTypeFlags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">types</td><td>Combination of actor types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of actors.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#af3d78ebac2b9075c068456acec30bdbf" title="Retrieve an array of all the actors of certain types in the scene. For supported types,...">getActors()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ae8416d78c556c21e7e961e5f9bad460f">physx::PxScene</a>.</p>

</div>
</div>
<a id="a91fb85e7ae86fa4945d15ce1059a2b43" name="a91fb85e7ae86fa4945d15ce1059a2b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fb85e7ae86fa4945d15ce1059a2b43">&#9670;&#160;</a></span>getNbAggregates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getNbAggregates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of aggregates in the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of aggregates in this scene.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#a4a843d6652a7cd7e956775f926a6e2cb" title="Retrieve all the aggregates in the scene.">getAggregates()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aa0ffd1ffd63b6d22cd679a6c3d345830">physx::PxScene</a>.</p>

</div>
</div>
<a id="aa5aeb14d2f5e6560f3a2935abed82ef3" name="aa5aeb14d2f5e6560f3a2935abed82ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5aeb14d2f5e6560f3a2935abed82ef3">&#9670;&#160;</a></span>getNbArticulations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getNbArticulations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of articulations in the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of articulations in this scene.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>getArticulations() </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aed6d4de4b67ff9cbeccced181d40c909">physx::PxScene</a>.</p>

</div>
</div>
<a id="ac4702a789d42ef9cbb87ac2265bfab03" name="ac4702a789d42ef9cbb87ac2265bfab03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4702a789d42ef9cbb87ac2265bfab03">&#9670;&#160;</a></span>getNbBroadPhaseRegions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getNbBroadPhaseRegions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of regions currently registered in the broad-phase. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of regions </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aac3db904a191be66c48ebad11158811d">physx::PxScene</a>.</p>

</div>
</div>
<a id="af6873324086c08b7c73af1828052aba7" name="af6873324086c08b7c73af1828052aba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6873324086c08b7c73af1828052aba7">&#9670;&#160;</a></span>getNbConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getNbConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of constraint shaders in the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of constraint shaders in this scene.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#ac1e4dfe27afea8452cc39e10dd09f172" title="Retrieve all the constraint shaders in the scene.">getConstraints()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#aa744dfe545b41ff9e380ddb17c2275e1">physx::PxScene</a>.</p>

</div>
</div>
<a id="a46447105dc218cc7cc21334435c1a49a" name="a46447105dc218cc7cc21334435c1a49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46447105dc218cc7cc21334435c1a49a">&#9670;&#160;</a></span>getNbContactDataBlocksUsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getNbContactDataBlocksUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the number of cache blocks currently used by the scene </p>
<p>This function may not be called while the scene is simulating</p>
<dl class="section return"><dt>Returns</dt><dd>the number of cache blocks currently used by the scene</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#aa24c162f0c558207a5d4e7e3c0243a8a" title="Setting to define the number of 16K blocks that will be initially reserved to store contact,...">PxSceneDesc.nbContactDataBlocks</a> <a class="el" href="classphysx_1_1_px_scene_desc.html#a23bbe23f16a7c7f8b5a0016a5abba02b" title="Setting to define the maximum number of 16K blocks that can be allocated to store contact,...">PxSceneDesc.maxNbContactDataBlocks</a> <a class="el" href="classphysx_1_1_np_scene.html#aad60c8aaea2ce9544fb3d987dc7e9986" title="Clear internal buffers and free memory.">flushSimulation()</a> <a class="el" href="classphysx_1_1_np_scene.html#a165d89debaed76c460cad53931a25bd2" title="set the cache blocks that can be used during simulate().">setNbContactDataBlocks()</a> <a class="el" href="classphysx_1_1_np_scene.html#a318d6decd73dd9e46cf3681f73ddb7c7" title="get the maximum number of cache blocks used by the scene">getMaxNbContactDataBlocksUsed()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a4bd55cfa2767c00bae5dc6119bd9431b">physx::PxScene</a>.</p>

</div>
</div>
<a id="a89d3234732ad157a17eb7c64a4c8f9b4" name="a89d3234732ad157a17eb7c64a4c8f9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d3234732ad157a17eb7c64a4c8f9b4">&#9670;&#160;</a></span>getNbFEMCloths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getNbFEMCloths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of FEM cloths in the scene. </p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of FEM cloths.</dd></dl>
<p>See <a class="el" href="classphysx_1_1_np_scene.html#acf585f9ffa7e3981b81d95b3f9434b07" title="Retrieve an array of all the FEM cloths in the scene.">getFEMCloths()</a> </p>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ab3fbc0ea0276715bc32fad4260b6bfdf">physx::PxScene</a>.</p>

</div>
</div>
<a id="a93a31837ae36e5f7b3b2cf8a391950c5" name="a93a31837ae36e5f7b3b2cf8a391950c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a31837ae36e5f7b3b2cf8a391950c5">&#9670;&#160;</a></span>getNbHairSystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getNbHairSystems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of hair systems in the scene. </p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of hair systems </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#af3d78ebac2b9075c068456acec30bdbf" title="Retrieve an array of all the actors of certain types in the scene. For supported types,...">getActors()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a65684ce4cddcd7484e568fe551f28c60">physx::PxScene</a>.</p>

</div>
</div>
<a id="a489b4634511bce61ca64821337bd92d2" name="a489b4634511bce61ca64821337bd92d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489b4634511bce61ca64821337bd92d2">&#9670;&#160;</a></span>getNbParticleSystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getNbParticleSystems </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_particle_solver_type.html#aab44d7e28b088d01cda18e0b7217ad2f">PxParticleSolverType::Enum</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of particle systems of the requested type in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The particle system type. See <a class="el" href="structphysx_1_1_px_particle_solver_type.html" title="Identifies the solver to use for a particle system.">PxParticleSolverType</a>. Only one type can be requested per function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number particle systems.</dd></dl>
<p>See <a class="el" href="classphysx_1_1_np_scene.html#ad143484c5d213a12bb2e69d3cafdf0c4" title="Retrieve an array of all the particle systems of the requested type in the scene.">getParticleSystems()</a>, <a class="el" href="structphysx_1_1_px_particle_solver_type.html" title="Identifies the solver to use for a particle system.">PxParticleSolverType</a> </p>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#abababe08774861786ae7ced1693c8560">physx::PxScene</a>.</p>

</div>
</div>
<a id="ae1b018b464729621c7aa0d121cef2d30" name="ae1b018b464729621c7aa0d121cef2d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b018b464729621c7aa0d121cef2d30">&#9670;&#160;</a></span>getNbSoftBodies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getNbSoftBodies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of soft bodies in the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of soft bodies.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#af3d78ebac2b9075c068456acec30bdbf" title="Retrieve an array of all the actors of certain types in the scene. For supported types,...">getActors()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a13d41246ea56135b8edb5561dbe46e7c">physx::PxScene</a>.</p>

</div>
</div>
<a id="ad143484c5d213a12bb2e69d3cafdf0c4" name="ad143484c5d213a12bb2e69d3cafdf0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad143484c5d213a12bb2e69d3cafdf0c4">&#9670;&#160;</a></span>getParticleSystems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getParticleSystems </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_particle_solver_type.html#aab44d7e28b088d01cda18e0b7217ad2f">PxParticleSolverType::Enum</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_particle_system.html">PxParticleSystem</a> **&#160;</td>
          <td class="paramname"><em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve an array of all the particle systems of the requested type in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The particle system type. See <a class="el" href="structphysx_1_1_px_particle_solver_type.html" title="Identifies the solver to use for a particle system.">PxParticleSolverType</a>. Only one type can be requested per function call. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">userBuffer</td><td>The buffer to receive particle system pointers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of provided user buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Index of first particle system pointer to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of particle systems written to the buffer.</dd></dl>
<p>See <a class="el" href="classphysx_1_1_np_scene.html#a489b4634511bce61ca64821337bd92d2" title="Retrieve the number of particle systems of the requested type in the scene.">getNbParticleSystems()</a>, <a class="el" href="structphysx_1_1_px_particle_solver_type.html" title="Identifies the solver to use for a particle system.">PxParticleSolverType</a> </p>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a5e0d5e93dfeef476bf08a74ee545ccc3">physx::PxScene</a>.</p>

</div>
</div>
<a id="a409975323f89f53ab9d8066b903f969c" name="a409975323f89f53ab9d8066b903f969c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409975323f89f53ab9d8066b903f969c">&#9670;&#160;</a></span>getPhysics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_physics.html">PxPhysics</a> &amp; NpScene::getPhysics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this method to retrieve the Physics SDK. </p>
<dl class="section return"><dt>Returns</dt><dd>The physics SDK this scene is associated with.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_physics.html" title="Abstract singleton factory class used for instancing objects in the Physics SDK.">PxPhysics</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a79c30b4f63853fadcab17b79a8712b63">physx::PxScene</a>.</p>

</div>
</div>
<a id="ab64368fd3bce3e261a4cd2790432e333" name="ab64368fd3bce3e261a4cd2790432e333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64368fd3bce3e261a4cd2790432e333">&#9670;&#160;</a></span>getRenderBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classphysx_1_1_px_render_buffer.html">PxRenderBuffer</a> &amp; NpScene::getRenderBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the render buffer. </p>
<p>This will contain the results of any active visualization for this scene.</p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running. Calls to this method while the simulation is running will result in undefined behaviour.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The render buffer.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_render_buffer.html" title="Interface for points, lines, triangles, and text buffer.">PxRenderBuffer</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a7dab0c597ed9cc15a4ed1d742fd485af">physx::PxScene</a>.</p>

</div>
</div>
<a id="a8e92ec0389a95e8c47b251cfe3542671" name="a8e92ec0389a95e8c47b251cfe3542671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e92ec0389a95e8c47b251cfe3542671">&#9670;&#160;</a></span>getScenePvdClient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_pvd_scene_client.html">PxPvdSceneClient</a> * NpScene::getScenePvdClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Pvd client associated with the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>the client, NULL if no PVD supported. </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a78121784577e178a12f58c46e145c6fe">physx::PxScene</a>.</p>

</div>
</div>
<a id="a751721ed8b3507c78648a4f4015b8b22" name="a751721ed8b3507c78648a4f4015b8b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751721ed8b3507c78648a4f4015b8b22">&#9670;&#160;</a></span>getSimulationController()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_pxs_simulation_controller.html">PxsSimulationController</a> * NpScene::getSimulationController </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classphysx_1_1_np_scene_accessor.html">physx::NpSceneAccessor</a>.</p>

</div>
</div>
<a id="a60b0d45fa77042425ea1c46216eee23f" name="a60b0d45fa77042425ea1c46216eee23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b0d45fa77042425ea1c46216eee23f">&#9670;&#160;</a></span>getSimulationEventCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_simulation_event_callback.html">PxSimulationEventCallback</a> * NpScene::getSimulationEventCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the simulationEventCallback pointer set with <a class="el" href="classphysx_1_1_np_scene.html#acf0505359e51a314a0358712c524e8df" title="Sets a user notify object which receives special simulation events when they occur.">setSimulationEventCallback()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The current user notify pointer. See #PxSimulationEventCallback.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_simulation_event_callback.html" title="An interface class that the user can implement in order to receive simulation events.">PxSimulationEventCallback</a> <a class="el" href="classphysx_1_1_np_scene.html#acf0505359e51a314a0358712c524e8df" title="Sets a user notify object which receives special simulation events when they occur.">setSimulationEventCallback()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a59e337988a53838d8e24e66af3bf3be2">physx::PxScene</a>.</p>

</div>
</div>
<a id="aecb0bedc73408e5f28656bbbe0f81374" name="aecb0bedc73408e5f28656bbbe0f81374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb0bedc73408e5f28656bbbe0f81374">&#9670;&#160;</a></span>getSimulationStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::getSimulationStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_simulation_statistics.html">PxSimulationStatistics</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this method to retrieve statistics for the current simulation step. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>Used to retrieve statistics for the current simulation step.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_simulation_statistics.html" title="Class used to retrieve statistics for a simulation step.">PxSimulationStatistics</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a8e31767110cdcff51abc530048deda60">physx::PxScene</a>.</p>

</div>
</div>
<a id="a1eefd0b7be71bade4ffc0d15ad146a35" name="a1eefd0b7be71bade4ffc0d15ad146a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eefd0b7be71bade4ffc0d15ad146a35">&#9670;&#160;</a></span>getSoftBodies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getSoftBodies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> **&#160;</td>
          <td class="paramname"><em>userBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>startIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve an array of all the soft bodies in the scene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">userBuffer</td><td>The buffer to receive actor pointers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of provided user buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startIndex</td><td>Index of first actor pointer to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of actors written to the buffer.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#ad77b3c021b3c6f7125fee3b351555206" title="Retrieve the number of actors of certain types in the scene. For supported types, see PxActorTypeFlag...">getNbActors()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a2304b6cfe8297715c07d1d56a0c9836d">physx::PxScene</a>.</p>

</div>
</div>
<a id="a94badc79f35955ba1c91e24cbcc38213" name="a94badc79f35955ba1c91e24cbcc38213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94badc79f35955ba1c91e24cbcc38213">&#9670;&#160;</a></span>getSolverArticulationBatchSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getSolverArticulationBatchSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of articulations required to spawn a separate rigid body solver thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Current number of articulations required to spawn a separate rigid body solver thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#adf6e151a8b23c58617e38b60436eb458" title="Defines the number of actors required to spawn a separate rigid body solver island task chain.">PxSceneDesc.solverBatchSize</a> <a class="el" href="classphysx_1_1_np_scene.html#aa5b18319c90e091728482b0c7e142031" title="Sets the number of articulations required to spawn a separate rigid body solver thread.">setSolverArticulationBatchSize()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a4505e78a2c2f6d17c42ffeddf8161802">physx::PxScene</a>.</p>

</div>
</div>
<a id="af7e15a81d064f2113e97c6425505b900" name="af7e15a81d064f2113e97c6425505b900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e15a81d064f2113e97c6425505b900">&#9670;&#160;</a></span>getSolverBatchSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getSolverBatchSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of actors required to spawn a separate rigid body solver thread. </p>
<dl class="section return"><dt>Returns</dt><dd>Current number of actors required to spawn a separate rigid body solver thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#adf6e151a8b23c58617e38b60436eb458" title="Defines the number of actors required to spawn a separate rigid body solver island task chain.">PxSceneDesc.solverBatchSize</a> <a class="el" href="classphysx_1_1_np_scene.html#a5e5ffb28a99ee7845ceb09951cc1eaec" title="Sets the number of actors required to spawn a separate rigid body solver thread.">setSolverBatchSize()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ada5be7946aa8991a36d6f122fceb041a">physx::PxScene</a>.</p>

</div>
</div>
<a id="a8ed20367cae9708c2ba05a631307cec0" name="a8ed20367cae9708c2ba05a631307cec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed20367cae9708c2ba05a631307cec0">&#9670;&#160;</a></span>getSolverType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structphysx_1_1_px_solver_type.html#a0544603c699b5fc70915ae1e41ba61e6">PxSolverType::Enum</a> NpScene::getSolverType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the solver model. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_solver_type.html" title="Enum for selecting the type of solver used for the simulation.">PxSolverType</a>, <a class="el" href="classphysx_1_1_px_scene_desc.html#a7671f47870c5c9999fb77cbb1030d695" title="Selects the solver algorithm to use.">PxSceneDesc::solverType</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a97225eed42e3cf9293164128569a8efe">physx::PxScene</a>.</p>

</div>
</div>
<a id="abf729829fc20a88d1dfcc5ca7e601370" name="abf729829fc20a88d1dfcc5ca7e601370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf729829fc20a88d1dfcc5ca7e601370">&#9670;&#160;</a></span>getStaticKinematicFilteringMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structphysx_1_1_px_pair_filtering_mode.html#acb3b16b245524f65af0b4c19335eaf27">PxPairFilteringMode::Enum</a> NpScene::getStaticKinematicFilteringMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pair filtering mode for static-kinematic pairs. </p>
<dl class="section return"><dt>Returns</dt><dd>Filtering mode for static-kinematic pairs.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_pair_filtering_mode.html">PxPairFilteringMode</a> <a class="el" href="classphysx_1_1_px_scene_desc.html" title="Descriptor class for scenes. See #PxScene.">PxSceneDesc</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#af83c8766d584f8e33093f7afcb879681">physx::PxScene</a>.</p>

</div>
</div>
<a id="ab11e696d44f18c302d55ee8496bdf8cf" name="ab11e696d44f18c302d55ee8496bdf8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11e696d44f18c302d55ee8496bdf8cf">&#9670;&#160;</a></span>getStaticStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structphysx_1_1_px_pruning_structure_type.html#a726793bb8900a198e0f9d9507acfc4ca">PxPruningStructureType::Enum</a> NpScene::getStaticStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of <a class="el" href="classphysx_1_1_px_scene_query_desc.html#a4f1303e59d71733a16aae16ebcc33b68" title="Defines the structure used to store static objects (PxRigidStatic actors).">PxSceneQueryDesc::staticStructure</a> that was set when creating the scene with <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_query_desc.html#a4f1303e59d71733a16aae16ebcc33b68" title="Defines the structure used to store static objects (PxRigidStatic actors).">PxSceneQueryDesc::staticStructure</a>, <a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics::createScene</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_s_q_system.html#a84bd51f20c7b6484b54a74c21fd30656">physx::PxSceneSQSystem</a>.</p>

</div>
</div>
<a id="a2384338a892dd50bb369a84f0e4b58f1" name="a2384338a892dd50bb369a84f0e4b58f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2384338a892dd50bb369a84f0e4b58f1">&#9670;&#160;</a></span>getStaticTimestamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getStaticTimestamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the system's internal scene query timestamp, increased each time a change to the static scene query structure is performed. </p>
<dl class="section return"><dt>Returns</dt><dd>scene query static timestamp </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_query_system_base.html#adc3301f591d7efb3dec3d48b4cefbb37">physx::PxSceneQuerySystemBase</a>.</p>

</div>
</div>
<a id="a4b34b33b5613df07966b9b33c18bb1ac" name="a4b34b33b5613df07966b9b33c18bb1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b34b33b5613df07966b9b33c18bb1ac">&#9670;&#160;</a></span>getTaskManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_task_manager.html">PxTaskManager</a> * physx::NpScene::getTaskManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the task manager associated with this scene. </p>
<dl class="section return"><dt>Returns</dt><dd>the task manager associated with the scene </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a80fb31daa17c170cabcd80470d373ece">physx::PxScene</a>.</p>

</div>
</div>
<a id="a2e516892594e8af8123fc8b6b35d082f" name="a2e516892594e8af8123fc8b6b35d082f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e516892594e8af8123fc8b6b35d082f">&#9670;&#160;</a></span>getTimestamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxU32 NpScene::getTimestamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the scene's internal timestamp, increased each time a simulation step is completed. </p>
<dl class="section return"><dt>Returns</dt><dd>scene timestamp </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a966b51fad4ddbf9128de548b0717a41c">physx::PxScene</a>.</p>

</div>
</div>
<a id="ab460ec8a1b24641fe9c9aefdbb53a48b" name="ab460ec8a1b24641fe9c9aefdbb53a48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab460ec8a1b24641fe9c9aefdbb53a48b">&#9670;&#160;</a></span>getUpdateMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structphysx_1_1_px_scene_query_update_mode.html#a3d0e848308f503deeb42f966e9fcb99f">PxSceneQueryUpdateMode::Enum</a> NpScene::getUpdateMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets scene query update mode. </p>
<dl class="section return"><dt>Returns</dt><dd>Current scene query update mode.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_scene_query_update_mode.html#a3d0e848308f503deeb42f966e9fcb99f">PxSceneQueryUpdateMode::Enum</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_query_system_base.html#acc7e4d9564d260a896c59112e73a6538">physx::PxSceneQuerySystemBase</a>.</p>

</div>
</div>
<a id="abf384537a1340be67465c3877b788f3e" name="abf384537a1340be67465c3877b788f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf384537a1340be67465c3877b788f3e">&#9670;&#160;</a></span>getVisualizationCullingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a> NpScene::getVisualizationCullingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the visualization culling box. </p>
<dl class="section return"><dt>Returns</dt><dd>the box to which the geometry will be culled. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#a3cfe009ab48d0c572f63d4a8e74b827d" title="Function that lets you set debug visualization parameters.">setVisualizationParameter</a> <a class="el" href="classphysx_1_1_np_scene.html#a53e090f275f6f3794f737bf54ffc3201" title="Defines a box in world space to which visualization geometry will be (conservatively) culled....">setVisualizationCullingBox</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a945cb94dbe51babca5ccbb961602c71f">physx::PxScene</a>.</p>

</div>
</div>
<a id="a526bf8a471eb0cd2bdbd827e7e022089" name="a526bf8a471eb0cd2bdbd827e7e022089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526bf8a471eb0cd2bdbd827e7e022089">&#9670;&#160;</a></span>getVisualizationParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxReal NpScene::getVisualizationParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_visualization_parameter.html#aa447b94a67f50a6573d90f68812ad47e">PxVisualizationParameter::Enum</a>&#160;</td>
          <td class="paramname"><em>paramEnum</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that lets you query debug visualization parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramEnum</td><td>The Parameter to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the parameter.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#a3cfe009ab48d0c572f63d4a8e74b827d" title="Function that lets you set debug visualization parameters.">setVisualizationParameter</a> <a class="el" href="structphysx_1_1_px_visualization_parameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a487ce0fecb1487735e519f90fa24e3fe">physx::PxScene</a>.</p>

</div>
</div>
<a id="a8d5b223a16d7b6b8f868ca3aa3226b9d" name="a8d5b223a16d7b6b8f868ca3aa3226b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5b223a16d7b6b8f868ca3aa3226b9d">&#9670;&#160;</a></span>getWakeCounterResetValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PxReal NpScene::getWakeCounterResetValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the wake counter reset value. </p>
<dl class="section return"><dt>Returns</dt><dd>Wake counter reset value</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a9fa76944edfb3c85dbc3c9009256f595" title="The wake counter reset value.">PxSceneDesc.wakeCounterResetValue</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ac3d1c6430df6046857b9c1b3e747cd59">physx::PxScene</a>.</p>

</div>
</div>
<a id="aaa9d0cf0d3f68b0ce1b1f790783e4dfe" name="aaa9d0cf0d3f68b0ce1b1f790783e4dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9d0cf0d3f68b0ce1b1f790783e4dfe">&#9670;&#160;</a></span>lockRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::lockRead </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the scene for reading from the calling thread. </p>
<p>When the <a class="el" href="structphysx_1_1_px_scene_flag.html#a1a7984bb50590b1a2ce5ca5fe6469e50af5964a5a8ac1a41c2ce226e535bba0e0" title="Require scene-level locking.">PxSceneFlag::eREQUIRE_RW_LOCK</a> flag is enabled <a class="el" href="classphysx_1_1_np_scene.html#aaa9d0cf0d3f68b0ce1b1f790783e4dfe" title="Lock the scene for reading from the calling thread.">lockRead()</a> must be called before any read calls are made on the scene.</p>
<p>Multiple threads may read at the same time, no threads may read while a thread is writing. If a call to <a class="el" href="classphysx_1_1_np_scene.html#aaa9d0cf0d3f68b0ce1b1f790783e4dfe" title="Lock the scene for reading from the calling thread.">lockRead()</a> is made while another thread is holding a write lock then the calling thread will be blocked until the writing thread calls <a class="el" href="classphysx_1_1_np_scene.html#ab63a6471e862677ab570a6db395cfd6b" title="Unlock the scene from writing.">unlockWrite()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Lock upgrading is <em>not</em> supported, that means it is an error to call <a class="el" href="classphysx_1_1_np_scene.html#aaa9d0cf0d3f68b0ce1b1f790783e4dfe" title="Lock the scene for reading from the calling thread.">lockRead()</a> followed by <a class="el" href="classphysx_1_1_np_scene.html#a89177e9e4be212c2e15e0b3d03063013" title="Lock the scene for writing from this thread.">lockWrite()</a>.</dd>
<dd>
Recursive locking is supported but each <a class="el" href="classphysx_1_1_np_scene.html#aaa9d0cf0d3f68b0ce1b1f790783e4dfe" title="Lock the scene for reading from the calling thread.">lockRead()</a> call must be paired with an <a class="el" href="classphysx_1_1_np_scene.html#ab3b41d59d5df44ec8a9b78bcf00f4a05" title="Unlock the scene from reading.">unlockRead()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>String representing the calling file, for debug purposes </td></tr>
    <tr><td class="paramname">line</td><td>The source file line number, for debug purposes </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#af0ab3ed85d4e3bf26254b153eb8429f4">physx::PxScene</a>.</p>

</div>
</div>
<a id="a89177e9e4be212c2e15e0b3d03063013" name="a89177e9e4be212c2e15e0b3d03063013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89177e9e4be212c2e15e0b3d03063013">&#9670;&#160;</a></span>lockWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::lockWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>line</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the scene for writing from this thread. </p>
<p>When the <a class="el" href="structphysx_1_1_px_scene_flag.html#a1a7984bb50590b1a2ce5ca5fe6469e50af5964a5a8ac1a41c2ce226e535bba0e0" title="Require scene-level locking.">PxSceneFlag::eREQUIRE_RW_LOCK</a> flag is enabled <a class="el" href="classphysx_1_1_np_scene.html#a89177e9e4be212c2e15e0b3d03063013" title="Lock the scene for writing from this thread.">lockWrite()</a> must be called before any write calls are made on the scene.</p>
<p>Only one thread may write at a time and no threads may read while a thread is writing. If a call to <a class="el" href="classphysx_1_1_np_scene.html#a89177e9e4be212c2e15e0b3d03063013" title="Lock the scene for writing from this thread.">lockWrite()</a> is made and there are other threads reading then the calling thread will be blocked until the readers complete.</p>
<p>Writers have priority. If a thread is blocked waiting to write then subsequent calls to <a class="el" href="classphysx_1_1_np_scene.html#aaa9d0cf0d3f68b0ce1b1f790783e4dfe" title="Lock the scene for reading from the calling thread.">lockRead()</a> from other threads will be blocked until the writer completes.</p>
<dl class="section note"><dt>Note</dt><dd>If multiple threads are waiting to write then the thread that is first granted access depends on OS scheduling.</dd>
<dd>
Recursive locking is supported but each <a class="el" href="classphysx_1_1_np_scene.html#a89177e9e4be212c2e15e0b3d03063013" title="Lock the scene for writing from this thread.">lockWrite()</a> call must be paired with an <a class="el" href="classphysx_1_1_np_scene.html#ab63a6471e862677ab570a6db395cfd6b" title="Unlock the scene from writing.">unlockWrite()</a>. <br  />
</dd>
<dd>
If a thread has already locked the scene for writing then it may call <a class="el" href="classphysx_1_1_np_scene.html#aaa9d0cf0d3f68b0ce1b1f790783e4dfe" title="Lock the scene for reading from the calling thread.">lockRead()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>String representing the calling file, for debug purposes </td></tr>
    <tr><td class="paramname">line</td><td>The source file line number, for debug purposes </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ae3abb67fa040b0218438f904caad4972">physx::PxScene</a>.</p>

</div>
</div>
<a id="a705475136b9d2df3b18b12924b347a7b" name="a705475136b9d2df3b18b12924b347a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705475136b9d2df3b18b12924b347a7b">&#9670;&#160;</a></span>overlap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_geometry.html">PxGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#ab1f519b85cba7aabc47ebaf00c505ada">PxOverlapCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;&#160;</td>
          <td class="paramname"><em>filterData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_query_filter_callback.html">PxQueryFilterCallback</a> *&#160;</td>
          <td class="paramname"><em>filterCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxGeometryQueryFlags&#160;</td>
          <td class="paramname"><em>queryFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an overlap test of a given geometry against objects in the scene, returns results in a PxOverlapBuffer object or via a custom user callback implementation inheriting from PxOverlapCallback. </p>
<dl class="section note"><dt>Note</dt><dd>Filtering: returning eBLOCK from user filter for overlap queries will cause a warning (see #PxQueryHitType).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry</td><td>Geometry of object to check for overlap (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Pose of the object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitCall</td><td>Overlap hit buffer or callback object used to report overlap hits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>Filtering data and simple logic. See #PxQueryFilterData #PxQueryFilterCallback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterCall</td><td>Custom filtering logic (optional). Only used if the corresponding #PxQueryFlag flags are set. If NULL, all hits are assumed to overlap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>Cached hit shape (optional). Overlap is performed against cached shape first. If no hit is found the overlap gets queried against the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queryFlags</td><td>Optional flags controlling the query. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. Note: Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any touching or blocking hits were found or any hit was found in case <a class="el" href="structphysx_1_1_px_query_flag.html#ab6f2a73622dd9c61562681e70cc8f29faba424ffb6f34ac4fc135b57b586fefb8">PxQueryFlag::eANY_HIT</a> was specified.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>eBLOCK should not be returned from user filters for <a class="el" href="classphysx_1_1_np_scene.html#a705475136b9d2df3b18b12924b347a7b" title="Performs an overlap test of a given geometry against objects in the scene, returns results in a PxOve...">overlap()</a>. Doing so will result in undefined behavior, and a warning will be issued. </dd>
<dd>
If the <a class="el" href="structphysx_1_1_px_query_flag.html#ab6f2a73622dd9c61562681e70cc8f29fa2a227527dc26b74469504e99e6c704a4">PxQueryFlag::eNO_BLOCK</a> flag is set, the eBLOCK will instead be automatically converted to an eTOUCH and the warning suppressed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacephysx.html#ab1f519b85cba7aabc47ebaf00c505ada" title="Overlap query callback.">PxOverlapCallback</a> <a class="el" href="namespacephysx.html#a9af52a9fe9935b3aeca4d1aa6c72246f" title="Overlap query buffer.">PxOverlapBuffer</a> PxHitFlags <a class="el" href="structphysx_1_1_px_query_filter_data.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classphysx_1_1_px_query_filter_callback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> <a class="el" href="structphysx_1_1_px_geometry_query_flag.html" title="Geometry-level query flags.">PxGeometryQueryFlag</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_query_system_base.html#a0785f99c74b3156ba1663ca232ceafaa">physx::PxSceneQuerySystemBase</a>.</p>

</div>
</div>
<a id="a09f2765833fdfa739d68c687a97f807a" name="a09f2765833fdfa739d68c687a97f807a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f2765833fdfa739d68c687a97f807a">&#9670;&#160;</a></span>processCallbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::processCallbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_base_task.html">physx::PxBaseTask</a> *&#160;</td>
          <td class="paramname"><em>continuation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This call processes all event callbacks in parallel. It takes a continuation task, which will be executed once all callbacks have been processed.</p>
<p>This is a utility function to make it easier to process callbacks in parallel using the PhysX task system. It can only be used in conjunction with fetchResultsStart(...) and fetchResultsFinish(...)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">continuation</td><td>The task that will be executed once all callbacks have been processed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a2e7640233402b4cce09968519251bffd">physx::PxScene</a>.</p>

</div>
</div>
<a id="aaeac119625abbdfc4ff70b36e2f612d8" name="aaeac119625abbdfc4ff70b36e2f612d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeac119625abbdfc4ff70b36e2f612d8">&#9670;&#160;</a></span>raycast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::raycast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#ac822ad888817f5b13417799d9161470c">PxRaycastCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&#160;</td>
          <td class="paramname"><em>hitFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;&#160;</td>
          <td class="paramname"><em>filterData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_query_filter_callback.html">PxQueryFilterCallback</a> *&#160;</td>
          <td class="paramname"><em>filterCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxGeometryQueryFlags&#160;</td>
          <td class="paramname"><em>queryFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a raycast against objects in the scene, returns results in a PxRaycastBuffer object or via a custom user callback implementation inheriting from PxRaycastCallback. </p>
<dl class="section note"><dt>Note</dt><dd>Touching hits are not ordered. </dd>
<dd>
Shooting a ray from within an object leads to different results depending on the shape type. Please check the details in user guide article SceneQuery. User can ignore such objects by employing one of the provided filter mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Origin of the ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Normalized direction of the ray. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Length of the ray. Has to be in the [0, inf) range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitCall</td><td>Raycast hit buffer or callback object used to report raycast hits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hitFlags</td><td>Specifies which properties per hit should be computed and returned via the hit callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>Filtering data passed to the filter shader. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterCall</td><td>Custom filtering logic (optional). Only used if the corresponding #PxQueryFlag flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>Cached hit shape (optional). Ray is tested against cached shape first. If no hit is found the ray gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. Note: Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queryFlags</td><td>Optional flags controlling the query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any touching or blocking hits were found or any hit was found in case <a class="el" href="structphysx_1_1_px_query_flag.html#ab6f2a73622dd9c61562681e70cc8f29faba424ffb6f34ac4fc135b57b586fefb8">PxQueryFlag::eANY_HIT</a> was specified.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacephysx.html#ac822ad888817f5b13417799d9161470c" title="Raycast query callback.">PxRaycastCallback</a> <a class="el" href="namespacephysx.html#aadaf816b0479200a97713e1dda8744d6" title="Raycast query buffer.">PxRaycastBuffer</a> <a class="el" href="structphysx_1_1_px_query_filter_data.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classphysx_1_1_px_query_filter_callback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> <a class="el" href="structphysx_1_1_px_query_cache.html" title="single hit cache for scene queries.">PxQueryCache</a> <a class="el" href="structphysx_1_1_px_raycast_hit.html">PxRaycastHit</a> <a class="el" href="structphysx_1_1_px_query_flag.html" title="Filtering flags for scene queries.">PxQueryFlag</a> <a class="el" href="structphysx_1_1_px_query_flag.html#ab6f2a73622dd9c61562681e70cc8f29faba424ffb6f34ac4fc135b57b586fefb8">PxQueryFlag::eANY_HIT</a> <a class="el" href="structphysx_1_1_px_geometry_query_flag.html" title="Geometry-level query flags.">PxGeometryQueryFlag</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_query_system_base.html#aa4a98b67c46760079ddf45416e1fd007">physx::PxSceneQuerySystemBase</a>.</p>

</div>
</div>
<a id="abdf9aafe76d85dc5608e569376df2eb6" name="abdf9aafe76d85dc5608e569376df2eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf9aafe76d85dc5608e569376df2eb6">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the scene. </p>
<p>Removes any actors and constraint shaders from this scene (if the user hasn't already done so).</p>
<p>Be sure to not keep a reference to this object after calling release. Avoid release calls while the scene is simulating (in between <a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a> and <a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a> calls).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_physics.html#a54223c8797310c90a187f4c7f1637d4c" title="Creates a scene.">PxPhysics.createScene()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ae339d16d3cd0240a2bd794b0acf56c99">physx::PxScene</a>.</p>

</div>
</div>
<a id="a6df7359e59642397e0b20d900688226c" name="a6df7359e59642397e0b20d900688226c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df7359e59642397e0b20d900688226c">&#9670;&#160;</a></span>removeActor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::removeActor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wakeOnLostTouch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an actor from this scene. </p>
<dl class="section note"><dt>Note</dt><dd>If the actor is not part of this scene (see <a class="el" href="classphysx_1_1_px_actor.html#a002cfb766d7d8aa71f174980fe7b1c6b" title="Retrieves the scene which this actor belongs to.">PxActor::getScene</a>), the call is ignored and an error is issued.</dd>
<dd>
You can not remove individual articulation links (see #PxArticulationLink) from the scene. Use <a class="el" href="classphysx_1_1_np_scene.html#afa5afb6860bbbac51c7e2f2f78c09d54" title="Removes an articulation from this scene.">removeArticulation()</a> instead.</dd>
<dd>
If the actor is a <a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> then all assigned <a class="el" href="classphysx_1_1_px_constraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> objects will get removed from the scene automatically.</dd>
<dd>
If the actor is in an aggregate it will be removed from the aggregate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>Actor to remove from scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeOnLostTouch</td><td>Specifies whether touching objects from the previous frame should get woken up in the next frame. Only applies to <a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html" title="A tree structure of bodies connected by joints that is treated as a unit by the dynamics solver....">PxArticulationReducedCoordinate</a> and <a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a>, <a class="el" href="classphysx_1_1_px_aggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a5552e34ffb3aa4c115cd7c239ab99e66">physx::PxScene</a>.</p>

</div>
</div>
<a id="aebc80373596abbe5469ea1dd7a8955fd" name="aebc80373596abbe5469ea1dd7a8955fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc80373596abbe5469ea1dd7a8955fd">&#9670;&#160;</a></span>removeActors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::removeActors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> *const *&#160;</td>
          <td class="paramname"><em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>nbActors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wakeOnLostTouch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes actors from this scene. Only supports actors of type <a class="el" href="classphysx_1_1_px_rigid_static.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK.">PxRigidStatic</a> and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This method only supports actors of type <a class="el" href="classphysx_1_1_px_rigid_static.html" title="PxRigidStatic represents a static rigid body simulation object in the physics SDK.">PxRigidStatic</a> and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>. For other actors, use <a class="el" href="classphysx_1_1_np_scene.html#a6df7359e59642397e0b20d900688226c" title="Removes an actor from this scene.">removeActor()</a> instead. For articulation links, use <a class="el" href="classphysx_1_1_np_scene.html#afa5afb6860bbbac51c7e2f2f78c09d54" title="Removes an articulation from this scene.">removeArticulation()</a>.</dd>
<dd>
If some actor is not part of this scene (see <a class="el" href="classphysx_1_1_px_actor.html#a002cfb766d7d8aa71f174980fe7b1c6b" title="Retrieves the scene which this actor belongs to.">PxActor::getScene</a>), the actor remove is ignored and an error is issued.</dd>
<dd>
You can not remove individual articulation links (see #PxArticulationLink) from the scene. Use <a class="el" href="classphysx_1_1_np_scene.html#afa5afb6860bbbac51c7e2f2f78c09d54" title="Removes an articulation from this scene.">removeArticulation()</a> instead.</dd>
<dd>
If the actor is a <a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> then all assigned <a class="el" href="classphysx_1_1_px_constraint.html" title="A plugin class for implementing constraints.">PxConstraint</a> objects will get removed from the scene automatically.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actors</td><td>Array of actors to add to scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nbActors</td><td>Number of actors in the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeOnLostTouch</td><td>Specifies whether touching objects from the previous frame should get woken up in the next frame. Only applies to PxArticulationReducedCooridnate and <a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a2029554978d1d223d6897c603bab7744">physx::PxScene</a>.</p>

</div>
</div>
<a id="a42641d6f1b646a03bf5f716296696fd2" name="a42641d6f1b646a03bf5f716296696fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42641d6f1b646a03bf5f716296696fd2">&#9670;&#160;</a></span>removeAggregate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::removeAggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> &amp;&#160;</td>
          <td class="paramname"><em>aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wakeOnLostTouch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an aggregate from this scene. </p>
<dl class="section note"><dt>Note</dt><dd>If the aggregate is not part of this scene (see <a class="el" href="classphysx_1_1_px_aggregate.html#a4cb67c7f94b6b36778fe418cdfcc1c6c" title="Retrieves the scene which this aggregate belongs to.">PxAggregate::getScene</a>), the call is ignored and an error is issued.</dd>
<dd>
If the aggregate contains actors, those actors are removed from the scene as well.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aggregate</td><td>Aggregate to remove from scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeOnLostTouch</td><td>Specifies whether touching objects from the previous frame should get woken up in the next frame. Only applies to <a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html" title="A tree structure of bodies connected by joints that is treated as a unit by the dynamics solver....">PxArticulationReducedCoordinate</a> and <a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_aggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a650581cd20d04db4a3a870f2eef67340">physx::PxScene</a>.</p>

</div>
</div>
<a id="afa5afb6860bbbac51c7e2f2f78c09d54" name="afa5afb6860bbbac51c7e2f2f78c09d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5afb6860bbbac51c7e2f2f78c09d54">&#9670;&#160;</a></span>removeArticulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::removeArticulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> &amp;&#160;</td>
          <td class="paramname"><em>articulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wakeOnLostTouch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an articulation from this scene. </p>
<dl class="section note"><dt>Note</dt><dd>If the articulation is not part of this scene (see <a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html#a2e9206aa9afa5b7d543816362e1067f4" title="Returns the scene which this articulation belongs to.">PxArticulationReducedCoordinate::getScene</a>), the call is ignored and an error is issued.</dd>
<dd>
If the articulation is in an aggregate it will be removed from the aggregate.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">articulation</td><td>The articulation to remove from the scene. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeOnLostTouch</td><td>Specifies whether touching objects from the previous frame should get woken up in the next frame. Only applies to <a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html" title="A tree structure of bodies connected by joints that is treated as a unit by the dynamics solver....">PxArticulationReducedCoordinate</a> and <a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html" title="A tree structure of bodies connected by joints that is treated as a unit by the dynamics solver....">PxArticulationReducedCoordinate</a>, <a class="el" href="classphysx_1_1_px_aggregate.html" title="Class to aggregate actors into a single broad-phase entry.">PxAggregate</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a36f708123587df24eee50e5a6c81a33a">physx::PxScene</a>.</p>

</div>
</div>
<a id="aba64c4f7b78676a6c8e5098402225ed5" name="aba64c4f7b78676a6c8e5098402225ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba64c4f7b78676a6c8e5098402225ed5">&#9670;&#160;</a></span>removeArticulationInternal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::removeArticulationInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_articulation_reduced_coordinate.html">PxArticulationReducedCoordinate</a> &amp;&#160;</td>
          <td class="paramname"><em>pxa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wakeOnLostTouch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeFromAggregate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>!!AL</p>

</div>
</div>
<a id="a8841de685cd0becffac6f67840b26da8" name="a8841de685cd0becffac6f67840b26da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8841de685cd0becffac6f67840b26da8">&#9670;&#160;</a></span>removeBroadPhaseRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::removeBroadPhaseRegion </td>
          <td>(</td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a new broad-phase region. </p>
<p>If the region still contains objects, and if those objects do not overlap any region any more, they are not automatically removed from the simulation. Instead, the <a class="el" href="classphysx_1_1_px_broad_phase_callback.html#a53ecb1147d971fd6a3c85f697ffde632" title="Out-of-bounds notification.">PxBroadPhaseCallback::onObjectOutOfBounds</a> notification is used for each object. Users are responsible for removing the objects from the simulation if this is the desired behavior.</p>
<p>If the handle is invalid, or if a valid handle is removed twice, an error message is sent to the error stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Region's handle, as returned by <a class="el" href="classphysx_1_1_px_scene.html#ae315e6a672ac6b4980d876b40f390e47" title="Adds a new broad-phase region.">PxScene::addBroadPhaseRegion</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a70a7ec2d65a8606ea8f16a375b6ea4e4">physx::PxScene</a>.</p>

</div>
</div>
<a id="abbcd29a20d673677b2ae2994db915fda" name="abbcd29a20d673677b2ae2994db915fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcd29a20d673677b2ae2994db915fda">&#9670;&#160;</a></span>resetFiltering() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::resetFiltering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;&#160;</td>
          <td class="paramname"><em>actor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the object to reset interactions and re-run collision filters in the next simulation step. </p>
<p>This call forces the object to remove all existing collision interactions, to search anew for existing contact pairs and to run the collision filters again for found collision pairs.</p>
<dl class="section note"><dt>Note</dt><dd>The operation is supported for <a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> objects only.</dd>
<dd>
All persistent state of existing interactions will be lost and can not be retrieved even if the same collison pair is found again in the next step. This will mean, for example, that you will not get notified about persistent contact for such an interaction (see <a class="el" href="structphysx_1_1_px_pair_flag.html#aacf32df5e523495c6b7dc8878f43d96caa59e917536b8be0b4c1d16498c8f27d5" title="Call contact report callback while this collision pair is in contact.">PxPairFlag::eNOTIFY_TOUCH_PERSISTS</a>), the contact pair will be interpreted as newly found instead.</dd>
<dd>
Lost touch contact reports will be sent for every collision pair which includes this shape, if they have been requested through <a class="el" href="structphysx_1_1_px_pair_flag.html#aacf32df5e523495c6b7dc8878f43d96ca4783d1101801f0336a1055edf691a217" title="Call contact report callback or trigger callback when this collision pair stops to be in contact.">PxPairFlag::eNOTIFY_TOUCH_LOST</a> or <a class="el" href="structphysx_1_1_px_pair_flag.html#aacf32df5e523495c6b7dc8878f43d96ca4028d6f689dd5dc0b7c24a62287006cd" title="Call contact report callback when the contact force between the actors of this collision pair falls b...">PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST</a>.</dd>
<dd>
This is an expensive operation, don't use it if you don't have to.</dd>
<dd>
Can be used to retrieve collision pairs that were killed by the collision filters (see <a class="el" href="structphysx_1_1_px_filter_flag.html#ab4b1cffaafe45818dbb75fc31e79377ca227d7b60b2bc3856a93880f599df386c" title="Ignore the collision pair as long as the bounding volumes of the pair objects overlap.">PxFilterFlag::eKILL</a>)</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already.</dd>
<dd>
It is invalid to use this method if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd>
<dd>
Do not use this method while the simulation is running.</dd></dl>
<p><b>Sleeping:</b> Does wake up the actor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The actor for which to re-evaluate interactions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacephysx.html#a7d989364d9339d1946b69ec9432f36ae" title="Filter method to specify how a pair of potentially colliding objects should be processed.">PxSimulationFilterShader</a> <a class="el" href="classphysx_1_1_px_simulation_filter_callback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a334ab8653c2c734822bbf69229bf500d">physx::PxScene</a>.</p>

</div>
</div>
<a id="a937195856f655e0eee5be694d19002e1" name="a937195856f655e0eee5be694d19002e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937195856f655e0eee5be694d19002e1">&#9670;&#160;</a></span>resetFiltering() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::resetFiltering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> &amp;&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> *const *&#160;</td>
          <td class="paramname"><em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>shapeCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the object to reset interactions and re-run collision filters for specified shapes in the next simulation step. </p>
<p>This is a specialization of the <a class="el" href="classphysx_1_1_np_scene.html#abbcd29a20d673677b2ae2994db915fda" title="Marks the object to reset interactions and re-run collision filters in the next simulation step.">resetFiltering(PxActor&amp; actor)</a> method and allows to reset interactions for specific shapes of a <a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<p><b>Sleeping:</b> Does wake up the actor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The actor for which to re-evaluate interactions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shapes</td><td>The shapes for which to re-evaluate interactions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shapeCount</td><td>Number of shapes in the list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacephysx.html#a7d989364d9339d1946b69ec9432f36ae" title="Filter method to specify how a pair of potentially colliding objects should be processed.">PxSimulationFilterShader</a> <a class="el" href="classphysx_1_1_px_simulation_filter_callback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a9e40486bbcbbdf4e7c205d8e94c506e3">physx::PxScene</a>.</p>

</div>
</div>
<a id="a2af0a1f6951c3ff59a21c0689405f450" name="a2af0a1f6951c3ff59a21c0689405f450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af0a1f6951c3ff59a21c0689405f450">&#9670;&#160;</a></span>sceneQueriesUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::sceneQueriesUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_base_task.html">physx::PxBaseTask</a> *&#160;</td>
          <td class="paramname"><em>completionTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>controlSimulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes scene queries update tasks. </p>
<p>This function will refit dirty shapes within the pruner and will execute a task to build a new AABB tree, which is build on a different thread. The new AABB tree is built based on the dynamic tree rebuild hint rate. Once the new tree is ready it will be commited in next fetchQueries call, which must be called after.</p>
<p>This function is equivalent to the following <a class="el" href="classphysx_1_1_px_scene_query_system.html" title="Scene-queries external sub-system for PxScene-based objects.">PxSceneQuerySystem</a> calls: Synchronous calls:</p><ul>
<li><a class="el" href="classphysx_1_1_px_scene_query_system_base.html#ad61d17a6a620b2725a4b5693fb974fa0" title="Flushes any changes to the scene query representation.">PxSceneQuerySystemBase::flushUpdates()</a></li>
<li>handle0 = PxSceneQuerySystem::prepareSceneQueryBuildStep(PX_SCENE_PRUNER_STATIC)</li>
<li>handle1 = PxSceneQuerySystem::prepareSceneQueryBuildStep(PX_SCENE_PRUNER_DYNAMIC) Asynchronous calls:</li>
<li>PxSceneQuerySystem::sceneQueryBuildStep(handle0);</li>
<li>PxSceneQuerySystem::sceneQueryBuildStep(handle1);</li>
</ul>
<p>This function is part of the <a class="el" href="classphysx_1_1_px_scene_s_q_system.html" title="Traditional SQ system for PxScene.">PxSceneSQSystem</a> interface because it uses the <a class="el" href="classphysx_1_1_px_scene.html" title="A scene is a collection of bodies and constraints which can interact.">PxScene</a> task system under the hood. But it calls <a class="el" href="classphysx_1_1_px_scene_query_system.html" title="Scene-queries external sub-system for PxScene-based objects.">PxSceneQuerySystem</a> functions, which are independent from this system and could be called in a similar fashion by a separate, possibly user-defined task manager.</p>
<dl class="section note"><dt>Note</dt><dd>If <a class="el" href="structphysx_1_1_px_scene_query_update_mode.html#a3d0e848308f503deeb42f966e9fcb99fa3dbc73ed495d8c174ec99a4c6755fb95" title="No work is done, no update of scene queries.">PxSceneQueryUpdateMode::eBUILD_DISABLED_COMMIT_DISABLED</a> is used, it is required to update the scene queries using this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">completionTask</td><td>if non-NULL, this task will have its refcount incremented in sceneQueryUpdate(), then decremented when the scene is ready to have fetchQueries called. So the task will not run until the application also calls removeReference(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controlSimulation</td><td>if true, the scene controls its <a class="el" href="classphysx_1_1_px_task_manager.html" title="The PxTaskManager interface.">PxTaskManager</a> simulation state. Leave true unless the application is calling the <a class="el" href="classphysx_1_1_px_task_manager.html" title="The PxTaskManager interface.">PxTaskManager</a> start/stopSimulation() methods itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_scene_query_update_mode.html#a3d0e848308f503deeb42f966e9fcb99fa3dbc73ed495d8c174ec99a4c6755fb95" title="No work is done, no update of scene queries.">PxSceneQueryUpdateMode::eBUILD_DISABLED_COMMIT_DISABLED</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_s_q_system.html#af17e9bb8012ab09f2f6d3f50959efd7a">physx::PxSceneSQSystem</a>.</p>

</div>
</div>
<a id="a4a6a5b35350e638ad26fcb195bb0f565" name="a4a6a5b35350e638ad26fcb195bb0f565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6a5b35350e638ad26fcb195bb0f565">&#9670;&#160;</a></span>setActiveActors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setActiveActors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> **&#160;</td>
          <td class="paramname"><em>actors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>nbActors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classphysx_1_1_np_scene_accessor.html">physx::NpSceneAccessor</a>.</p>

</div>
</div>
<a id="ace3655560e5dac5ba7c3977d67ddb3df" name="ace3655560e5dac5ba7c3977d67ddb3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3655560e5dac5ba7c3977d67ddb3df">&#9670;&#160;</a></span>setBounceThresholdVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setBounceThresholdVelocity </td>
          <td>(</td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the bounce threshold velocity. Collision speeds below this threshold will not cause a bounce. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#aad54d9d20e485740a84a7bbfffdefe11" title="A contact with a relative velocity below this will not bounce. A typical value for simulation....">PxSceneDesc::bounceThresholdVelocity</a>, <a class="el" href="classphysx_1_1_np_scene.html#a6cddad2ad26773e073d27b61e7749ebd" title="Return the bounce threshold velocity.">getBounceThresholdVelocity</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a1eef025b5643b4d59922df35a7b648dc">physx::PxScene</a>.</p>

</div>
</div>
<a id="a9f115b6be26fd492c312a032e6096f1f" name="a9f115b6be26fd492c312a032e6096f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f115b6be26fd492c312a032e6096f1f">&#9670;&#160;</a></span>setBroadPhaseCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setBroadPhaseCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_broad_phase_callback.html">PxBroadPhaseCallback</a> *&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a broad-phase user callback object. </p>
<dl class="section note"><dt>Note</dt><dd>Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Asynchronous broad-phase callback. See #PxBroadPhaseCallback. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a9984b6c609963bcf0a828b101ca95105">physx::PxScene</a>.</p>

</div>
</div>
<a id="a550ed2822765595bfaed32dd0bc0602f" name="a550ed2822765595bfaed32dd0bc0602f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550ed2822765595bfaed32dd0bc0602f">&#9670;&#160;</a></span>setCCDContactModifyCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setCCDContactModifyCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_c_c_d_contact_modify_callback.html">PxCCDContactModifyCallback</a> *&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a user callback object, which receives callbacks on all CCD contacts generated for specified actors. </p>
<dl class="section note"><dt>Note</dt><dd>Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Asynchronous user contact modification callback. See #PxCCDContactModifyCallback. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a41ec5c3a9f5ab221e2137522ba9d6091">physx::PxScene</a>.</p>

</div>
</div>
<a id="a29a7ada27b5045396732671746f3f598" name="a29a7ada27b5045396732671746f3f598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a7ada27b5045396732671746f3f598">&#9670;&#160;</a></span>setCCDMaxPasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setCCDMaxPasses </td>
          <td>(</td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>ccdMaxPasses</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum number of CCD passes. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ccdMaxPasses</td><td>Maximum number of CCD passes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a735fcf1c8af0365502ddac996b0e196d" title="Maximum number of CCD passes.">PxSceneDesc.ccdMaxPasses</a> <a class="el" href="classphysx_1_1_np_scene.html#a5316908b5bfa5dab28df9d5bcab07021" title="Gets the maximum number of CCD passes.">getCCDMaxPasses()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a5204296318db64954809879d013d921d">physx::PxScene</a>.</p>

</div>
</div>
<a id="a3b5d78bc2221c7221b50ad6914fb3e5b" name="a3b5d78bc2221c7221b50ad6914fb3e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5d78bc2221c7221b50ad6914fb3e5b">&#9670;&#160;</a></span>setCCDMaxSeparation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setCCDMaxSeparation </td>
          <td>(</td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum CCD separation. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#aea10c3fc8a745d51ae69e7b4fb330609" title="A threshold for speculative CCD. Used to control whether bias, restitution or a combination of the tw...">PxSceneDesc::ccdMaxSeparation</a>, <a class="el" href="classphysx_1_1_np_scene.html#a3787f0da131b268dbc6918a4d10e402d" title="Gets the maximum CCD separation.">getCCDMaxSeparation</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#abdd86bae6fbe3d83f89078cad0e8d27d">physx::PxScene</a>.</p>

</div>
</div>
<a id="aef2d2dee68ffeec00fe92516acffa355" name="aef2d2dee68ffeec00fe92516acffa355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2d2dee68ffeec00fe92516acffa355">&#9670;&#160;</a></span>setCCDThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setCCDThreshold </td>
          <td>(</td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the CCD threshold. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a2e5a82176b6a253d4efdca970594dcc5" title="CCD threshold.">PxSceneDesc::ccdThreshold</a>, <a class="el" href="classphysx_1_1_np_scene.html#a496ec70c2fa7e1219070747aa1f6628b" title="Gets the CCD threshold.">getCCDThreshold</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a7c81055ecf5524b082ca0fb80dd6ce45">physx::PxScene</a>.</p>

</div>
</div>
<a id="a6a394872deaa7dbd44d6240bd8e8dafc" name="a6a394872deaa7dbd44d6240bd8e8dafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a394872deaa7dbd44d6240bd8e8dafc">&#9670;&#160;</a></span>setContactModifyCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setContactModifyCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_contact_modify_callback.html">PxContactModifyCallback</a> *&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a user callback object, which receives callbacks on all contacts generated for specified actors. </p>
<dl class="section note"><dt>Note</dt><dd>Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Asynchronous user contact modification callback. See #PxContactModifyCallback. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a405c6c2f9cd63835b2d541ebdd4918f2">physx::PxScene</a>.</p>

</div>
</div>
<a id="ab5ff3fbd073192ed9998b632bf503715" name="ab5ff3fbd073192ed9998b632bf503715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ff3fbd073192ed9998b632bf503715">&#9670;&#160;</a></span>setDominanceGroupPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setDominanceGroupPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a>&#160;</td>
          <td class="paramname"><em>group1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a>&#160;</td>
          <td class="paramname"><em>group2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_dominance_group_pair.html">PxDominanceGroupPair</a> &amp;&#160;</td>
          <td class="paramname"><em>dominance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the dominance behavior of contacts between two actors with two certain dominance groups. </p>
<p>It is possible to assign each actor to a dominance groups using <a class="el" href="classphysx_1_1_px_actor.html#a3786b0f53c9a37074372d0ea62ce348d" title="Assigns dynamic actors a dominance group identifier.">PxActor::setDominanceGroup()</a>.</p>
<p>With dominance groups one can have all contacts created between actors act in one direction only. This is useful, for example, if you want an object to push debris out of its way and be unaffected,while still responding physically to forces and collisions with non-debris objects.</p>
<p>Whenever a contact between two actors (a0, a1) needs to be solved, the groups (g0, g1) of both actors are retrieved. Then the <a class="el" href="structphysx_1_1_px_dominance_group_pair.html" title="Expresses the dominance relationship of a contact. For the time being only three settings are permitt...">PxDominanceGroupPair</a> setting for this group pair is retrieved with getDominanceGroupPair(g0, g1).</p>
<p>In the contact, PxDominanceGroupPair::dominance0 becomes the dominance setting for a0, and PxDominanceGroupPair::dominance1 becomes the dominance setting for a1. A dominanceN setting of 1.0f, the default, will permit aN to be pushed or pulled by a(1-N) through the contact. A dominanceN setting of 0.0f, will however prevent aN to be pushed by a(1-N) via the contact. Thus, a <a class="el" href="structphysx_1_1_px_dominance_group_pair.html" title="Expresses the dominance relationship of a contact. For the time being only three settings are permitt...">PxDominanceGroupPair</a> of (1.0f, 0.0f) makes the interaction one-way.</p>
<p>The matrix sampled by getDominanceGroupPair(g1, g2) is initialised by default such that:</p>
<p>if g1 == g2, then (1.0f, 1.0f) is returned if g1 &lt; g2, then (0.0f, 1.0f) is returned if g1 &gt; g2, then (1.0f, 0.0f) is returned</p>
<p>In other words, we permit actors in higher groups to be pushed around by actors in lower groups by default.</p>
<p>These settings should cover most applications, and in fact not overriding these settings may likely result in higher performance.</p>
<p>It is not possible to make the matrix asymetric, or to change the diagonal. In other words:</p>
<p>it is not possible to change (g1, g2) if (g1==g2) if you set</p>
<p>(g1, g2) to X, then (g2, g1) will implicitly and automatically be set to ~X, where:</p>
<p>~(1.0f, 1.0f) is (1.0f, 1.0f) ~(0.0f, 1.0f) is (1.0f, 0.0f) ~(1.0f, 0.0f) is (0.0f, 1.0f)</p>
<p>These two restrictions are to make sure that contacts between two actors will always evaluate to the same dominance setting, regardless of the order of the actors.</p>
<p>Dominance settings are currently specified as floats 0.0f or 1.0f because in the future we may permit arbitrary fractional settings to express 'partly-one-way' interactions.</p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake actors up automatically.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#a716d215dfdc868843a1b38ed24c944dd" title="Samples the dominance matrix.">getDominanceGroupPair()</a> <a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e" title="Group index which allows to specify 1- or 2-way interaction.">PxDominanceGroup</a> <a class="el" href="structphysx_1_1_px_dominance_group_pair.html" title="Expresses the dominance relationship of a contact. For the time being only three settings are permitt...">PxDominanceGroupPair</a> <a class="el" href="classphysx_1_1_px_actor.html#a3786b0f53c9a37074372d0ea62ce348d" title="Assigns dynamic actors a dominance group identifier.">PxActor::setDominanceGroup()</a> <a class="el" href="classphysx_1_1_px_actor.html#a4b7effc9b077780ffd713baa8869feae" title="Retrieves the value set with setDominanceGroup().">PxActor::getDominanceGroup()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a821e125c4ac3890166851dee8b6ca30e">physx::PxScene</a>.</p>

</div>
</div>
<a id="abbac7601df289d7b6f2d04a9caa1b059" name="abbac7601df289d7b6f2d04a9caa1b059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbac7601df289d7b6f2d04a9caa1b059">&#9670;&#160;</a></span>setDynamicTreeRebuildRateHint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setDynamicTreeRebuildRateHint </td>
          <td>(</td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>dynamicTreeRebuildRateHint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the rebuild rate of the dynamic tree pruning structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dynamicTreeRebuildRateHint</td><td>Rebuild rate of the dynamic tree pruning structures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_query_desc.html#aa9b4f3adb72c59a63e19c09e0c110ab6" title="Hint for how much work should be done per simulation frame to rebuild the pruning structures.">PxSceneQueryDesc.dynamicTreeRebuildRateHint</a> <a class="el" href="classphysx_1_1_np_scene.html#a4895ebc7606b70bff52c29bca6bfaacc" title="Retrieves the rebuild rate of the dynamic tree pruning structures.">getDynamicTreeRebuildRateHint()</a> <a class="el" href="classphysx_1_1_np_scene.html#af43306bf149c77bffadc54bfbb99c17e" title="Forces dynamic trees to be immediately rebuilt.">forceRebuildDynamicTree()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_query_system_base.html#aa6b603df89b7794fa533e02d8a5a5c80">physx::PxSceneQuerySystemBase</a>.</p>

</div>
</div>
<a id="a662fed3a64c14045f3df4e833ded9a58" name="a662fed3a64c14045f3df4e833ded9a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662fed3a64c14045f3df4e833ded9a58">&#9670;&#160;</a></span>setFilterShaderData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setFilterShaderData </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the shared global filter data which will get passed into the filter shader. </p>
<dl class="section note"><dt>Note</dt><dd>It is the user's responsibility to ensure that changing the shared global filter data does not change the filter output value for existing pairs. If the filter output for existing pairs does change nonetheless then such a change will not take effect until the pair gets refiltered. <a class="el" href="classphysx_1_1_np_scene.html#abbcd29a20d673677b2ae2994db915fda" title="Marks the object to reset interactions and re-run collision filters in the next simulation step.">resetFiltering()</a> can be used to explicitly refilter the pairs of specific objects.</dd>
<dd>
The provided data will get copied to internal buffers and this copy will be used for filtering calls.</dd>
<dd>
Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The shared global filter shader data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>Size of the shared global filter shader data (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#ae4b8cd7f046e9b62188ece65dd367bc2" title="Gets the shared global filter data in use for this scene.">getFilterShaderData()</a> <a class="el" href="classphysx_1_1_px_scene_desc.html#a5fd01054bfc88a5c30748ad712abfd88" title="Shared global filter data which will get passed into the filter shader.">PxSceneDesc.filterShaderData</a> <a class="el" href="namespacephysx.html#a7d989364d9339d1946b69ec9432f36ae" title="Filter method to specify how a pair of potentially colliding objects should be processed.">PxSimulationFilterShader</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a82b241c653b34b6f6ea1af14763b4ae1">physx::PxScene</a>.</p>

</div>
</div>
<a id="a53fc524e3c214722465430e0ad554c6f" name="a53fc524e3c214722465430e0ad554c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fc524e3c214722465430e0ad554c6f">&#9670;&#160;</a></span>setFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_scene_flag.html#a1a7984bb50590b1a2ce5ca5fe6469e50">PxSceneFlag::Enum</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a scene flag. You can only set one flag at a time. </p>
<dl class="section note"><dt>Note</dt><dd>Not all flags are mutable and changing some will result in an error. Please check #PxSceneFlag to see which flags can be changed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_scene_flag.html" title="flags for configuring properties of the scene">PxSceneFlag</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a9ed79fff923c0af77edd48f3e36a0eb8">physx::PxScene</a>.</p>

</div>
</div>
<a id="a911d803e082ba5c34b4f30bc3d6c4bb9" name="a911d803e082ba5c34b4f30bc3d6c4bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911d803e082ba5c34b4f30bc3d6c4bb9">&#9670;&#160;</a></span>setFrictionCorrelationDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setFrictionCorrelationDistance </td>
          <td>(</td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the friction correlation distance. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a69991c05f58629b6c3cc775242e069c9" title="Friction correlation distance used to decide whether contacts are close enough to be merged into a si...">PxSceneDesc::frictionCorrelationDistance</a>, <a class="el" href="classphysx_1_1_np_scene.html#a250c2fd08143f1e91691a65b41526394" title="Gets the friction correlation distance.">getFrictionCorrelationDistance</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a4d37121545ed3763154db41a295ebbd8">physx::PxScene</a>.</p>

</div>
</div>
<a id="a7cb738f041a90dc9a22fe6494476860f" name="a7cb738f041a90dc9a22fe6494476860f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb738f041a90dc9a22fe6494476860f">&#9670;&#160;</a></span>setFrictionOffsetThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setFrictionOffsetThreshold </td>
          <td>(</td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the friction offset threshold. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#afcd24ab471972d8faad7b1bbd6b2748e" title="A threshold of contact separation distance used to decide if a contact point will experience friction...">PxSceneDesc::frictionOffsetThreshold</a>, <a class="el" href="classphysx_1_1_np_scene.html#ac0770948af43be11d82add237afc0ad4" title="Gets the friction offset threshold.">getFrictionOffsetThreshold</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a8194dafba5ae7af8d6f32b71f8662d4c">physx::PxScene</a>.</p>

</div>
</div>
<a id="a7dfe24681f5d4d93900287156ba13bbe" name="a7dfe24681f5d4d93900287156ba13bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfe24681f5d4d93900287156ba13bbe">&#9670;&#160;</a></span>setFrozenActorFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setFrozenActorFlag </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>buildFrozenActors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classphysx_1_1_np_scene_accessor.html">physx::NpSceneAccessor</a>.</p>

</div>
</div>
<a id="a0cdc7e9623f1822ad460e4dc3bac2f41" name="a0cdc7e9623f1822ad460e4dc3bac2f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdc7e9623f1822ad460e4dc3bac2f41">&#9670;&#160;</a></span>setGravity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setGravity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a constant gravity for the entire scene. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>A new gravity vector(e.g. PxVec3(0.0f,-9.8f,0.0f) ) <b>Range:</b> force vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a62505d66b9c4f00831cf31a7c4bf4046" title="Gravity vector.">PxSceneDesc.gravity</a> <a class="el" href="classphysx_1_1_np_scene.html#afc5198b7257a8cffa856dcbe979f49f2" title="Retrieves the current gravity setting.">getGravity()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a741357e593af477450668557f97f941b">physx::PxScene</a>.</p>

</div>
</div>
<a id="a26353210471576d8e7e6bd1c18de6575" name="a26353210471576d8e7e6bd1c18de6575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26353210471576d8e7e6bd1c18de6575">&#9670;&#160;</a></span>setLimits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setLimits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_scene_limits.html">PxSceneLimits</a> &amp;&#160;</td>
          <td class="paramname"><em>limits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set new scene limits. </p>
<dl class="section note"><dt>Note</dt><dd>Increase the maximum capacity of various data structures in the scene. The new capacities will be at least as large as required to deal with the objects currently in the scene. Further, these values are for preallocation and do not represent hard limits.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">limits</td><td>Scene limits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_limits.html" title="Class used to retrieve limits(e.g. maximum number of bodies) for a scene. The limits are used as a hi...">PxSceneLimits</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a9df8df41a39549403fbcc7f0a372543f">physx::PxScene</a>.</p>

</div>
</div>
<a id="a213d2ef7f2baf9613b1de1fdd2d6ba05" name="a213d2ef7f2baf9613b1de1fdd2d6ba05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213d2ef7f2baf9613b1de1fdd2d6ba05">&#9670;&#160;</a></span>setMaxBiasCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setMaxBiasCoefficient </td>
          <td>(</td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the max bias coefficient. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#ad2b0b28bc190c1a4bbbda3ef115eb5e2" title="The maximum bias coefficient used in the constraint solver.">PxSceneDesc::maxBiasCoefficient</a>, <a class="el" href="classphysx_1_1_np_scene.html#a79a74b8b08c99a62ea9c987e38ddba35" title="Gets the max bias coefficient.">getMaxBiasCoefficient</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#afc561d01d207522c3a3218fa140048f0">physx::PxScene</a>.</p>

</div>
</div>
<a id="a165d89debaed76c460cad53931a25bd2" name="a165d89debaed76c460cad53931a25bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165d89debaed76c460cad53931a25bd2">&#9670;&#160;</a></span>setNbContactDataBlocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setNbContactDataBlocks </td>
          <td>(</td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>numBlocks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the cache blocks that can be used during <a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a>. </p>
<p>Each frame the simulation requires memory to store contact, friction, and contact cache data. This memory is used in blocks of 16K. Each frame the blocks used by the previous frame are freed, and may be retrieved by the application using <a class="el" href="classphysx_1_1_px_scene.html#a8f4860c4aec012d77af67f3234b2815f" title="Clear internal buffers and free memory.">PxScene::flushSimulation()</a></p>
<p>This call will force allocation of cache blocks if the numBlocks parameter is greater than the currently allocated number of blocks, and less than the max16KContactDataBlocks parameter specified at scene creation time.</p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numBlocks</td><td>The number of blocks to allocate. <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#aa24c162f0c558207a5d4e7e3c0243a8a" title="Setting to define the number of 16K blocks that will be initially reserved to store contact,...">PxSceneDesc.nbContactDataBlocks</a> <a class="el" href="classphysx_1_1_px_scene_desc.html#a23bbe23f16a7c7f8b5a0016a5abba02b" title="Setting to define the maximum number of 16K blocks that can be allocated to store contact,...">PxSceneDesc.maxNbContactDataBlocks</a> <a class="el" href="classphysx_1_1_np_scene.html#aad60c8aaea2ce9544fb3d987dc7e9986" title="Clear internal buffers and free memory.">flushSimulation()</a> <a class="el" href="classphysx_1_1_np_scene.html#a46447105dc218cc7cc21334435c1a49a" title="get the number of cache blocks currently used by the scene">getNbContactDataBlocksUsed</a> <a class="el" href="classphysx_1_1_np_scene.html#a318d6decd73dd9e46cf3681f73ddb7c7" title="get the maximum number of cache blocks used by the scene">getMaxNbContactDataBlocksUsed</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a8a41430fca2505d3fae46bf8ec6257cf">physx::PxScene</a>.</p>

</div>
</div>
<a id="acf0505359e51a314a0358712c524e8df" name="acf0505359e51a314a0358712c524e8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0505359e51a314a0358712c524e8df">&#9670;&#160;</a></span>setSimulationEventCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setSimulationEventCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_simulation_event_callback.html">PxSimulationEventCallback</a> *&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a user notify object which receives special simulation events when they occur. </p>
<dl class="section note"><dt>Note</dt><dd>Do not set the callback while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>User notification callback. See #PxSimulationEventCallback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_simulation_event_callback.html" title="An interface class that the user can implement in order to receive simulation events.">PxSimulationEventCallback</a> <a class="el" href="classphysx_1_1_np_scene.html#a60b0d45fa77042425ea1c46216eee23f" title="Retrieves the simulationEventCallback pointer set with setSimulationEventCallback().">getSimulationEventCallback</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a18da50ea8b837ea81214c2ce3507add2">physx::PxScene</a>.</p>

</div>
</div>
<a id="aa5b18319c90e091728482b0c7e142031" name="aa5b18319c90e091728482b0c7e142031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b18319c90e091728482b0c7e142031">&#9670;&#160;</a></span>setSolverArticulationBatchSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setSolverArticulationBatchSize </td>
          <td>(</td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>solverBatchSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of articulations required to spawn a separate rigid body solver thread. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solverBatchSize</td><td>Number of articulations required to spawn a separate rigid body solver thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#adf6e151a8b23c58617e38b60436eb458" title="Defines the number of actors required to spawn a separate rigid body solver island task chain.">PxSceneDesc.solverBatchSize</a> <a class="el" href="classphysx_1_1_np_scene.html#a94badc79f35955ba1c91e24cbcc38213" title="Retrieves the number of articulations required to spawn a separate rigid body solver thread.">getSolverArticulationBatchSize()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ab865b0ad9c28d9753e9cada869b66b39">physx::PxScene</a>.</p>

</div>
</div>
<a id="a5e5ffb28a99ee7845ceb09951cc1eaec" name="a5e5ffb28a99ee7845ceb09951cc1eaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5ffb28a99ee7845ceb09951cc1eaec">&#9670;&#160;</a></span>setSolverBatchSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setSolverBatchSize </td>
          <td>(</td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>solverBatchSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of actors required to spawn a separate rigid body solver thread. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solverBatchSize</td><td>Number of actors required to spawn a separate rigid body solver thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#adf6e151a8b23c58617e38b60436eb458" title="Defines the number of actors required to spawn a separate rigid body solver island task chain.">PxSceneDesc.solverBatchSize</a> <a class="el" href="classphysx_1_1_np_scene.html#af7e15a81d064f2113e97c6425505b900" title="Retrieves the number of actors required to spawn a separate rigid body solver thread.">getSolverBatchSize()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#afa9108e9b02c6ae254019cb7151b6411">physx::PxScene</a>.</p>

</div>
</div>
<a id="a0d9f0d6bdfb888134270afcd4bc65017" name="a0d9f0d6bdfb888134270afcd4bc65017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9f0d6bdfb888134270afcd4bc65017">&#9670;&#160;</a></span>setUpdateMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setUpdateMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_scene_query_update_mode.html#a3d0e848308f503deeb42f966e9fcb99f">PxSceneQueryUpdateMode::Enum</a>&#160;</td>
          <td class="paramname"><em>updateMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets scene query update mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">updateMode</td><td>Scene query update mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_scene_query_update_mode.html#a3d0e848308f503deeb42f966e9fcb99f">PxSceneQueryUpdateMode::Enum</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_query_system_base.html#a4b2060d763604091c9e08f5a64b360ce">physx::PxSceneQuerySystemBase</a>.</p>

</div>
</div>
<a id="a53e090f275f6f3794f737bf54ffc3201" name="a53e090f275f6f3794f737bf54ffc3201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e090f275f6f3794f737bf54ffc3201">&#9670;&#160;</a></span>setVisualizationCullingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::setVisualizationCullingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines a box in world space to which visualization geometry will be (conservatively) culled. Use a non-empty culling box to enable the feature, and an empty culling box to disable it. </p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>the box to which the geometry will be culled. Empty box to disable the feature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#a3cfe009ab48d0c572f63d4a8e74b827d" title="Function that lets you set debug visualization parameters.">setVisualizationParameter</a> <a class="el" href="classphysx_1_1_np_scene.html#abf384537a1340be67465c3877b788f3e" title="Retrieves the visualization culling box.">getVisualizationCullingBox</a> <a class="el" href="classphysx_1_1_np_scene.html#ab64368fd3bce3e261a4cd2790432e333" title="Retrieves the render buffer.">getRenderBuffer()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a372a64d573f39589ce8a8c2101423044">physx::PxScene</a>.</p>

</div>
</div>
<a id="a3cfe009ab48d0c572f63d4a8e74b827d" name="a3cfe009ab48d0c572f63d4a8e74b827d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfe009ab48d0c572f63d4a8e74b827d">&#9670;&#160;</a></span>setVisualizationParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::setVisualizationParameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_visualization_parameter.html#aa447b94a67f50a6573d90f68812ad47e">PxVisualizationParameter::Enum</a>&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that lets you set debug visualization parameters. </p>
<p>Returns false if the value passed is out of range for usage specified by the enum.</p>
<dl class="section note"><dt>Note</dt><dd>Do not use this method while the simulation is running.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>Parameter to set. See #PxVisualizationParameter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to set, see #PxVisualizationParameter for allowable values. Setting to zero disables visualization for the specified property, setting to a positive value usually enables visualization and defines the scale factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the parameter is out of range.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#a526bf8a471eb0cd2bdbd827e7e022089" title="Function that lets you query debug visualization parameters.">getVisualizationParameter</a> <a class="el" href="structphysx_1_1_px_visualization_parameter.html" title="Debug visualization parameters.">PxVisualizationParameter</a> <a class="el" href="classphysx_1_1_np_scene.html#ab64368fd3bce3e261a4cd2790432e333" title="Retrieves the render buffer.">getRenderBuffer()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a02876e45a9335d6d6ec116a075b381e6">physx::PxScene</a>.</p>

</div>
</div>
<a id="a4a75233131b78e93f4f45fa01416e40d" name="a4a75233131b78e93f4f45fa01416e40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a75233131b78e93f4f45fa01416e40d">&#9670;&#160;</a></span>shiftOrigin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::shiftOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>shift</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the scene origin by the specified vector. </p>
<p>The poses of all objects in the scene and the corresponding data structures will get adjusted to reflect the new origin location (the shift vector will get subtracted from all object positions).</p>
<dl class="section note"><dt>Note</dt><dd>It is the user's responsibility to keep track of the summed total origin shift and adjust all input/output to/from PhysX accordingly.</dd>
<dd>
Do not use this method while the simulation is running. Calls to this method while the simulation is running will be ignored.</dd>
<dd>
Make sure to propagate the origin shift to other dependent modules (for example, the character controller module etc.).</dd>
<dd>
This is an expensive operation and we recommend to use it only in the case where distance related precision issues may arise in areas far from the origin.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>Translation vector to shift the origin by. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#abc4460bdc06d2dab1c966a4aba0b0989">physx::PxScene</a>.</p>

</div>
</div>
<a id="ac1b874fe4d75ec6b6502c547a8bce5a8" name="ac1b874fe4d75ec6b6502c547a8bce5a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b874fe4d75ec6b6502c547a8bce5a8">&#9670;&#160;</a></span>simulate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::simulate </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>elapsedTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_base_task.html">physx::PxBaseTask</a> *&#160;</td>
          <td class="paramname"><em>completionTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scratchMemBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>scratchMemBlockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>controlSimulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the simulation by an elapsedTime time. </p>
<dl class="section note"><dt>Note</dt><dd>Large elapsedTime values can lead to instabilities. In such cases elapsedTime should be subdivided into smaller time intervals and <a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a> should be called multiple times for each interval.</dd></dl>
<p>Calls to <a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a> should pair with calls to <a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a>: Each <a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a> invocation corresponds to exactly one <a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a> invocation; calling <a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a> twice without an intervening <a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a> or <a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a> twice without an intervening <a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a> causes an error condition.</p>
<p>scene-&gt;<a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a>; ...do some processing until physics is computed... scene-&gt;<a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a>; ...now results of run may be retrieved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elapsedTime</td><td>Amount of time to advance simulation by. The parameter has to be larger than 0, else the resulting behavior will be undefined. <b>Range:</b> (0, PX_MAX_F32) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">completionTask</td><td>if non-NULL, this task will have its refcount incremented in <a class="el" href="classphysx_1_1_np_scene.html#ac1b874fe4d75ec6b6502c547a8bce5a8" title="Advances the simulation by an elapsedTime time.">simulate()</a>, then decremented when the scene is ready to have fetchResults called. So the task will not run until the application also calls removeReference(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scratchMemBlock</td><td>a memory region for physx to use for temporary data during simulation. This block may be reused by the application after fetchResults returns. Must be aligned on a 16-byte boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scratchMemBlockSize</td><td>the size of the scratch memory block. Must be a multiple of 16K. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">controlSimulation</td><td>if true, the scene controls its <a class="el" href="classphysx_1_1_px_task_manager.html" title="The PxTaskManager interface.">PxTaskManager</a> simulation state. Leave true unless the application is calling the <a class="el" href="classphysx_1_1_px_task_manager.html" title="The PxTaskManager interface.">PxTaskManager</a> start/stopSimulation() methods itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_scene.html#a459128504c8dff8c4d6af42d1028208d">fetchResults()</a> <a class="el" href="classphysx_1_1_np_scene.html#ac393a255bb6fcad89ae8452f5682abd3" title="This checks to see if the simulation run has completed.">checkResults()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ac9bf1631519e43a0375f821396e246e9">physx::PxScene</a>.</p>

</div>
</div>
<a id="a96c28d68f0ef41541fd3c040c42b20ab" name="a96c28d68f0ef41541fd3c040c42b20ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c28d68f0ef41541fd3c040c42b20ab">&#9670;&#160;</a></span>sweep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool NpScene::sweep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_geometry.html">PxGeometry</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>unitDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacephysx.html#aeb5288dec811f06fc7d10620f388dd9d">PxSweepCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>hitCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxHitFlags&#160;</td>
          <td class="paramname"><em>hitFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_filter_data.html">PxQueryFilterData</a> &amp;&#160;</td>
          <td class="paramname"><em>filterData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_query_filter_callback.html">PxQueryFilterCallback</a> *&#160;</td>
          <td class="paramname"><em>filterCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_query_cache.html">PxQueryCache</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PxReal&#160;</td>
          <td class="paramname"><em>inflation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxGeometryQueryFlags&#160;</td>
          <td class="paramname"><em>queryFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a sweep test against objects in the scene, returns results in a PxSweepBuffer object or via a custom user callback implementation inheriting from PxSweepCallback. </p>
<dl class="section note"><dt>Note</dt><dd>Touching hits are not ordered. </dd>
<dd>
If a shape from the scene is already overlapping with the query shape in its starting position, the hit is returned unless eASSUME_NO_INITIAL_OVERLAP was specified.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry</td><td>Geometry of object to sweep (supported types are: box, sphere, capsule, convex). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Pose of the sweep object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitDir</td><td>Normalized direction of the sweep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Sweep distance. Needs to be in [0, inf) range and &gt;0 if eASSUME_NO_INITIAL_OVERLAP was specified. Will be clamped to PX_MAX_SWEEP_DISTANCE. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hitCall</td><td>Sweep hit buffer or callback object used to report sweep hits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hitFlags</td><td>Specifies which properties per hit should be computed and returned via the hit callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterData</td><td>Filtering data and simple logic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filterCall</td><td>Custom filtering logic (optional). Only used if the corresponding #PxQueryFlag flags are set. If NULL, all hits are assumed to be blocking. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>Cached hit shape (optional). Sweep is performed against cached shape first. If no hit is found the sweep gets queried against the scene. Note: Filtering is not executed for a cached shape if supplied; instead, if a hit is found, it is assumed to be a blocking hit. Note: Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inflation</td><td>This parameter creates a skin around the swept geometry which increases its extents for sweeping. The sweep will register a hit as soon as the skin touches a shape, and will return the corresponding distance and normal. Note: ePRECISE_SWEEP doesn't support inflation. Therefore the sweep will be performed with zero inflation. <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">queryFlags</td><td>Optional flags controlling the query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any touching or blocking hits were found or any hit was found in case <a class="el" href="structphysx_1_1_px_query_flag.html#ab6f2a73622dd9c61562681e70cc8f29faba424ffb6f34ac4fc135b57b586fefb8">PxQueryFlag::eANY_HIT</a> was specified.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacephysx.html#aeb5288dec811f06fc7d10620f388dd9d" title="Sweep query callback.">PxSweepCallback</a> <a class="el" href="namespacephysx.html#a3b7e7fb7c8e61f32b50564aebb5e3009" title="Sweep query buffer.">PxSweepBuffer</a> <a class="el" href="structphysx_1_1_px_query_filter_data.html" title="Scene query filtering data.">PxQueryFilterData</a> <a class="el" href="classphysx_1_1_px_query_filter_callback.html" title="Scene query filtering callbacks.">PxQueryFilterCallback</a> <a class="el" href="structphysx_1_1_px_sweep_hit.html">PxSweepHit</a> <a class="el" href="structphysx_1_1_px_query_cache.html" title="single hit cache for scene queries.">PxQueryCache</a> <a class="el" href="structphysx_1_1_px_geometry_query_flag.html" title="Geometry-level query flags.">PxGeometryQueryFlag</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene_query_system_base.html#a1f4cf801dbf2cf31c2200baadb7bb14a">physx::PxSceneQuerySystemBase</a>.</p>

</div>
</div>
<a id="ab3b41d59d5df44ec8a9b78bcf00f4a05" name="ab3b41d59d5df44ec8a9b78bcf00f4a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b41d59d5df44ec8a9b78bcf00f4a05">&#9670;&#160;</a></span>unlockRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::unlockRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock the scene from reading. </p>
<dl class="section note"><dt>Note</dt><dd>Each <a class="el" href="classphysx_1_1_np_scene.html#ab3b41d59d5df44ec8a9b78bcf00f4a05" title="Unlock the scene from reading.">unlockRead()</a> must be paired with a <a class="el" href="classphysx_1_1_np_scene.html#aaa9d0cf0d3f68b0ce1b1f790783e4dfe" title="Lock the scene for reading from the calling thread.">lockRead()</a> from the same thread. </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#a908567834210a60db3a6fed55e1f4b55">physx::PxScene</a>.</p>

</div>
</div>
<a id="ab63a6471e862677ab570a6db395cfd6b" name="ab63a6471e862677ab570a6db395cfd6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63a6471e862677ab570a6db395cfd6b">&#9670;&#160;</a></span>unlockWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void NpScene::unlockWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock the scene from writing. </p>
<dl class="section note"><dt>Note</dt><dd>Each <a class="el" href="classphysx_1_1_np_scene.html#ab63a6471e862677ab570a6db395cfd6b" title="Unlock the scene from writing.">unlockWrite()</a> must be paired with a <a class="el" href="classphysx_1_1_np_scene.html#a89177e9e4be212c2e15e0b3d03063013" title="Lock the scene for writing from this thread.">lockWrite()</a> from the same thread. </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_scene.html#ab306134680733c995b5457e633c5573c">physx::PxScene</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/physx/src/<a class="el" href="_np_scene_8h_source.html">NpScene.h</a></li>
<li>source/physx/src/NpDebugViz.cpp</li>
<li>source/physx/src/NpScene.cpp</li>
<li>source/physx/src/NpSceneFetchResults.cpp</li>
<li>source/physx/src/NpSceneQueries.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacephysx.html">physx</a></li><li class="navelem"><a class="el" href="classphysx_1_1_np_scene.html">NpScene</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
