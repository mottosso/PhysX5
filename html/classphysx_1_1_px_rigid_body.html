<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PhysX: physx::PxRigidBody Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PhysX<span id="projectnumber">&#160;5.1.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classphysx_1_1_px_rigid_body.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="classphysx_1_1_px_rigid_body-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">physx::PxRigidBody Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classphysx_1_1_px_rigid_body.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> is a base class shared between dynamic rigid body objects.  
 <a href="classphysx_1_1_px_rigid_body.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_px_rigid_body_8h_source.html">PxRigidBody.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for physx::PxRigidBody:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classphysx_1_1_px_rigid_body.png" usemap="#physx::PxRigidBody_map" alt=""/>
  <map id="physx::PxRigidBody_map" name="physx::PxRigidBody_map">
<area href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD..." alt="physx::PxRigidActor" shape="rect" coords="81,112,233,136"/>
<area href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="physx::PxActor" shape="rect" coords="81,56,233,80"/>
<area href="classphysx_1_1_px_base.html" title="Base class for objects that can be members of a PxCollection." alt="physx::PxBase" shape="rect" coords="81,0,233,24"/>
<area href="classphysx_1_1_px_articulation_link.html" title="A component of an articulation that represents a rigid body." alt="physx::PxArticulationLink" shape="rect" coords="0,224,152,248"/>
<area href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK." alt="physx::PxRigidDynamic" shape="rect" coords="162,224,314,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mass Manipulation</div></td></tr>
<tr class="memitem:a9038be016fffefba405ce6a083bc1936"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a9038be016fffefba405ce6a083bc1936">setCMassLocalPose</a> (const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;pose)=0</td></tr>
<tr class="memdesc:a9038be016fffefba405ce6a083bc1936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pose of the center of mass relative to the actor. <br  />
  <br /></td></tr>
<tr class="separator:a9038be016fffefba405ce6a083bc1936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7df384ad4cada38535d7d5ffa77a6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a33a7df384ad4cada38535d7d5ffa77a6">getCMassLocalPose</a> () const =0</td></tr>
<tr class="memdesc:a33a7df384ad4cada38535d7d5ffa77a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the center of mass pose relative to the actor frame.  <br /></td></tr>
<tr class="separator:a33a7df384ad4cada38535d7d5ffa77a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fb1b366d9b26a06a2b20c52fa709f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ad0fb1b366d9b26a06a2b20c52fa709f8">setMass</a> (PxReal mass)=0</td></tr>
<tr class="memdesc:ad0fb1b366d9b26a06a2b20c52fa709f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mass of a dynamic actor.  <br /></td></tr>
<tr class="separator:ad0fb1b366d9b26a06a2b20c52fa709f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aef661dfca7aa4ce904c4606442509"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ac2aef661dfca7aa4ce904c4606442509">getMass</a> () const =0</td></tr>
<tr class="memdesc:ac2aef661dfca7aa4ce904c4606442509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the mass of the actor.  <br /></td></tr>
<tr class="separator:ac2aef661dfca7aa4ce904c4606442509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae450dc383abe68f94c54d4f705811b15"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ae450dc383abe68f94c54d4f705811b15">getInvMass</a> () const =0</td></tr>
<tr class="memdesc:ae450dc383abe68f94c54d4f705811b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the inverse mass of the actor.  <br /></td></tr>
<tr class="separator:ae450dc383abe68f94c54d4f705811b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17df2c95e1f0a096aa3ebec1cd167656"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a17df2c95e1f0a096aa3ebec1cd167656">setMassSpaceInertiaTensor</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;m)=0</td></tr>
<tr class="memdesc:a17df2c95e1f0a096aa3ebec1cd167656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the inertia tensor, using a parameter specified in mass space coordinates.  <br /></td></tr>
<tr class="separator:a17df2c95e1f0a096aa3ebec1cd167656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9605908d991d0d6be27e690a55c27d00"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a9605908d991d0d6be27e690a55c27d00">getMassSpaceInertiaTensor</a> () const =0</td></tr>
<tr class="memdesc:a9605908d991d0d6be27e690a55c27d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame.  <br /></td></tr>
<tr class="separator:a9605908d991d0d6be27e690a55c27d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d24a7c452595426d738300802a2a7d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a88d24a7c452595426d738300802a2a7d">getMassSpaceInvInertiaTensor</a> () const =0</td></tr>
<tr class="memdesc:a88d24a7c452595426d738300802a2a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the diagonal inverse inertia tensor of the actor relative to the mass coordinate frame.  <br /></td></tr>
<tr class="separator:a88d24a7c452595426d738300802a2a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Damping</div></td></tr>
<tr class="memitem:a87cbe4f374180181c45d65562aa29098"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a87cbe4f374180181c45d65562aa29098">setLinearDamping</a> (PxReal linDamp)=0</td></tr>
<tr class="memdesc:a87cbe4f374180181c45d65562aa29098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the linear damping coefficient.  <br /></td></tr>
<tr class="separator:a87cbe4f374180181c45d65562aa29098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1f5404c4a54e143b9851aa5a5936af"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a7f1f5404c4a54e143b9851aa5a5936af">getLinearDamping</a> () const =0</td></tr>
<tr class="memdesc:a7f1f5404c4a54e143b9851aa5a5936af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the linear damping coefficient.  <br /></td></tr>
<tr class="separator:a7f1f5404c4a54e143b9851aa5a5936af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97921d4c4fc44b5e34c9113f688abdf3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a97921d4c4fc44b5e34c9113f688abdf3">setAngularDamping</a> (PxReal angDamp)=0</td></tr>
<tr class="memdesc:a97921d4c4fc44b5e34c9113f688abdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the angular damping coefficient.  <br /></td></tr>
<tr class="separator:a97921d4c4fc44b5e34c9113f688abdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d317a7d63bc32fa490eb3a39fc6844"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ad8d317a7d63bc32fa490eb3a39fc6844">getAngularDamping</a> () const =0</td></tr>
<tr class="memdesc:ad8d317a7d63bc32fa490eb3a39fc6844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the angular damping coefficient.  <br /></td></tr>
<tr class="separator:ad8d317a7d63bc32fa490eb3a39fc6844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Velocity</div></td></tr>
<tr class="memitem:ae2739d0560b5681034deb063fe6916f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ae2739d0560b5681034deb063fe6916f3">getLinearVelocity</a> () const =0</td></tr>
<tr class="memdesc:ae2739d0560b5681034deb063fe6916f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the linear velocity of an actor.  <br /></td></tr>
<tr class="separator:ae2739d0560b5681034deb063fe6916f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0718c3215843b0c333665cb2caffca8d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a0718c3215843b0c333665cb2caffca8d">getAngularVelocity</a> () const =0</td></tr>
<tr class="memdesc:a0718c3215843b0c333665cb2caffca8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the angular velocity of the actor.  <br /></td></tr>
<tr class="separator:a0718c3215843b0c333665cb2caffca8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4c80d576f21a6fb45884d6584b08b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#afd4c80d576f21a6fb45884d6584b08b5">setMaxLinearVelocity</a> (PxReal maxLinVel)=0</td></tr>
<tr class="memdesc:afd4c80d576f21a6fb45884d6584b08b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets you set the maximum linear velocity permitted for this actor.  <br /></td></tr>
<tr class="separator:afd4c80d576f21a6fb45884d6584b08b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc31a61c9865b6de27c448b320b06dbf"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#acc31a61c9865b6de27c448b320b06dbf">getMaxLinearVelocity</a> () const =0</td></tr>
<tr class="memdesc:acc31a61c9865b6de27c448b320b06dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum angular velocity permitted for this actor.  <br /></td></tr>
<tr class="separator:acc31a61c9865b6de27c448b320b06dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7ffce7c2a92546abd7a07cdbc67c76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a3c7ffce7c2a92546abd7a07cdbc67c76">setMaxAngularVelocity</a> (PxReal maxAngVel)=0</td></tr>
<tr class="memdesc:a3c7ffce7c2a92546abd7a07cdbc67c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets you set the maximum angular velocity permitted for this actor.  <br /></td></tr>
<tr class="separator:a3c7ffce7c2a92546abd7a07cdbc67c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aedd3e236650303e840e7a9b885339"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#af2aedd3e236650303e840e7a9b885339">getMaxAngularVelocity</a> () const =0</td></tr>
<tr class="memdesc:af2aedd3e236650303e840e7a9b885339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum angular velocity permitted for this actor.  <br /></td></tr>
<tr class="separator:af2aedd3e236650303e840e7a9b885339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_rigid_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_rigid_actor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_rigid_actor.html">physx::PxRigidActor</a></td></tr>
<tr class="memitem:aa586d6c2d8eef65c4b986066297809f7 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#aa586d6c2d8eef65c4b986066297809f7">release</a> ()=0</td></tr>
<tr class="memdesc:aa586d6c2d8eef65c4b986066297809f7 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the rigid actor object.  <br /></td></tr>
<tr class="separator:aa586d6c2d8eef65c4b986066297809f7 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f5c46f4b03d7d6c5293cc90b9a7660 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a06f5c46f4b03d7d6c5293cc90b9a7660">getInternalActorIndex</a> () const =0</td></tr>
<tr class="memdesc:a06f5c46f4b03d7d6c5293cc90b9a7660 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal actor index.  <br /></td></tr>
<tr class="separator:a06f5c46f4b03d7d6c5293cc90b9a7660 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb7aba78c0dee595675bf6f4c09cc7c inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#acdb7aba78c0dee595675bf6f4c09cc7c">getGlobalPose</a> () const =0</td></tr>
<tr class="memdesc:acdb7aba78c0dee595675bf6f4c09cc7c inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the actors world space transform.  <br /></td></tr>
<tr class="separator:acdb7aba78c0dee595675bf6f4c09cc7c inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471dcde00089e53114f87d884c7a0163 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a471dcde00089e53114f87d884c7a0163">setGlobalPose</a> (const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;pose, bool autowake=true)=0</td></tr>
<tr class="memdesc:a471dcde00089e53114f87d884c7a0163 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for setting an actor's pose in the world.  <br /></td></tr>
<tr class="separator:a471dcde00089e53114f87d884c7a0163 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464e93731d0f59ea0e308a1cb5881646 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a464e93731d0f59ea0e308a1cb5881646">attachShape</a> (<a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> &amp;shape)=0</td></tr>
<tr class="memdesc:a464e93731d0f59ea0e308a1cb5881646 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a shape to an actor.  <br /></td></tr>
<tr class="separator:a464e93731d0f59ea0e308a1cb5881646 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191dad155177ded4d47396d4fea598e2 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a191dad155177ded4d47396d4fea598e2">detachShape</a> (<a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> &amp;shape, bool wakeOnLostTouch=true)=0</td></tr>
<tr class="memdesc:a191dad155177ded4d47396d4fea598e2 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a shape from an actor.  <br /></td></tr>
<tr class="separator:a191dad155177ded4d47396d4fea598e2 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d0db68c9d9ec4d0f369ab2f8029a25 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a72d0db68c9d9ec4d0f369ab2f8029a25">getNbShapes</a> () const =0</td></tr>
<tr class="memdesc:a72d0db68c9d9ec4d0f369ab2f8029a25 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of shapes assigned to the actor.  <br /></td></tr>
<tr class="separator:a72d0db68c9d9ec4d0f369ab2f8029a25 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aa5f84f999da2e8c410b8d0fbe8f5a inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a50aa5f84f999da2e8c410b8d0fbe8f5a">getShapes</a> (<a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0</td></tr>
<tr class="memdesc:a50aa5f84f999da2e8c410b8d0fbe8f5a inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the shape pointers belonging to the actor.  <br /></td></tr>
<tr class="separator:a50aa5f84f999da2e8c410b8d0fbe8f5a inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06c08d1d6ae4b0c9e69714c5698b27d inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#aa06c08d1d6ae4b0c9e69714c5698b27d">getNbConstraints</a> () const =0</td></tr>
<tr class="memdesc:aa06c08d1d6ae4b0c9e69714c5698b27d inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraint shaders attached to the actor.  <br /></td></tr>
<tr class="separator:aa06c08d1d6ae4b0c9e69714c5698b27d inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84b5553f7f32e5f0a4543b6968f432f inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#ac84b5553f7f32e5f0a4543b6968f432f">getConstraints</a> (<a class="el" href="classphysx_1_1_px_constraint.html">PxConstraint</a> **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0</td></tr>
<tr class="memdesc:ac84b5553f7f32e5f0a4543b6968f432f inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the constraint shader pointers belonging to the actor.  <br /></td></tr>
<tr class="separator:ac84b5553f7f32e5f0a4543b6968f432f inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_actor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_actor.html">physx::PxActor</a></td></tr>
<tr class="memitem:a782e6bd48fb10f393581302d428eee19 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a782e6bd48fb10f393581302d428eee19">release</a> ()=0</td></tr>
<tr class="memdesc:a782e6bd48fb10f393581302d428eee19 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the actor.  <br /></td></tr>
<tr class="separator:a782e6bd48fb10f393581302d428eee19 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff803bacb565652fb46ab69cda1d2526 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_actor_type.html#aa12d1dbb97bda016f592de47e67e3963">PxActorType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aff803bacb565652fb46ab69cda1d2526">getType</a> () const =0</td></tr>
<tr class="memdesc:aff803bacb565652fb46ab69cda1d2526 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the type of actor.  <br /></td></tr>
<tr class="separator:aff803bacb565652fb46ab69cda1d2526 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002cfb766d7d8aa71f174980fe7b1c6b inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_scene.html">PxScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a002cfb766d7d8aa71f174980fe7b1c6b">getScene</a> () const =0</td></tr>
<tr class="memdesc:a002cfb766d7d8aa71f174980fe7b1c6b inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the scene which this actor belongs to.  <br /></td></tr>
<tr class="separator:a002cfb766d7d8aa71f174980fe7b1c6b inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab374c355cdd9c9b5a93479a8c751704a inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#ab374c355cdd9c9b5a93479a8c751704a">setName</a> (const char *name)=0</td></tr>
<tr class="memdesc:ab374c355cdd9c9b5a93479a8c751704a inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classphysx_1_1_px_actor.html#aad553a24aa6546e93bfb887d0c27fba9" title="Retrieves the name string set with setName().">getName()</a>.  <br /></td></tr>
<tr class="separator:ab374c355cdd9c9b5a93479a8c751704a inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad553a24aa6546e93bfb887d0c27fba9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aad553a24aa6546e93bfb887d0c27fba9">getName</a> () const =0</td></tr>
<tr class="memdesc:aad553a24aa6546e93bfb887d0c27fba9 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the name string set with <a class="el" href="classphysx_1_1_px_actor.html#ab374c355cdd9c9b5a93479a8c751704a" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>.  <br /></td></tr>
<tr class="separator:aad553a24aa6546e93bfb887d0c27fba9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4121e4d3f38d9303b840159ac18bc5d inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#ab4121e4d3f38d9303b840159ac18bc5d">getWorldBounds</a> (float inflation=1.01f) const =0</td></tr>
<tr class="memdesc:ab4121e4d3f38d9303b840159ac18bc5d inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the actor.  <br /></td></tr>
<tr class="separator:ab4121e4d3f38d9303b840159ac18bc5d inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6587b0a441c214a3f4504099105e298f inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a6587b0a441c214a3f4504099105e298f">setActorFlag</a> (<a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8">PxActorFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:a6587b0a441c214a3f4504099105e298f inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular actor flag.  <br /></td></tr>
<tr class="separator:a6587b0a441c214a3f4504099105e298f inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47d905605f403aa95aee541a772b696 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aa47d905605f403aa95aee541a772b696">setActorFlags</a> (<a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a> inFlags)=0</td></tr>
<tr class="memdesc:aa47d905605f403aa95aee541a772b696 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the actor flags.  <br /></td></tr>
<tr class="separator:aa47d905605f403aa95aee541a772b696 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3aebddb7b31092182606c61398983a inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a5d3aebddb7b31092182606c61398983a">getActorFlags</a> () const =0</td></tr>
<tr class="memdesc:a5d3aebddb7b31092182606c61398983a inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> flags.  <br /></td></tr>
<tr class="separator:a5d3aebddb7b31092182606c61398983a inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3786b0f53c9a37074372d0ea62ce348d inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a3786b0f53c9a37074372d0ea62ce348d">setDominanceGroup</a> (<a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a> dominanceGroup)=0</td></tr>
<tr class="memdesc:a3786b0f53c9a37074372d0ea62ce348d inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns dynamic actors a dominance group identifier.  <br /></td></tr>
<tr class="separator:a3786b0f53c9a37074372d0ea62ce348d inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7effc9b077780ffd713baa8869feae inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a4b7effc9b077780ffd713baa8869feae">getDominanceGroup</a> () const =0</td></tr>
<tr class="memdesc:a4b7effc9b077780ffd713baa8869feae inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value set with <a class="el" href="classphysx_1_1_px_actor.html#a3786b0f53c9a37074372d0ea62ce348d" title="Assigns dynamic actors a dominance group identifier.">setDominanceGroup()</a>.  <br /></td></tr>
<tr class="separator:a4b7effc9b077780ffd713baa8869feae inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160170378b1a28ef6f82f9c603b3cdf9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a160170378b1a28ef6f82f9c603b3cdf9">setOwnerClient</a> (<a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a> inClient)=0</td></tr>
<tr class="memdesc:a160170378b1a28ef6f82f9c603b3cdf9 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the owner client of an actor.  <br /></td></tr>
<tr class="separator:a160170378b1a28ef6f82f9c603b3cdf9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fe5ab2d87b2cded54153370492875 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a0f3fe5ab2d87b2cded54153370492875">getOwnerClient</a> () const =0</td></tr>
<tr class="memdesc:a0f3fe5ab2d87b2cded54153370492875 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the owner client that was specified at creation time.  <br /></td></tr>
<tr class="separator:a0f3fe5ab2d87b2cded54153370492875 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2001117af8250e4afc077e160307aa13 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a2001117af8250e4afc077e160307aa13">getAggregate</a> () const =0</td></tr>
<tr class="memdesc:a2001117af8250e4afc077e160307aa13 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the aggregate the actor might be a part of.  <br /></td></tr>
<tr class="separator:a2001117af8250e4afc077e160307aa13 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a09013f88c156cfcdfcb001611360e92c">release</a> ()=0</td></tr>
<tr class="memdesc:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the <a class="el" href="classphysx_1_1_px_base.html" title="Base class for objects that can be members of a PxCollection.">PxBase</a> instance, please check documentation of release in derived class.  <br /></td></tr>
<tr class="separator:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aea4c4ef95da2697f36d3a9fc9a2f897a">getConcreteTypeName</a> () const =0</td></tr>
<tr class="memdesc:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string name of dynamic type.  <br /></td></tr>
<tr class="separator:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="a76be84f268e30c6fcb62a413963908db" name="a76be84f268e30c6fcb62a413963908db"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is</b> ()</td></tr>
<tr class="separator:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="a114ba2d2c3e2e50368c7003660b7e78d" name="a114ba2d2c3e2e50368c7003660b7e78d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is</b> () const</td></tr>
<tr class="separator:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> PxType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aeb75b831810e817d266223ccb244f3e4">getConcreteType</a> () const</td></tr>
<tr class="memdesc:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns concrete type of object.  <br /></td></tr>
<tr class="separator:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aa1f16f63ebbcad8aff05560d28709ff0">setBaseFlag</a> (PxBaseFlag::Enum flag, bool value)</td></tr>
<tr class="memdesc:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="structphysx_1_1_px_base_flag.html" title="Flags for PxBase.">PxBaseFlag</a> <br  />
  <br /></td></tr>
<tr class="separator:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a87724fce99cffbdd787a13391e58c04e">setBaseFlags</a> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> inFlags)</td></tr>
<tr class="memdesc:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PxBaseFlags <br  />
  <br /></td></tr>
<tr class="separator:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a1f7953973ba7e246effc9d4f6e6f34ab">getBaseFlags</a> () const</td></tr>
<tr class="memdesc:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns PxBaseFlags.  <br /></td></tr>
<tr class="separator:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a43f6a532bcc3da9e6fc8977094f419d9">isReleasable</a> () const</td></tr>
<tr class="memdesc:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the object is subordinate.  <br /></td></tr>
<tr class="separator:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Forces</h2></td></tr>
<tr class="memitem:acd9fd364b46b541261c703a718d1c551"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#acd9fd364b46b541261c703a718d1c551">addForce</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;force, <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a> mode=<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a>, bool autowake=true)=0</td></tr>
<tr class="memdesc:acd9fd364b46b541261c703a718d1c551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mass.  <br /></td></tr>
<tr class="separator:acd9fd364b46b541261c703a718d1c551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da43ae58269860df73c0164cef0118b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a5da43ae58269860df73c0164cef0118b">addTorque</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;torque, <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a> mode=<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a>, bool autowake=true)=0</td></tr>
<tr class="memdesc:a5da43ae58269860df73c0164cef0118b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an impulsive torque defined in the global coordinate frame to the actor.  <br /></td></tr>
<tr class="separator:a5da43ae58269860df73c0164cef0118b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13e207785f48e70e89fe1965617e624"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ad13e207785f48e70e89fe1965617e624">clearForce</a> (<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a> mode=<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:ad13e207785f48e70e89fe1965617e624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the accumulated forces (sets the accumulated force back to zero).  <br /></td></tr>
<tr class="separator:ad13e207785f48e70e89fe1965617e624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3a753e5a8f1a00bf5691ebf0d66a55"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a8a3a753e5a8f1a00bf5691ebf0d66a55">clearTorque</a> (<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a> mode=<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:a8a3a753e5a8f1a00bf5691ebf0d66a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the impulsive torque defined in the global coordinate frame to the actor.  <br /></td></tr>
<tr class="separator:a8a3a753e5a8f1a00bf5691ebf0d66a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d643ffccf6fefb0b39c609c2e474f75"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a8d643ffccf6fefb0b39c609c2e474f75">setForceAndTorque</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;force, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;torque, <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a> mode=<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:a8d643ffccf6fefb0b39c609c2e474f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the impulsive force and torque defined in the global coordinate frame to the actor.  <br /></td></tr>
<tr class="separator:a8d643ffccf6fefb0b39c609c2e474f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85350efb9b525a6cf0de079d959d8c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ab85350efb9b525a6cf0de079d959d8c4">setRigidBodyFlag</a> (<a class="el" href="structphysx_1_1_px_rigid_body_flag.html#ae3a4da7ce0535fdd127728674e060869">PxRigidBodyFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:ab85350efb9b525a6cf0de079d959d8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular rigid body flag.  <br /></td></tr>
<tr class="separator:ab85350efb9b525a6cf0de079d959d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdfb6b1a61d6fa8010af0dc854c7d68"><td class="memItemLeft" align="right" valign="top"><a id="aabdfb6b1a61d6fa8010af0dc854c7d68" name="aabdfb6b1a61d6fa8010af0dc854c7d68"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setRigidBodyFlags</b> (<a class="el" href="namespacephysx.html#a97e228a8044f5674ef80a0195012f401">PxRigidBodyFlags</a> inFlags)=0</td></tr>
<tr class="separator:aabdfb6b1a61d6fa8010af0dc854c7d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864acc2c28d314bb3074f7997cb1d910"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a97e228a8044f5674ef80a0195012f401">PxRigidBodyFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a864acc2c28d314bb3074f7997cb1d910">getRigidBodyFlags</a> () const =0</td></tr>
<tr class="memdesc:a864acc2c28d314bb3074f7997cb1d910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classphysx_1_1_px_rigid_body.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> flags.  <br /></td></tr>
<tr class="separator:a864acc2c28d314bb3074f7997cb1d910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef05905d355a51c91f71c99f0ab3a990"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#aef05905d355a51c91f71c99f0ab3a990">setMinCCDAdvanceCoefficient</a> (PxReal advanceCoefficient)=0</td></tr>
<tr class="memdesc:aef05905d355a51c91f71c99f0ab3a990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CCD minimum advance coefficient.  <br /></td></tr>
<tr class="separator:aef05905d355a51c91f71c99f0ab3a990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cc5fcce42853bb3f718c2c78782eb6"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ab5cc5fcce42853bb3f718c2c78782eb6">getMinCCDAdvanceCoefficient</a> () const =0</td></tr>
<tr class="memdesc:ab5cc5fcce42853bb3f718c2c78782eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the CCD minimum advance coefficient.  <br /></td></tr>
<tr class="separator:ab5cc5fcce42853bb3f718c2c78782eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f892df807dac059cabe4ac699aa8104"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a4f892df807dac059cabe4ac699aa8104">setMaxDepenetrationVelocity</a> (PxReal biasClamp)=0</td></tr>
<tr class="memdesc:a4f892df807dac059cabe4ac699aa8104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum depenetration velocity permitted to be introduced by the solver. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  <br /></td></tr>
<tr class="separator:a4f892df807dac059cabe4ac699aa8104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8a85ec0bf904443aaa1897f72bd0d5"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a8b8a85ec0bf904443aaa1897f72bd0d5">getMaxDepenetrationVelocity</a> () const =0</td></tr>
<tr class="memdesc:a8b8a85ec0bf904443aaa1897f72bd0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum depenetration velocity the solver is permitted to introduced. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  <br /></td></tr>
<tr class="separator:a8b8a85ec0bf904443aaa1897f72bd0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0616e1ce7f675243220ce94f8eb23e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a5a0616e1ce7f675243220ce94f8eb23e">setMaxContactImpulse</a> (PxReal maxImpulse)=0</td></tr>
<tr class="memdesc:a5a0616e1ce7f675243220ce94f8eb23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body.  <br /></td></tr>
<tr class="separator:a5a0616e1ce7f675243220ce94f8eb23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3efe30e7ceaae6694bb80fd0567820"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#afc3efe30e7ceaae6694bb80fd0567820">getMaxContactImpulse</a> () const =0</td></tr>
<tr class="memdesc:afc3efe30e7ceaae6694bb80fd0567820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum impulse that may be applied at a contact.  <br /></td></tr>
<tr class="separator:afc3efe30e7ceaae6694bb80fd0567820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29704224fe61cc77002d290b1bbe0bb8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a29704224fe61cc77002d290b1bbe0bb8">setContactSlopCoefficient</a> (PxReal slopCoefficient)=0</td></tr>
<tr class="memdesc:a29704224fe61cc77002d290b1bbe0bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a distance scale whereby the angular influence of a contact on the normal constraint in a contact is zeroed if normal.cross(offset) falls below this tolerance. Rather than acting as an absolute value, this tolerance is scaled by the ratio rXn.dot(angVel)/normal.dot(linVel) such that contacts that have relatively larger angular velocity than linear normal velocity (e.g. rolling wheels) achieve larger slop values as the angular velocity increases.  <br /></td></tr>
<tr class="separator:a29704224fe61cc77002d290b1bbe0bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60939f0d306255f906f9c9626a69a3e5"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a60939f0d306255f906f9c9626a69a3e5">getContactSlopCoefficient</a> () const =0</td></tr>
<tr class="memdesc:a60939f0d306255f906f9c9626a69a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contact slop coefficient.  <br /></td></tr>
<tr class="separator:a60939f0d306255f906f9c9626a69a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b68a2d6ca702401da6ddbe165fae35"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_node_index.html">PxNodeIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a82b68a2d6ca702401da6ddbe165fae35">getInternalIslandNodeIndex</a> () const =0</td></tr>
<tr class="memdesc:a82b68a2d6ca702401da6ddbe165fae35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the island node index.  <br /></td></tr>
<tr class="separator:a82b68a2d6ca702401da6ddbe165fae35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f73ea4c22236077d0ea55fe5ca2048"><td class="memItemLeft" align="right" valign="top"><a id="a00f73ea4c22236077d0ea55fe5ca2048" name="a00f73ea4c22236077d0ea55fe5ca2048"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxRigidBody</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a00f73ea4c22236077d0ea55fe5ca2048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c68990ce024b92c5ad18e88c83ff497"><td class="memItemLeft" align="right" valign="top"><a id="a3c68990ce024b92c5ad18e88c83ff497" name="a3c68990ce024b92c5ad18e88c83ff497"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxRigidBody</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a3c68990ce024b92c5ad18e88c83ff497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada115a8b6441798bfd89a9ded9dedef9"><td class="memItemLeft" align="right" valign="top"><a id="ada115a8b6441798bfd89a9ded9dedef9" name="ada115a8b6441798bfd89a9ded9dedef9"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PxRigidBody</b> ()</td></tr>
<tr class="separator:ada115a8b6441798bfd89a9ded9dedef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231f75c8948a5b712453b18339a4bae1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a231f75c8948a5b712453b18339a4bae1">isKindOf</a> (const char *name) const</td></tr>
<tr class="memdesc:a231f75c8948a5b712453b18339a4bae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:a231f75c8948a5b712453b18339a4bae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classphysx_1_1_px_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classphysx_1_1_px_actor')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classphysx_1_1_px_actor.html">physx::PxActor</a></td></tr>
<tr class="memitem:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="a85d97eb04de762d740345cc469824b6f" name="a85d97eb04de762d740345cc469824b6f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>userData</b></td></tr>
<tr class="memdesc:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object. <br /></td></tr>
<tr class="separator:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_rigid_actor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_rigid_actor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_rigid_actor.html">physx::PxRigidActor</a></td></tr>
<tr class="memitem:a19d601aff4c99aae855bac2d84c2ea4b inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top"><a id="a19d601aff4c99aae855bac2d84c2ea4b" name="a19d601aff4c99aae855bac2d84c2ea4b"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxRigidActor</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a19d601aff4c99aae855bac2d84c2ea4b inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e66d5f55151b1e81bd391f0e044eed inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top"><a id="ae1e66d5f55151b1e81bd391f0e044eed" name="ae1e66d5f55151b1e81bd391f0e044eed"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxRigidActor</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:ae1e66d5f55151b1e81bd391f0e044eed inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44f9c3cd9442253412732cd0e4a4e3a inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top"><a id="ae44f9c3cd9442253412732cd0e4a4e3a" name="ae44f9c3cd9442253412732cd0e4a4e3a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PxRigidActor</b> ()</td></tr>
<tr class="separator:ae44f9c3cd9442253412732cd0e4a4e3a inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_actor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_actor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_actor.html">physx::PxActor</a></td></tr>
<tr class="memitem:a38b030b8d43f75ca6a0011d369369fdf inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="a38b030b8d43f75ca6a0011d369369fdf" name="a38b030b8d43f75ca6a0011d369369fdf"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxActor</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a38b030b8d43f75ca6a0011d369369fdf inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d98db236080d8bdb8f7dd179d84bde inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="ad8d98db236080d8bdb8f7dd179d84bde" name="ad8d98db236080d8bdb8f7dd179d84bde"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxActor</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:ad8d98db236080d8bdb8f7dd179d84bde inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a538ec41302af60afec0df10f31f4ab24">isKindOf</a> (const char *name) const</td></tr>
<tr class="memdesc:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a92f28ef9d2c863db69d316e68375fac5" name="a92f28ef9d2c863db69d316e68375fac5"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxBase</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor setting concrete type and base flags. <br /></td></tr>
<tr class="separator:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a4f41a74f151437e79ea1fb075df19cbc" name="a4f41a74f151437e79ea1fb075df19cbc"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxBase</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialization constructor setting base flags. <br /></td></tr>
<tr class="separator:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="adcee0bb92feaaaaeb2340d7304af1830" name="adcee0bb92feaaaaeb2340d7304af1830"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PxBase</b> ()</td></tr>
<tr class="memdesc:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a8645a6d66bcc1df05a82bf3be518cb55">isKindOf</a> (const char *superClass) const</td></tr>
<tr class="memdesc:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="abcfbbbce797c885d67969f6c5b975601" name="abcfbbbce797c885d67969f6c5b975601"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeMatch</b> () const</td></tr>
<tr class="separator:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:ad6a3f9870b95cebff97107058729852a inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="ad6a3f9870b95cebff97107058729852a" name="ad6a3f9870b95cebff97107058729852a"></a>
PxType&#160;</td><td class="memItemRight" valign="bottom"><b>mConcreteType</b></td></tr>
<tr class="separator:ad6a3f9870b95cebff97107058729852a inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24687e4fc96f1902f53cd4e0444c4482 inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a24687e4fc96f1902f53cd4e0444c4482" name="a24687e4fc96f1902f53cd4e0444c4482"></a>
<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mBaseFlags</b></td></tr>
<tr class="separator:a24687e4fc96f1902f53cd4e0444c4482 inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e247c6b6559031c784449e79396af0 inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a67e247c6b6559031c784449e79396af0" name="a67e247c6b6559031c784449e79396af0"></a>
PxU32&#160;</td><td class="memItemRight" valign="bottom"><b>mBuiltInRefCount</b></td></tr>
<tr class="separator:a67e247c6b6559031c784449e79396af0 inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classphysx_1_1_px_rigid_body.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> is a base class shared between dynamic rigid body objects. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD...">PxRigidActor</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acd9fd364b46b541261c703a718d1c551" name="acd9fd364b46b541261c703a718d1c551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9fd364b46b541261c703a718d1c551">&#9670;&#160;</a></span>addForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::addForce </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autowake</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mass. </p>
<p><b>This will not induce a torque</b>.</p>
<p>::PxForceMode determines if the force is to be conventional or impulsive.</p>
<p>Each actor has an acceleration and a velocity change accumulator which are directly modified using the modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2af9c11ae8dd4feac4e0b9bef3d29af2c2" title="parameter has unit of length/ time^2, i.e., an acceleration. It gets treated just like a force except...">PxForceMode::eACCELERATION</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ac1a871bce8c1a62fd55bed0695caeb36" title="parameter has unit of length / time, i.e., the effect is mass independent: a velocity change.">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505" title="parameter has unit of mass * length / time^2, i.e., a force">PxForceMode::eFORCE</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ae6aeaebd2e3df6183c88e70485fd5836" title="parameter has unit of mass * length / time, i.e., force * time">PxForceMode::eIMPULSE</a> also modify these same accumulators and are just short hand for multiplying the vector parameter by inverse mass and then using <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2af9c11ae8dd4feac4e0b9bef3d29af2c2" title="parameter has unit of length/ time^2, i.e., an acceleration. It gets treated just like a force except...">PxForceMode::eACCELERATION</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ac1a871bce8c1a62fd55bed0695caeb36" title="parameter has unit of length / time, i.e., the effect is mass independent: a velocity change.">PxForceMode::eVELOCITY_CHANGE</a> respectively.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd>
<dd>
The force modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ae6aeaebd2e3df6183c88e70485fd5836" title="parameter has unit of mass * length / time, i.e., force * time">PxForceMode::eIMPULSE</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ac1a871bce8c1a62fd55bed0695caeb36" title="parameter has unit of length / time, i.e., the effect is mass independent: a velocity change.">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.</dd>
<dd>
if this is called on an articulation link, only the link is updated, not the entire articulation.</dd>
<dd>
see <a class="el" href="classphysx_1_1_px_rigid_body_ext.html#ab4b2d526a96942fb192e789a8cb61fe4" title="Compute the change to linear and angular velocity that would occur if an impulsive force and torque w...">PxRigidBodyExt::computeVelocityDeltaFromImpulse</a> for details of how to compute the change in linear velocity that will arise from the application of an impulsive force, where an impulsive force is applied force multiplied by a timestep.</dd></dl>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the force is non-zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>Force/Impulse to apply defined in the global frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode to use when applying the force/impulse(see #PxForceMode) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autowake</td><td>Specify if the call should wake up the actor if it is currently asleep. If true and the current wake counter value is smaller than <a class="el" href="classphysx_1_1_px_scene_desc.html#a9fa76944edfb3c85dbc3c9009256f595" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_force_mode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out.">PxForceMode</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#a5da43ae58269860df73c0164cef0118b" title="Applies an impulsive torque defined in the global coordinate frame to the actor.">addTorque</a> </dd></dl>

</div>
</div>
<a id="a5da43ae58269860df73c0164cef0118b" name="a5da43ae58269860df73c0164cef0118b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da43ae58269860df73c0164cef0118b">&#9670;&#160;</a></span>addTorque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::addTorque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>torque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autowake</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an impulsive torque defined in the global coordinate frame to the actor. </p>
<p>::PxForceMode determines if the torque is to be conventional or impulsive.</p>
<p>Each actor has an angular acceleration and an angular velocity change accumulator which are directly modified using the modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2af9c11ae8dd4feac4e0b9bef3d29af2c2" title="parameter has unit of length/ time^2, i.e., an acceleration. It gets treated just like a force except...">PxForceMode::eACCELERATION</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ac1a871bce8c1a62fd55bed0695caeb36" title="parameter has unit of length / time, i.e., the effect is mass independent: a velocity change.">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505" title="parameter has unit of mass * length / time^2, i.e., a force">PxForceMode::eFORCE</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ae6aeaebd2e3df6183c88e70485fd5836" title="parameter has unit of mass * length / time, i.e., force * time">PxForceMode::eIMPULSE</a> also modify these same accumulators and are just short hand for multiplying the vector parameter by inverse inertia and then using <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2af9c11ae8dd4feac4e0b9bef3d29af2c2" title="parameter has unit of length/ time^2, i.e., an acceleration. It gets treated just like a force except...">PxForceMode::eACCELERATION</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ac1a871bce8c1a62fd55bed0695caeb36" title="parameter has unit of length / time, i.e., the effect is mass independent: a velocity change.">PxForceMode::eVELOCITY_CHANGE</a> respectively.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd>
<dd>
The force modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ae6aeaebd2e3df6183c88e70485fd5836" title="parameter has unit of mass * length / time, i.e., force * time">PxForceMode::eIMPULSE</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ac1a871bce8c1a62fd55bed0695caeb36" title="parameter has unit of length / time, i.e., the effect is mass independent: a velocity change.">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.</dd>
<dd>
if this called on an articulation link, only the link is updated, not the entire articulation.</dd>
<dd>
see <a class="el" href="classphysx_1_1_px_rigid_body_ext.html#ab4b2d526a96942fb192e789a8cb61fe4" title="Compute the change to linear and angular velocity that would occur if an impulsive force and torque w...">PxRigidBodyExt::computeVelocityDeltaFromImpulse</a> for details of how to compute the change in angular velocity that will arise from the application of an impulsive torque, where an impulsive torque is an applied torque multiplied by a timestep.</dd></dl>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the torque is non-zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">torque</td><td>Torque to apply defined in the global frame. <b>Range:</b> torque vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode to use when applying the force/impulse(see #PxForceMode). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autowake</td><td>Specify if the call should wake up the actor if it is currently asleep. If true and the current wake counter value is smaller than <a class="el" href="classphysx_1_1_px_scene_desc.html#a9fa76944edfb3c85dbc3c9009256f595" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_force_mode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out.">PxForceMode</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#acd9fd364b46b541261c703a718d1c551" title="Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mas...">addForce()</a> </dd></dl>

</div>
</div>
<a id="ad13e207785f48e70e89fe1965617e624" name="ad13e207785f48e70e89fe1965617e624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13e207785f48e70e89fe1965617e624">&#9670;&#160;</a></span>clearForce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::clearForce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the accumulated forces (sets the accumulated force back to zero). </p>
<p>Each actor has an acceleration and a velocity change accumulator which are directly modified using the modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2af9c11ae8dd4feac4e0b9bef3d29af2c2" title="parameter has unit of length/ time^2, i.e., an acceleration. It gets treated just like a force except...">PxForceMode::eACCELERATION</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ac1a871bce8c1a62fd55bed0695caeb36" title="parameter has unit of length / time, i.e., the effect is mass independent: a velocity change.">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505" title="parameter has unit of mass * length / time^2, i.e., a force">PxForceMode::eFORCE</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ae6aeaebd2e3df6183c88e70485fd5836" title="parameter has unit of mass * length / time, i.e., force * time">PxForceMode::eIMPULSE</a> also modify these same accumulators (see <a class="el" href="classphysx_1_1_px_rigid_body.html#acd9fd364b46b541261c703a718d1c551" title="Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mas...">PxRigidBody::addForce()</a> for details); therefore the effect of calling clearForce(PxForceMode::eFORCE) is equivalent to calling clearForce(PxForceMode::eACCELERATION), and the effect of calling clearForce(PxForceMode::eIMPULSE) is equivalent to calling clearForce(PxForceMode::eVELOCITY_CHANGE).</p>
<p>::PxForceMode determines if the cleared force is to be conventional or impulsive.</p>
<dl class="section note"><dt>Note</dt><dd>The force modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ae6aeaebd2e3df6183c88e70485fd5836" title="parameter has unit of mass * length / time, i.e., force * time">PxForceMode::eIMPULSE</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ac1a871bce8c1a62fd55bed0695caeb36" title="parameter has unit of length / time, i.e., the effect is mass independent: a velocity change.">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode to use when clearing the force/impulse(see #PxForceMode)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_force_mode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out.">PxForceMode</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#acd9fd364b46b541261c703a718d1c551" title="Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mas...">addForce</a> </dd></dl>

</div>
</div>
<a id="a8a3a753e5a8f1a00bf5691ebf0d66a55" name="a8a3a753e5a8f1a00bf5691ebf0d66a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3a753e5a8f1a00bf5691ebf0d66a55">&#9670;&#160;</a></span>clearTorque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::clearTorque </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the impulsive torque defined in the global coordinate frame to the actor. </p>
<p>::PxForceMode determines if the cleared torque is to be conventional or impulsive.</p>
<p>Each actor has an angular acceleration and a velocity change accumulator which are directly modified using the modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2af9c11ae8dd4feac4e0b9bef3d29af2c2" title="parameter has unit of length/ time^2, i.e., an acceleration. It gets treated just like a force except...">PxForceMode::eACCELERATION</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ac1a871bce8c1a62fd55bed0695caeb36" title="parameter has unit of length / time, i.e., the effect is mass independent: a velocity change.">PxForceMode::eVELOCITY_CHANGE</a> respectively. The modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505" title="parameter has unit of mass * length / time^2, i.e., a force">PxForceMode::eFORCE</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ae6aeaebd2e3df6183c88e70485fd5836" title="parameter has unit of mass * length / time, i.e., force * time">PxForceMode::eIMPULSE</a> also modify these same accumulators (see <a class="el" href="classphysx_1_1_px_rigid_body.html#a5da43ae58269860df73c0164cef0118b" title="Applies an impulsive torque defined in the global coordinate frame to the actor.">PxRigidBody::addTorque()</a> for details); therefore the effect of calling clearTorque(PxForceMode::eFORCE) is equivalent to calling clearTorque(PxForceMode::eACCELERATION), and the effect of calling clearTorque(PxForceMode::eIMPULSE) is equivalent to calling clearTorque(PxForceMode::eVELOCITY_CHANGE).</p>
<dl class="section note"><dt>Note</dt><dd>The force modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ae6aeaebd2e3df6183c88e70485fd5836" title="parameter has unit of mass * length / time, i.e., force * time">PxForceMode::eIMPULSE</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ac1a871bce8c1a62fd55bed0695caeb36" title="parameter has unit of length / time, i.e., the effect is mass independent: a velocity change.">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode to use when clearing the force/impulse(see #PxForceMode).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_force_mode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out.">PxForceMode</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#a5da43ae58269860df73c0164cef0118b" title="Applies an impulsive torque defined in the global coordinate frame to the actor.">addTorque</a> </dd></dl>

</div>
</div>
<a id="ad8d317a7d63bc32fa490eb3a39fc6844" name="ad8d317a7d63bc32fa490eb3a39fc6844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d317a7d63bc32fa490eb3a39fc6844">&#9670;&#160;</a></span>getAngularDamping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidBody::getAngularDamping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the angular damping coefficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The angular damping coefficient associated with this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#a97921d4c4fc44b5e34c9113f688abdf3" title="Sets the angular damping coefficient.">setAngularDamping()</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#a7f1f5404c4a54e143b9851aa5a5936af" title="Retrieves the linear damping coefficient.">getLinearDamping()</a> </dd></dl>

</div>
</div>
<a id="a0718c3215843b0c333665cb2caffca8d" name="a0718c3215843b0c333665cb2caffca8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0718c3215843b0c333665cb2caffca8d">&#9670;&#160;</a></span>getAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> physx::PxRigidBody::getAngularVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the angular velocity of the actor. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to use this method while the simulation is running (except during <a class="el" href="classphysx_1_1_px_scene.html#a9c63e5a0e592a434b8647c98e569aed4" title="Performs collision detection for the scene over elapsedTime.">PxScene::collide()</a>, in <a class="el" href="classphysx_1_1_px_contact_modify_callback.html" title="An interface class that the user can implement in order to modify contact constraints.">PxContactModifyCallback</a> or in contact report callbacks).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The angular velocity of the actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6ad3c1668c33b479282d7098804bc6ec" title="Sets the angular velocity of the actor.">PxRigidDynamic.setAngularVelocity()</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#ae2739d0560b5681034deb063fe6916f3" title="Retrieves the linear velocity of an actor.">getLinearVelocity()</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_px_articulation_link.html#a1e293ac8aec1f35cd143f34948b49a44">physx::PxArticulationLink</a>, and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6fcf6611fa954275cdbcd290691ca76c">physx::PxRigidDynamic</a>.</p>

</div>
</div>
<a id="a33a7df384ad4cada38535d7d5ffa77a6" name="a33a7df384ad4cada38535d7d5ffa77a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a7df384ad4cada38535d7d5ffa77a6">&#9670;&#160;</a></span>getCMassLocalPose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> physx::PxRigidBody::getCMassLocalPose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the center of mass pose relative to the actor frame. </p>
<dl class="section return"><dt>Returns</dt><dd>The center of mass pose relative to the actor frame.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#a9038be016fffefba405ce6a083bc1936" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a> PxRigidBodyDesc.massLocalPose </dd></dl>

</div>
</div>
<a id="a60939f0d306255f906f9c9626a69a3e5" name="a60939f0d306255f906f9c9626a69a3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60939f0d306255f906f9c9626a69a3e5">&#9670;&#160;</a></span>getContactSlopCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidBody::getContactSlopCoefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the contact slop coefficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The contact slop coefficient.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#a29704224fe61cc77002d290b1bbe0bb8" title="Sets a distance scale whereby the angular influence of a contact on the normal constraint in a contac...">setContactSlopCoefficient</a> </dd></dl>

</div>
</div>
<a id="a82b68a2d6ca702401da6ddbe165fae35" name="a82b68a2d6ca702401da6ddbe165fae35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b68a2d6ca702401da6ddbe165fae35">&#9670;&#160;</a></span>getInternalIslandNodeIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_node_index.html">PxNodeIndex</a> physx::PxRigidBody::getInternalIslandNodeIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the island node index. </p>
<dl class="section return"><dt>Returns</dt><dd>The island node index. </dd></dl>

</div>
</div>
<a id="ae450dc383abe68f94c54d4f705811b15" name="ae450dc383abe68f94c54d4f705811b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae450dc383abe68f94c54d4f705811b15">&#9670;&#160;</a></span>getInvMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidBody::getInvMass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the inverse mass of the actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The inverse mass of this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#ad0fb1b366d9b26a06a2b20c52fa709f8" title="Sets the mass of a dynamic actor.">setMass()</a> PxRigidBodyDesc.mass <a class="el" href="classphysx_1_1_px_rigid_body.html#a17df2c95e1f0a096aa3ebec1cd167656" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> </dd></dl>

</div>
</div>
<a id="a7f1f5404c4a54e143b9851aa5a5936af" name="a7f1f5404c4a54e143b9851aa5a5936af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1f5404c4a54e143b9851aa5a5936af">&#9670;&#160;</a></span>getLinearDamping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidBody::getLinearDamping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the linear damping coefficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The linear damping coefficient associated with this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#a87cbe4f374180181c45d65562aa29098" title="Sets the linear damping coefficient.">setLinearDamping()</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#ad8d317a7d63bc32fa490eb3a39fc6844" title="Retrieves the angular damping coefficient.">getAngularDamping()</a> </dd></dl>

</div>
</div>
<a id="ae2739d0560b5681034deb063fe6916f3" name="ae2739d0560b5681034deb063fe6916f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2739d0560b5681034deb063fe6916f3">&#9670;&#160;</a></span>getLinearVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> physx::PxRigidBody::getLinearVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the linear velocity of an actor. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to use this method while the simulation is running (except during <a class="el" href="classphysx_1_1_px_scene.html#a9c63e5a0e592a434b8647c98e569aed4" title="Performs collision detection for the scene over elapsedTime.">PxScene::collide()</a>, in <a class="el" href="classphysx_1_1_px_contact_modify_callback.html" title="An interface class that the user can implement in order to modify contact constraints.">PxContactModifyCallback</a> or in contact report callbacks).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The linear velocity of the actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6ed77febd573d1f3969f1d18b6c6822a" title="Sets the linear velocity of the actor.">PxRigidDynamic.setLinearVelocity()</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#a0718c3215843b0c333665cb2caffca8d" title="Retrieves the angular velocity of the actor.">getAngularVelocity()</a> </dd></dl>

<p>Implemented in <a class="el" href="classphysx_1_1_px_articulation_link.html#ab5527a81319cf5385ee2805b6cf607ca">physx::PxArticulationLink</a>, and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a85e22669a3296cc6c2a2161606d7c887">physx::PxRigidDynamic</a>.</p>

</div>
</div>
<a id="ac2aef661dfca7aa4ce904c4606442509" name="ac2aef661dfca7aa4ce904c4606442509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2aef661dfca7aa4ce904c4606442509">&#9670;&#160;</a></span>getMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidBody::getMass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the mass of the actor. </p>
<dl class="section note"><dt>Note</dt><dd>A value of 0 is interpreted as infinite mass.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The mass of this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#ad0fb1b366d9b26a06a2b20c52fa709f8" title="Sets the mass of a dynamic actor.">setMass()</a> PxRigidBodyDesc.mass <a class="el" href="classphysx_1_1_px_rigid_body.html#a17df2c95e1f0a096aa3ebec1cd167656" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> </dd></dl>

</div>
</div>
<a id="a9605908d991d0d6be27e690a55c27d00" name="a9605908d991d0d6be27e690a55c27d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9605908d991d0d6be27e690a55c27d00">&#9670;&#160;</a></span>getMassSpaceInertiaTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> physx::PxRigidBody::getMassSpaceInertiaTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame. </p>
<p>This method retrieves a mass frame inertia vector.</p>
<dl class="section return"><dt>Returns</dt><dd>The mass space inertia tensor of this actor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A value of 0 in an element is interpreted as infinite inertia along that axis.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>PxRigidBodyDesc.massSpaceInertia <a class="el" href="classphysx_1_1_px_rigid_body.html#a17df2c95e1f0a096aa3ebec1cd167656" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#ad0fb1b366d9b26a06a2b20c52fa709f8" title="Sets the mass of a dynamic actor.">setMass()</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#a9038be016fffefba405ce6a083bc1936" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a> </dd></dl>

</div>
</div>
<a id="a88d24a7c452595426d738300802a2a7d" name="a88d24a7c452595426d738300802a2a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d24a7c452595426d738300802a2a7d">&#9670;&#160;</a></span>getMassSpaceInvInertiaTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> physx::PxRigidBody::getMassSpaceInvInertiaTensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the diagonal inverse inertia tensor of the actor relative to the mass coordinate frame. </p>
<p>This method retrieves a mass frame inverse inertia vector.</p>
<dl class="section note"><dt>Note</dt><dd>A value of 0 in an element is interpreted as infinite inertia along that axis.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The mass space inverse inertia tensor of this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>PxRigidBodyDesc.massSpaceInertia <a class="el" href="classphysx_1_1_px_rigid_body.html#a17df2c95e1f0a096aa3ebec1cd167656" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#ad0fb1b366d9b26a06a2b20c52fa709f8" title="Sets the mass of a dynamic actor.">setMass()</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#a9038be016fffefba405ce6a083bc1936" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a> </dd></dl>

</div>
</div>
<a id="af2aedd3e236650303e840e7a9b885339" name="af2aedd3e236650303e840e7a9b885339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2aedd3e236650303e840e7a9b885339">&#9670;&#160;</a></span>getMaxAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidBody::getMaxAngularVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the maximum angular velocity permitted for this actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum allowed angular velocity for this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#a3c7ffce7c2a92546abd7a07cdbc67c76" title="Lets you set the maximum angular velocity permitted for this actor.">setMaxAngularVelocity</a> </dd></dl>

</div>
</div>
<a id="afc3efe30e7ceaae6694bb80fd0567820" name="afc3efe30e7ceaae6694bb80fd0567820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3efe30e7ceaae6694bb80fd0567820">&#9670;&#160;</a></span>getMaxContactImpulse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidBody::getMaxContactImpulse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum impulse that may be applied at a contact. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum impulse that may be applied at a contact</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#a5a0616e1ce7f675243220ce94f8eb23e" title="Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact betwee...">setMaxContactImpulse</a> </dd></dl>

</div>
</div>
<a id="a8b8a85ec0bf904443aaa1897f72bd0d5" name="a8b8a85ec0bf904443aaa1897f72bd0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8a85ec0bf904443aaa1897f72bd0d5">&#9670;&#160;</a></span>getMaxDepenetrationVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidBody::getMaxDepenetrationVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum depenetration velocity the solver is permitted to introduced. This value controls how much velocity the solver can introduce to correct for penetrations in contacts. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum penetration bias applied by the solver. </dd></dl>

</div>
</div>
<a id="acc31a61c9865b6de27c448b320b06dbf" name="acc31a61c9865b6de27c448b320b06dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc31a61c9865b6de27c448b320b06dbf">&#9670;&#160;</a></span>getMaxLinearVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidBody::getMaxLinearVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the maximum angular velocity permitted for this actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum allowed angular velocity for this actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#afd4c80d576f21a6fb45884d6584b08b5" title="Lets you set the maximum linear velocity permitted for this actor.">setMaxLinearVelocity</a> </dd></dl>

</div>
</div>
<a id="ab5cc5fcce42853bb3f718c2c78782eb6" name="ab5cc5fcce42853bb3f718c2c78782eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cc5fcce42853bb3f718c2c78782eb6">&#9670;&#160;</a></span>getMinCCDAdvanceCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidBody::getMinCCDAdvanceCoefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the CCD minimum advance coefficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the CCD min advance coefficient.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#aef05905d355a51c91f71c99f0ab3a990" title="Sets the CCD minimum advance coefficient.">setMinCCDAdvanceCoefficient</a> </dd></dl>

</div>
</div>
<a id="a864acc2c28d314bb3074f7997cb1d910" name="a864acc2c28d314bb3074f7997cb1d910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864acc2c28d314bb3074f7997cb1d910">&#9670;&#160;</a></span>getRigidBodyFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacephysx.html#a97e228a8044f5674ef80a0195012f401">PxRigidBodyFlags</a> physx::PxRigidBody::getRigidBodyFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the <a class="el" href="classphysx_1_1_px_rigid_body.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> flags. </p>
<p>See the list of flags #PxRigidBodyFlag</p>
<dl class="section return"><dt>Returns</dt><dd>The values of the <a class="el" href="classphysx_1_1_px_rigid_body.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> flags.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_rigid_body_flag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#ab85350efb9b525a6cf0de079d959d8c4" title="Raises or clears a particular rigid body flag.">setRigidBodyFlag()</a> </dd></dl>

</div>
</div>
<a id="a231f75c8948a5b712453b18339a4bae1" name="a231f75c8948a5b712453b18339a4bae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231f75c8948a5b712453b18339a4bae1">&#9670;&#160;</a></span>isKindOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::PxRigidBody::isKindOf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>superClass</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a given type name matches with the type of this instance. </p>

<p>Reimplemented from <a class="el" href="classphysx_1_1_px_rigid_actor.html#a48fe39a001529118d4e2a2a25841a013">physx::PxRigidActor</a>.</p>

<p>Reimplemented in <a class="el" href="classphysx_1_1_px_articulation_link.html#ae8dd3a041558425f88dcb10ff0c880b4">physx::PxArticulationLink</a>, and <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a24e7bb6ab20e7d635c9263fba2f283ed">physx::PxRigidDynamic</a>.</p>

</div>
</div>
<a id="a97921d4c4fc44b5e34c9113f688abdf3" name="a97921d4c4fc44b5e34c9113f688abdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97921d4c4fc44b5e34c9113f688abdf3">&#9670;&#160;</a></span>setAngularDamping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setAngularDamping </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>angDamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the angular damping coefficient. </p>
<p>Zero represents no damping.</p>
<p>The angular damping coefficient must be nonnegative.</p>
<p><b>Default:</b> 0.05</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angDamp</td><td>Angular damping coefficient. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#ad8d317a7d63bc32fa490eb3a39fc6844" title="Retrieves the angular damping coefficient.">getAngularDamping()</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#a87cbe4f374180181c45d65562aa29098" title="Sets the linear damping coefficient.">setLinearDamping()</a> </dd></dl>

</div>
</div>
<a id="a9038be016fffefba405ce6a083bc1936" name="a9038be016fffefba405ce6a083bc1936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9038be016fffefba405ce6a083bc1936">&#9670;&#160;</a></span>setCMassLocalPose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setCMassLocalPose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>pose</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the pose of the center of mass relative to the actor. <br  />
 </p>
<dl class="section note"><dt>Note</dt><dd>Changing this transform will not move the actor in the world!</dd>
<dd>
Setting an unrealistic center of mass which is a long way from the body can make it difficult for the SDK to solve constraints. Perhaps leading to instability and jittering bodies.</dd></dl>
<p><b>Default:</b> the identity transform</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pose</td><td>Mass frame offset transform relative to the actor frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#a33a7df384ad4cada38535d7d5ffa77a6" title="Retrieves the center of mass pose relative to the actor frame.">getCMassLocalPose()</a> PxRigidBodyDesc.massLocalPose </dd></dl>

</div>
</div>
<a id="a29704224fe61cc77002d290b1bbe0bb8" name="a29704224fe61cc77002d290b1bbe0bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29704224fe61cc77002d290b1bbe0bb8">&#9670;&#160;</a></span>setContactSlopCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setContactSlopCoefficient </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>slopCoefficient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a distance scale whereby the angular influence of a contact on the normal constraint in a contact is zeroed if normal.cross(offset) falls below this tolerance. Rather than acting as an absolute value, this tolerance is scaled by the ratio rXn.dot(angVel)/normal.dot(linVel) such that contacts that have relatively larger angular velocity than linear normal velocity (e.g. rolling wheels) achieve larger slop values as the angular velocity increases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slopCoefficient</td><td>the Slop coefficient. <b>Range:</b> [0, PX_MAX_F32] <b>Default:</b> 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#a60939f0d306255f906f9c9626a69a3e5" title="Returns the contact slop coefficient.">getContactSlopCoefficient</a> </dd></dl>

</div>
</div>
<a id="a8d643ffccf6fefb0b39c609c2e474f75" name="a8d643ffccf6fefb0b39c609c2e474f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d643ffccf6fefb0b39c609c2e474f75">&#9670;&#160;</a></span>setForceAndTorque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setForceAndTorque </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>torque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the impulsive force and torque defined in the global coordinate frame to the actor. </p>
<p>::PxForceMode determines if the cleared torque is to be conventional or impulsive.</p>
<dl class="section note"><dt>Note</dt><dd>The force modes <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ae6aeaebd2e3df6183c88e70485fd5836" title="parameter has unit of mass * length / time, i.e., force * time">PxForceMode::eIMPULSE</a> and <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2ac1a871bce8c1a62fd55bed0695caeb36" title="parameter has unit of length / time, i.e., the effect is mass independent: a velocity change.">PxForceMode::eVELOCITY_CHANGE</a> can not be applied to articulation links.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_force_mode.html" title="Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out.">PxForceMode</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#a5da43ae58269860df73c0164cef0118b" title="Applies an impulsive torque defined in the global coordinate frame to the actor.">addTorque</a> </dd></dl>

</div>
</div>
<a id="a87cbe4f374180181c45d65562aa29098" name="a87cbe4f374180181c45d65562aa29098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87cbe4f374180181c45d65562aa29098">&#9670;&#160;</a></span>setLinearDamping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setLinearDamping </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>linDamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the linear damping coefficient. </p>
<p>Zero represents no damping. The damping coefficient must be nonnegative.</p>
<p><b>Default:</b> 0.0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">linDamp</td><td>Linear damping coefficient. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#a7f1f5404c4a54e143b9851aa5a5936af" title="Retrieves the linear damping coefficient.">getLinearDamping()</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#a97921d4c4fc44b5e34c9113f688abdf3" title="Sets the angular damping coefficient.">setAngularDamping()</a> </dd></dl>

</div>
</div>
<a id="ad0fb1b366d9b26a06a2b20c52fa709f8" name="ad0fb1b366d9b26a06a2b20c52fa709f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0fb1b366d9b26a06a2b20c52fa709f8">&#9670;&#160;</a></span>setMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setMass </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>mass</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mass of a dynamic actor. </p>
<p>The mass must be non-negative.</p>
<p><a class="el" href="classphysx_1_1_px_rigid_body.html#ad0fb1b366d9b26a06a2b20c52fa709f8" title="Sets the mass of a dynamic actor.">setMass()</a> does not update the inertial properties of the body, to change the inertia tensor use <a class="el" href="classphysx_1_1_px_rigid_body.html#a17df2c95e1f0a096aa3ebec1cd167656" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> or the PhysX extensions method <a class="el" href="classphysx_1_1_px_rigid_body_ext.html#a678c51b0b07b67123352695013bf192a" title="Computation of mass properties for a rigid body actor.">PxRigidBodyExt::updateMassAndInertia()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>A value of 0 is interpreted as infinite mass. </dd>
<dd>
Values of 0 are not permitted for instances of <a class="el" href="classphysx_1_1_px_articulation_link.html" title="A component of an articulation that represents a rigid body.">PxArticulationLink</a> but are permitted for instances of <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>.</dd></dl>
<p><b>Default:</b> 1.0</p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mass</td><td>New mass value for the actor. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#ac2aef661dfca7aa4ce904c4606442509" title="Retrieves the mass of the actor.">getMass()</a> PxRigidBodyDesc.mass <a class="el" href="classphysx_1_1_px_rigid_body.html#a17df2c95e1f0a096aa3ebec1cd167656" title="Sets the inertia tensor, using a parameter specified in mass space coordinates.">setMassSpaceInertiaTensor()</a> </dd></dl>

</div>
</div>
<a id="a17df2c95e1f0a096aa3ebec1cd167656" name="a17df2c95e1f0a096aa3ebec1cd167656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17df2c95e1f0a096aa3ebec1cd167656">&#9670;&#160;</a></span>setMassSpaceInertiaTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setMassSpaceInertiaTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the inertia tensor, using a parameter specified in mass space coordinates. </p>
<p>Note that such matrices are diagonal &ndash; the passed vector is the diagonal.</p>
<p>If you have a non diagonal world/actor space inertia tensor(3x3 matrix). Then you need to diagonalize it and set an appropriate mass space transform. See <a class="el" href="classphysx_1_1_px_rigid_body.html#a9038be016fffefba405ce6a083bc1936" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a>.</p>
<p>The inertia tensor elements must be non-negative.</p>
<dl class="section note"><dt>Note</dt><dd>A value of 0 in an element is interpreted as infinite inertia along that axis. </dd>
<dd>
Values of 0 are not permitted for instances of <a class="el" href="classphysx_1_1_px_articulation_link.html" title="A component of an articulation that represents a rigid body.">PxArticulationLink</a> but are permitted for instances of <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a>.</dd></dl>
<p><b>Default:</b> (1.0, 1.0, 1.0)</p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>New mass space inertia tensor for the actor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>PxRigidBodyDesc.massSpaceInertia getMassSpaceInertia() <a class="el" href="classphysx_1_1_px_rigid_body.html#ad0fb1b366d9b26a06a2b20c52fa709f8" title="Sets the mass of a dynamic actor.">setMass()</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#a9038be016fffefba405ce6a083bc1936" title="Sets the pose of the center of mass relative to the actor.">setCMassLocalPose()</a> </dd></dl>

</div>
</div>
<a id="a3c7ffce7c2a92546abd7a07cdbc67c76" name="a3c7ffce7c2a92546abd7a07cdbc67c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7ffce7c2a92546abd7a07cdbc67c76">&#9670;&#160;</a></span>setMaxAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setMaxAngularVelocity </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>maxAngVel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lets you set the maximum angular velocity permitted for this actor. </p>
<p>For various internal computations, very quickly rotating actors introduce error into the simulation, which leads to undesired results.</p>
<p>With this function, you can set the maximum angular velocity permitted for this rigid body. Higher angular velocities are clamped to this value.</p>
<p>Note: The angular velocity is clamped to the set value <em>before</em> the solver, which means that the limit may still be momentarily exceeded.</p>
<p><b>Default:</b> 100.0</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxAngVel</td><td>Max allowable angular velocity for actor. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#af2aedd3e236650303e840e7a9b885339" title="Retrieves the maximum angular velocity permitted for this actor.">getMaxAngularVelocity()</a> </dd></dl>

</div>
</div>
<a id="a5a0616e1ce7f675243220ce94f8eb23e" name="a5a0616e1ce7f675243220ce94f8eb23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0616e1ce7f675243220ce94f8eb23e">&#9670;&#160;</a></span>setMaxContactImpulse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setMaxContactImpulse </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>maxImpulse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxImpulse</td><td>the maximum contact impulse. <b>Range:</b> [0, PX_MAX_F32] <b>Default:</b> PX_MAX_F32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#afc3efe30e7ceaae6694bb80fd0567820" title="Returns the maximum impulse that may be applied at a contact.">getMaxContactImpulse</a> </dd></dl>

</div>
</div>
<a id="a4f892df807dac059cabe4ac699aa8104" name="a4f892df807dac059cabe4ac699aa8104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f892df807dac059cabe4ac699aa8104">&#9670;&#160;</a></span>setMaxDepenetrationVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setMaxDepenetrationVelocity </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>biasClamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum depenetration velocity permitted to be introduced by the solver. This value controls how much velocity the solver can introduce to correct for penetrations in contacts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">biasClamp</td><td>The maximum velocity to de-penetrate by <b>Range:</b> (0, PX_MAX_F32]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd4c80d576f21a6fb45884d6584b08b5" name="afd4c80d576f21a6fb45884d6584b08b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4c80d576f21a6fb45884d6584b08b5">&#9670;&#160;</a></span>setMaxLinearVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setMaxLinearVelocity </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>maxLinVel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lets you set the maximum linear velocity permitted for this actor. </p>
<p>With this function, you can set the maximum linear velocity permitted for this rigid body. Higher angular velocities are clamped to this value.</p>
<p>Note: The angular velocity is clamped to the set value <em>before</em> the solver, which means that the limit may still be momentarily exceeded.</p>
<p><b>Default:</b> PX_MAX_F32</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxLinVel</td><td>Max allowable linear velocity for actor. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html#af2aedd3e236650303e840e7a9b885339" title="Retrieves the maximum angular velocity permitted for this actor.">getMaxAngularVelocity()</a> </dd></dl>

</div>
</div>
<a id="aef05905d355a51c91f71c99f0ab3a990" name="aef05905d355a51c91f71c99f0ab3a990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef05905d355a51c91f71c99f0ab3a990">&#9670;&#160;</a></span>setMinCCDAdvanceCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setMinCCDAdvanceCoefficient </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>advanceCoefficient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the CCD minimum advance coefficient. </p>
<p>The CCD minimum advance coefficient is a value in the range [0, 1] that is used to control the minimum amount of time a body is integrated when it has a CCD contact. The actual minimum amount of time that is integrated depends on various properties, including the relative speed and collision shapes of the bodies involved in the contact. From these properties, a numeric value is calculated that determines the maximum distance (and therefore maximum time) which these bodies could be integrated forwards that would ensure that these bodies did not pass through each-other. This value is then scaled by CCD minimum advance coefficient to determine the amount of time that will be consumed in the CCD pass.</p>
<p><b>Things to consider:</b> A large value (approaching 1) ensures that the objects will always advance some time. However, larger values increase the chances of objects gently drifting through each-other in scenes which the constraint solver can't converge, e.g. scenes where an object is being dragged through a wall with a constraint. A value of 0 ensures that the pair of objects stop at the exact time-of-impact and will not gently drift through each-other. However, with very small/thin objects initially in contact, this can lead to a large amount of time being dropped and increases the chances of jamming. Jamming occurs when the an object is persistently in contact with an object such that the time-of-impact is 0, which results in no time being advanced for those objects in that CCD pass.</p>
<p>The chances of jamming can be reduced by increasing the number of CCD mass </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_scene_desc.html#a735fcf1c8af0365502ddac996b0e196d" title="Maximum number of CCD passes.">PxSceneDesc.ccdMaxPasses</a>. However, increasing this number increases the CCD overhead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">advanceCoefficient</td><td>The CCD min advance coefficient. <b>Range:</b> [0, 1] <b>Default:</b> 0.15 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab85350efb9b525a6cf0de079d959d8c4" name="ab85350efb9b525a6cf0de079d959d8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85350efb9b525a6cf0de079d959d8c4">&#9670;&#160;</a></span>setRigidBodyFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidBody::setRigidBodyFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_rigid_body_flag.html#ae3a4da7ce0535fdd127728674e060869">PxRigidBodyFlag::Enum</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raises or clears a particular rigid body flag. </p>
<p>See the list of flags #PxRigidBodyFlag</p>
<p><b>Default:</b> no flags are set</p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the actor up automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>The <a class="el" href="classphysx_1_1_px_rigid_body.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> flag to raise(set) or clear. See #PxRigidBodyFlag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The new boolean value for the flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_rigid_body_flag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#a864acc2c28d314bb3074f7997cb1d910" title="Reads the PxRigidBody flags.">getRigidBodyFlags()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="_px_rigid_body_8h_source.html">PxRigidBody.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacephysx.html">physx</a></li><li class="navelem"><a class="el" href="classphysx_1_1_px_rigid_body.html">PxRigidBody</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
