<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PhysX: physx::PxRigidDynamic Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PhysX<span id="projectnumber">&#160;5.1.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classphysx_1_1_px_rigid_dynamic.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="classphysx_1_1_px_rigid_dynamic-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">physx::PxRigidDynamic Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> represents a dynamic rigid simulation object in the physics SDK.  
 <a href="classphysx_1_1_px_rigid_dynamic.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_px_rigid_dynamic_8h_source.html">PxRigidDynamic.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for physx::PxRigidDynamic:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classphysx_1_1_px_rigid_dynamic.png" usemap="#physx::PxRigidDynamic_map" alt=""/>
  <map id="physx::PxRigidDynamic_map" name="physx::PxRigidDynamic_map">
<area href="classphysx_1_1_px_rigid_body.html" title="PxRigidBody is a base class shared between dynamic rigid body objects." alt="physx::PxRigidBody" shape="rect" coords="0,168,142,192"/>
<area href="classphysx_1_1_px_rigid_actor.html" title="PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SD..." alt="physx::PxRigidActor" shape="rect" coords="0,112,142,136"/>
<area href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="physx::PxActor" shape="rect" coords="0,56,142,80"/>
<area href="classphysx_1_1_px_base.html" title="Base class for objects that can be members of a PxCollection." alt="physx::PxBase" shape="rect" coords="0,0,142,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Kinematic Actors</div></td></tr>
<tr class="memitem:ac63b42588e1abbc80ba22735d975f498"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#ac63b42588e1abbc80ba22735d975f498">setKinematicTarget</a> (const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;destination)=0</td></tr>
<tr class="memdesc:ac63b42588e1abbc80ba22735d975f498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves kinematically controlled dynamic actors through the game world.  <br /></td></tr>
<tr class="separator:ac63b42588e1abbc80ba22735d975f498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ad06a0a2c871c17ea8122975af9b22"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#ac4ad06a0a2c871c17ea8122975af9b22">getKinematicTarget</a> (<a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;target) const =0</td></tr>
<tr class="memdesc:ac4ad06a0a2c871c17ea8122975af9b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get target pose of a kinematically controlled dynamic actor.  <br /></td></tr>
<tr class="separator:ac4ad06a0a2c871c17ea8122975af9b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_rigid_body"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_rigid_body')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_rigid_body.html">physx::PxRigidBody</a></td></tr>
<tr class="memitem:a9038be016fffefba405ce6a083bc1936 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a9038be016fffefba405ce6a083bc1936">setCMassLocalPose</a> (const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;pose)=0</td></tr>
<tr class="memdesc:a9038be016fffefba405ce6a083bc1936 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pose of the center of mass relative to the actor. <br  />
  <br /></td></tr>
<tr class="separator:a9038be016fffefba405ce6a083bc1936 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7df384ad4cada38535d7d5ffa77a6 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a33a7df384ad4cada38535d7d5ffa77a6">getCMassLocalPose</a> () const =0</td></tr>
<tr class="memdesc:a33a7df384ad4cada38535d7d5ffa77a6 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the center of mass pose relative to the actor frame.  <br /></td></tr>
<tr class="separator:a33a7df384ad4cada38535d7d5ffa77a6 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fb1b366d9b26a06a2b20c52fa709f8 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ad0fb1b366d9b26a06a2b20c52fa709f8">setMass</a> (PxReal mass)=0</td></tr>
<tr class="memdesc:ad0fb1b366d9b26a06a2b20c52fa709f8 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mass of a dynamic actor.  <br /></td></tr>
<tr class="separator:ad0fb1b366d9b26a06a2b20c52fa709f8 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aef661dfca7aa4ce904c4606442509 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ac2aef661dfca7aa4ce904c4606442509">getMass</a> () const =0</td></tr>
<tr class="memdesc:ac2aef661dfca7aa4ce904c4606442509 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the mass of the actor.  <br /></td></tr>
<tr class="separator:ac2aef661dfca7aa4ce904c4606442509 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae450dc383abe68f94c54d4f705811b15 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ae450dc383abe68f94c54d4f705811b15">getInvMass</a> () const =0</td></tr>
<tr class="memdesc:ae450dc383abe68f94c54d4f705811b15 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the inverse mass of the actor.  <br /></td></tr>
<tr class="separator:ae450dc383abe68f94c54d4f705811b15 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17df2c95e1f0a096aa3ebec1cd167656 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a17df2c95e1f0a096aa3ebec1cd167656">setMassSpaceInertiaTensor</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;m)=0</td></tr>
<tr class="memdesc:a17df2c95e1f0a096aa3ebec1cd167656 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the inertia tensor, using a parameter specified in mass space coordinates.  <br /></td></tr>
<tr class="separator:a17df2c95e1f0a096aa3ebec1cd167656 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9605908d991d0d6be27e690a55c27d00 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a9605908d991d0d6be27e690a55c27d00">getMassSpaceInertiaTensor</a> () const =0</td></tr>
<tr class="memdesc:a9605908d991d0d6be27e690a55c27d00 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the diagonal inertia tensor of the actor relative to the mass coordinate frame.  <br /></td></tr>
<tr class="separator:a9605908d991d0d6be27e690a55c27d00 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d24a7c452595426d738300802a2a7d inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a88d24a7c452595426d738300802a2a7d">getMassSpaceInvInertiaTensor</a> () const =0</td></tr>
<tr class="memdesc:a88d24a7c452595426d738300802a2a7d inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the diagonal inverse inertia tensor of the actor relative to the mass coordinate frame.  <br /></td></tr>
<tr class="separator:a88d24a7c452595426d738300802a2a7d inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cbe4f374180181c45d65562aa29098 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a87cbe4f374180181c45d65562aa29098">setLinearDamping</a> (PxReal linDamp)=0</td></tr>
<tr class="memdesc:a87cbe4f374180181c45d65562aa29098 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the linear damping coefficient.  <br /></td></tr>
<tr class="separator:a87cbe4f374180181c45d65562aa29098 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1f5404c4a54e143b9851aa5a5936af inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a7f1f5404c4a54e143b9851aa5a5936af">getLinearDamping</a> () const =0</td></tr>
<tr class="memdesc:a7f1f5404c4a54e143b9851aa5a5936af inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the linear damping coefficient.  <br /></td></tr>
<tr class="separator:a7f1f5404c4a54e143b9851aa5a5936af inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97921d4c4fc44b5e34c9113f688abdf3 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a97921d4c4fc44b5e34c9113f688abdf3">setAngularDamping</a> (PxReal angDamp)=0</td></tr>
<tr class="memdesc:a97921d4c4fc44b5e34c9113f688abdf3 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the angular damping coefficient.  <br /></td></tr>
<tr class="separator:a97921d4c4fc44b5e34c9113f688abdf3 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d317a7d63bc32fa490eb3a39fc6844 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ad8d317a7d63bc32fa490eb3a39fc6844">getAngularDamping</a> () const =0</td></tr>
<tr class="memdesc:ad8d317a7d63bc32fa490eb3a39fc6844 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the angular damping coefficient.  <br /></td></tr>
<tr class="separator:ad8d317a7d63bc32fa490eb3a39fc6844 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4c80d576f21a6fb45884d6584b08b5 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#afd4c80d576f21a6fb45884d6584b08b5">setMaxLinearVelocity</a> (PxReal maxLinVel)=0</td></tr>
<tr class="memdesc:afd4c80d576f21a6fb45884d6584b08b5 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets you set the maximum linear velocity permitted for this actor.  <br /></td></tr>
<tr class="separator:afd4c80d576f21a6fb45884d6584b08b5 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc31a61c9865b6de27c448b320b06dbf inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#acc31a61c9865b6de27c448b320b06dbf">getMaxLinearVelocity</a> () const =0</td></tr>
<tr class="memdesc:acc31a61c9865b6de27c448b320b06dbf inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum angular velocity permitted for this actor.  <br /></td></tr>
<tr class="separator:acc31a61c9865b6de27c448b320b06dbf inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7ffce7c2a92546abd7a07cdbc67c76 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a3c7ffce7c2a92546abd7a07cdbc67c76">setMaxAngularVelocity</a> (PxReal maxAngVel)=0</td></tr>
<tr class="memdesc:a3c7ffce7c2a92546abd7a07cdbc67c76 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets you set the maximum angular velocity permitted for this actor.  <br /></td></tr>
<tr class="separator:a3c7ffce7c2a92546abd7a07cdbc67c76 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2aedd3e236650303e840e7a9b885339 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#af2aedd3e236650303e840e7a9b885339">getMaxAngularVelocity</a> () const =0</td></tr>
<tr class="memdesc:af2aedd3e236650303e840e7a9b885339 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum angular velocity permitted for this actor.  <br /></td></tr>
<tr class="separator:af2aedd3e236650303e840e7a9b885339 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9fd364b46b541261c703a718d1c551 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#acd9fd364b46b541261c703a718d1c551">addForce</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;force, <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a> mode=<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a>, bool autowake=true)=0</td></tr>
<tr class="memdesc:acd9fd364b46b541261c703a718d1c551 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame to the actor at its center of mass.  <br /></td></tr>
<tr class="separator:acd9fd364b46b541261c703a718d1c551 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da43ae58269860df73c0164cef0118b inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a5da43ae58269860df73c0164cef0118b">addTorque</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;torque, <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a> mode=<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a>, bool autowake=true)=0</td></tr>
<tr class="memdesc:a5da43ae58269860df73c0164cef0118b inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an impulsive torque defined in the global coordinate frame to the actor.  <br /></td></tr>
<tr class="separator:a5da43ae58269860df73c0164cef0118b inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13e207785f48e70e89fe1965617e624 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ad13e207785f48e70e89fe1965617e624">clearForce</a> (<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a> mode=<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:ad13e207785f48e70e89fe1965617e624 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the accumulated forces (sets the accumulated force back to zero).  <br /></td></tr>
<tr class="separator:ad13e207785f48e70e89fe1965617e624 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3a753e5a8f1a00bf5691ebf0d66a55 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a8a3a753e5a8f1a00bf5691ebf0d66a55">clearTorque</a> (<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a> mode=<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:a8a3a753e5a8f1a00bf5691ebf0d66a55 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the impulsive torque defined in the global coordinate frame to the actor.  <br /></td></tr>
<tr class="separator:a8a3a753e5a8f1a00bf5691ebf0d66a55 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d643ffccf6fefb0b39c609c2e474f75 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a8d643ffccf6fefb0b39c609c2e474f75">setForceAndTorque</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;force, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;torque, <a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2">PxForceMode::Enum</a> mode=<a class="el" href="structphysx_1_1_px_force_mode.html#a9ff6cda92b5c14771fa3f2eec39581b2aaaf8d6181e13db4d737a48e042112505">PxForceMode::eFORCE</a>)=0</td></tr>
<tr class="memdesc:a8d643ffccf6fefb0b39c609c2e474f75 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the impulsive force and torque defined in the global coordinate frame to the actor.  <br /></td></tr>
<tr class="separator:a8d643ffccf6fefb0b39c609c2e474f75 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85350efb9b525a6cf0de079d959d8c4 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ab85350efb9b525a6cf0de079d959d8c4">setRigidBodyFlag</a> (<a class="el" href="structphysx_1_1_px_rigid_body_flag.html#ae3a4da7ce0535fdd127728674e060869">PxRigidBodyFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:ab85350efb9b525a6cf0de079d959d8c4 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular rigid body flag.  <br /></td></tr>
<tr class="separator:ab85350efb9b525a6cf0de079d959d8c4 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdfb6b1a61d6fa8010af0dc854c7d68 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top"><a id="aabdfb6b1a61d6fa8010af0dc854c7d68" name="aabdfb6b1a61d6fa8010af0dc854c7d68"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setRigidBodyFlags</b> (<a class="el" href="namespacephysx.html#a97e228a8044f5674ef80a0195012f401">PxRigidBodyFlags</a> inFlags)=0</td></tr>
<tr class="separator:aabdfb6b1a61d6fa8010af0dc854c7d68 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864acc2c28d314bb3074f7997cb1d910 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a97e228a8044f5674ef80a0195012f401">PxRigidBodyFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a864acc2c28d314bb3074f7997cb1d910">getRigidBodyFlags</a> () const =0</td></tr>
<tr class="memdesc:a864acc2c28d314bb3074f7997cb1d910 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classphysx_1_1_px_rigid_body.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> flags.  <br /></td></tr>
<tr class="separator:a864acc2c28d314bb3074f7997cb1d910 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef05905d355a51c91f71c99f0ab3a990 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#aef05905d355a51c91f71c99f0ab3a990">setMinCCDAdvanceCoefficient</a> (PxReal advanceCoefficient)=0</td></tr>
<tr class="memdesc:aef05905d355a51c91f71c99f0ab3a990 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CCD minimum advance coefficient.  <br /></td></tr>
<tr class="separator:aef05905d355a51c91f71c99f0ab3a990 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cc5fcce42853bb3f718c2c78782eb6 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#ab5cc5fcce42853bb3f718c2c78782eb6">getMinCCDAdvanceCoefficient</a> () const =0</td></tr>
<tr class="memdesc:ab5cc5fcce42853bb3f718c2c78782eb6 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the CCD minimum advance coefficient.  <br /></td></tr>
<tr class="separator:ab5cc5fcce42853bb3f718c2c78782eb6 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f892df807dac059cabe4ac699aa8104 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a4f892df807dac059cabe4ac699aa8104">setMaxDepenetrationVelocity</a> (PxReal biasClamp)=0</td></tr>
<tr class="memdesc:a4f892df807dac059cabe4ac699aa8104 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum depenetration velocity permitted to be introduced by the solver. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  <br /></td></tr>
<tr class="separator:a4f892df807dac059cabe4ac699aa8104 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8a85ec0bf904443aaa1897f72bd0d5 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a8b8a85ec0bf904443aaa1897f72bd0d5">getMaxDepenetrationVelocity</a> () const =0</td></tr>
<tr class="memdesc:a8b8a85ec0bf904443aaa1897f72bd0d5 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum depenetration velocity the solver is permitted to introduced. This value controls how much velocity the solver can introduce to correct for penetrations in contacts.  <br /></td></tr>
<tr class="separator:a8b8a85ec0bf904443aaa1897f72bd0d5 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0616e1ce7f675243220ce94f8eb23e inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a5a0616e1ce7f675243220ce94f8eb23e">setMaxContactImpulse</a> (PxReal maxImpulse)=0</td></tr>
<tr class="memdesc:a5a0616e1ce7f675243220ce94f8eb23e inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a limit on the impulse that may be applied at a contact. The maximum impulse at a contact between two dynamic or kinematic bodies will be the minimum of the two limit values. For a collision between a static and a dynamic body, the impulse is limited by the value for the dynamic body.  <br /></td></tr>
<tr class="separator:a5a0616e1ce7f675243220ce94f8eb23e inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3efe30e7ceaae6694bb80fd0567820 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#afc3efe30e7ceaae6694bb80fd0567820">getMaxContactImpulse</a> () const =0</td></tr>
<tr class="memdesc:afc3efe30e7ceaae6694bb80fd0567820 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum impulse that may be applied at a contact.  <br /></td></tr>
<tr class="separator:afc3efe30e7ceaae6694bb80fd0567820 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29704224fe61cc77002d290b1bbe0bb8 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a29704224fe61cc77002d290b1bbe0bb8">setContactSlopCoefficient</a> (PxReal slopCoefficient)=0</td></tr>
<tr class="memdesc:a29704224fe61cc77002d290b1bbe0bb8 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a distance scale whereby the angular influence of a contact on the normal constraint in a contact is zeroed if normal.cross(offset) falls below this tolerance. Rather than acting as an absolute value, this tolerance is scaled by the ratio rXn.dot(angVel)/normal.dot(linVel) such that contacts that have relatively larger angular velocity than linear normal velocity (e.g. rolling wheels) achieve larger slop values as the angular velocity increases.  <br /></td></tr>
<tr class="separator:a29704224fe61cc77002d290b1bbe0bb8 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60939f0d306255f906f9c9626a69a3e5 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a60939f0d306255f906f9c9626a69a3e5">getContactSlopCoefficient</a> () const =0</td></tr>
<tr class="memdesc:a60939f0d306255f906f9c9626a69a3e5 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contact slop coefficient.  <br /></td></tr>
<tr class="separator:a60939f0d306255f906f9c9626a69a3e5 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b68a2d6ca702401da6ddbe165fae35 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_node_index.html">PxNodeIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_body.html#a82b68a2d6ca702401da6ddbe165fae35">getInternalIslandNodeIndex</a> () const =0</td></tr>
<tr class="memdesc:a82b68a2d6ca702401da6ddbe165fae35 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the island node index.  <br /></td></tr>
<tr class="separator:a82b68a2d6ca702401da6ddbe165fae35 inherit pub_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_rigid_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_rigid_actor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_rigid_actor.html">physx::PxRigidActor</a></td></tr>
<tr class="memitem:aa586d6c2d8eef65c4b986066297809f7 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#aa586d6c2d8eef65c4b986066297809f7">release</a> ()=0</td></tr>
<tr class="memdesc:aa586d6c2d8eef65c4b986066297809f7 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the rigid actor object.  <br /></td></tr>
<tr class="separator:aa586d6c2d8eef65c4b986066297809f7 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f5c46f4b03d7d6c5293cc90b9a7660 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a06f5c46f4b03d7d6c5293cc90b9a7660">getInternalActorIndex</a> () const =0</td></tr>
<tr class="memdesc:a06f5c46f4b03d7d6c5293cc90b9a7660 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal actor index.  <br /></td></tr>
<tr class="separator:a06f5c46f4b03d7d6c5293cc90b9a7660 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb7aba78c0dee595675bf6f4c09cc7c inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#acdb7aba78c0dee595675bf6f4c09cc7c">getGlobalPose</a> () const =0</td></tr>
<tr class="memdesc:acdb7aba78c0dee595675bf6f4c09cc7c inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the actors world space transform.  <br /></td></tr>
<tr class="separator:acdb7aba78c0dee595675bf6f4c09cc7c inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471dcde00089e53114f87d884c7a0163 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a471dcde00089e53114f87d884c7a0163">setGlobalPose</a> (const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;pose, bool autowake=true)=0</td></tr>
<tr class="memdesc:a471dcde00089e53114f87d884c7a0163 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for setting an actor's pose in the world.  <br /></td></tr>
<tr class="separator:a471dcde00089e53114f87d884c7a0163 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464e93731d0f59ea0e308a1cb5881646 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a464e93731d0f59ea0e308a1cb5881646">attachShape</a> (<a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> &amp;shape)=0</td></tr>
<tr class="memdesc:a464e93731d0f59ea0e308a1cb5881646 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a shape to an actor.  <br /></td></tr>
<tr class="separator:a464e93731d0f59ea0e308a1cb5881646 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191dad155177ded4d47396d4fea598e2 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a191dad155177ded4d47396d4fea598e2">detachShape</a> (<a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> &amp;shape, bool wakeOnLostTouch=true)=0</td></tr>
<tr class="memdesc:a191dad155177ded4d47396d4fea598e2 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a shape from an actor.  <br /></td></tr>
<tr class="separator:a191dad155177ded4d47396d4fea598e2 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d0db68c9d9ec4d0f369ab2f8029a25 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a72d0db68c9d9ec4d0f369ab2f8029a25">getNbShapes</a> () const =0</td></tr>
<tr class="memdesc:a72d0db68c9d9ec4d0f369ab2f8029a25 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of shapes assigned to the actor.  <br /></td></tr>
<tr class="separator:a72d0db68c9d9ec4d0f369ab2f8029a25 inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aa5f84f999da2e8c410b8d0fbe8f5a inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#a50aa5f84f999da2e8c410b8d0fbe8f5a">getShapes</a> (<a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0</td></tr>
<tr class="memdesc:a50aa5f84f999da2e8c410b8d0fbe8f5a inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the shape pointers belonging to the actor.  <br /></td></tr>
<tr class="separator:a50aa5f84f999da2e8c410b8d0fbe8f5a inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06c08d1d6ae4b0c9e69714c5698b27d inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#aa06c08d1d6ae4b0c9e69714c5698b27d">getNbConstraints</a> () const =0</td></tr>
<tr class="memdesc:aa06c08d1d6ae4b0c9e69714c5698b27d inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraint shaders attached to the actor.  <br /></td></tr>
<tr class="separator:aa06c08d1d6ae4b0c9e69714c5698b27d inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84b5553f7f32e5f0a4543b6968f432f inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_actor.html#ac84b5553f7f32e5f0a4543b6968f432f">getConstraints</a> (<a class="el" href="classphysx_1_1_px_constraint.html">PxConstraint</a> **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const =0</td></tr>
<tr class="memdesc:ac84b5553f7f32e5f0a4543b6968f432f inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all the constraint shader pointers belonging to the actor.  <br /></td></tr>
<tr class="separator:ac84b5553f7f32e5f0a4543b6968f432f inherit pub_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_actor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_actor.html">physx::PxActor</a></td></tr>
<tr class="memitem:a782e6bd48fb10f393581302d428eee19 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a782e6bd48fb10f393581302d428eee19">release</a> ()=0</td></tr>
<tr class="memdesc:a782e6bd48fb10f393581302d428eee19 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the actor.  <br /></td></tr>
<tr class="separator:a782e6bd48fb10f393581302d428eee19 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff803bacb565652fb46ab69cda1d2526 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_actor_type.html#aa12d1dbb97bda016f592de47e67e3963">PxActorType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aff803bacb565652fb46ab69cda1d2526">getType</a> () const =0</td></tr>
<tr class="memdesc:aff803bacb565652fb46ab69cda1d2526 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the type of actor.  <br /></td></tr>
<tr class="separator:aff803bacb565652fb46ab69cda1d2526 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002cfb766d7d8aa71f174980fe7b1c6b inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_scene.html">PxScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a002cfb766d7d8aa71f174980fe7b1c6b">getScene</a> () const =0</td></tr>
<tr class="memdesc:a002cfb766d7d8aa71f174980fe7b1c6b inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the scene which this actor belongs to.  <br /></td></tr>
<tr class="separator:a002cfb766d7d8aa71f174980fe7b1c6b inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab374c355cdd9c9b5a93479a8c751704a inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#ab374c355cdd9c9b5a93479a8c751704a">setName</a> (const char *name)=0</td></tr>
<tr class="memdesc:ab374c355cdd9c9b5a93479a8c751704a inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classphysx_1_1_px_actor.html#aad553a24aa6546e93bfb887d0c27fba9" title="Retrieves the name string set with setName().">getName()</a>.  <br /></td></tr>
<tr class="separator:ab374c355cdd9c9b5a93479a8c751704a inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad553a24aa6546e93bfb887d0c27fba9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aad553a24aa6546e93bfb887d0c27fba9">getName</a> () const =0</td></tr>
<tr class="memdesc:aad553a24aa6546e93bfb887d0c27fba9 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the name string set with <a class="el" href="classphysx_1_1_px_actor.html#ab374c355cdd9c9b5a93479a8c751704a" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>.  <br /></td></tr>
<tr class="separator:aad553a24aa6546e93bfb887d0c27fba9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4121e4d3f38d9303b840159ac18bc5d inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#ab4121e4d3f38d9303b840159ac18bc5d">getWorldBounds</a> (float inflation=1.01f) const =0</td></tr>
<tr class="memdesc:ab4121e4d3f38d9303b840159ac18bc5d inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the actor.  <br /></td></tr>
<tr class="separator:ab4121e4d3f38d9303b840159ac18bc5d inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6587b0a441c214a3f4504099105e298f inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a6587b0a441c214a3f4504099105e298f">setActorFlag</a> (<a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8">PxActorFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:a6587b0a441c214a3f4504099105e298f inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular actor flag.  <br /></td></tr>
<tr class="separator:a6587b0a441c214a3f4504099105e298f inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47d905605f403aa95aee541a772b696 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aa47d905605f403aa95aee541a772b696">setActorFlags</a> (<a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a> inFlags)=0</td></tr>
<tr class="memdesc:aa47d905605f403aa95aee541a772b696 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the actor flags.  <br /></td></tr>
<tr class="separator:aa47d905605f403aa95aee541a772b696 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3aebddb7b31092182606c61398983a inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a5d3aebddb7b31092182606c61398983a">getActorFlags</a> () const =0</td></tr>
<tr class="memdesc:a5d3aebddb7b31092182606c61398983a inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> flags.  <br /></td></tr>
<tr class="separator:a5d3aebddb7b31092182606c61398983a inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3786b0f53c9a37074372d0ea62ce348d inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a3786b0f53c9a37074372d0ea62ce348d">setDominanceGroup</a> (<a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a> dominanceGroup)=0</td></tr>
<tr class="memdesc:a3786b0f53c9a37074372d0ea62ce348d inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns dynamic actors a dominance group identifier.  <br /></td></tr>
<tr class="separator:a3786b0f53c9a37074372d0ea62ce348d inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7effc9b077780ffd713baa8869feae inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a4b7effc9b077780ffd713baa8869feae">getDominanceGroup</a> () const =0</td></tr>
<tr class="memdesc:a4b7effc9b077780ffd713baa8869feae inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value set with <a class="el" href="classphysx_1_1_px_actor.html#a3786b0f53c9a37074372d0ea62ce348d" title="Assigns dynamic actors a dominance group identifier.">setDominanceGroup()</a>.  <br /></td></tr>
<tr class="separator:a4b7effc9b077780ffd713baa8869feae inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160170378b1a28ef6f82f9c603b3cdf9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a160170378b1a28ef6f82f9c603b3cdf9">setOwnerClient</a> (<a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a> inClient)=0</td></tr>
<tr class="memdesc:a160170378b1a28ef6f82f9c603b3cdf9 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the owner client of an actor.  <br /></td></tr>
<tr class="separator:a160170378b1a28ef6f82f9c603b3cdf9 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fe5ab2d87b2cded54153370492875 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a0f3fe5ab2d87b2cded54153370492875">getOwnerClient</a> () const =0</td></tr>
<tr class="memdesc:a0f3fe5ab2d87b2cded54153370492875 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the owner client that was specified at creation time.  <br /></td></tr>
<tr class="separator:a0f3fe5ab2d87b2cded54153370492875 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2001117af8250e4afc077e160307aa13 inherit pub_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a2001117af8250e4afc077e160307aa13">getAggregate</a> () const =0</td></tr>
<tr class="memdesc:a2001117af8250e4afc077e160307aa13 inherit pub_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the aggregate the actor might be a part of.  <br /></td></tr>
<tr class="separator:a2001117af8250e4afc077e160307aa13 inherit pub_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a09013f88c156cfcdfcb001611360e92c">release</a> ()=0</td></tr>
<tr class="memdesc:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the <a class="el" href="classphysx_1_1_px_base.html" title="Base class for objects that can be members of a PxCollection.">PxBase</a> instance, please check documentation of release in derived class.  <br /></td></tr>
<tr class="separator:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aea4c4ef95da2697f36d3a9fc9a2f897a">getConcreteTypeName</a> () const =0</td></tr>
<tr class="memdesc:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string name of dynamic type.  <br /></td></tr>
<tr class="separator:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="a76be84f268e30c6fcb62a413963908db" name="a76be84f268e30c6fcb62a413963908db"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is</b> ()</td></tr>
<tr class="separator:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="a114ba2d2c3e2e50368c7003660b7e78d" name="a114ba2d2c3e2e50368c7003660b7e78d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is</b> () const</td></tr>
<tr class="separator:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> PxType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aeb75b831810e817d266223ccb244f3e4">getConcreteType</a> () const</td></tr>
<tr class="memdesc:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns concrete type of object.  <br /></td></tr>
<tr class="separator:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aa1f16f63ebbcad8aff05560d28709ff0">setBaseFlag</a> (PxBaseFlag::Enum flag, bool value)</td></tr>
<tr class="memdesc:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="structphysx_1_1_px_base_flag.html" title="Flags for PxBase.">PxBaseFlag</a> <br  />
  <br /></td></tr>
<tr class="separator:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a87724fce99cffbdd787a13391e58c04e">setBaseFlags</a> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> inFlags)</td></tr>
<tr class="memdesc:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PxBaseFlags <br  />
  <br /></td></tr>
<tr class="separator:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a1f7953973ba7e246effc9d4f6e6f34ab">getBaseFlags</a> () const</td></tr>
<tr class="memdesc:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns PxBaseFlags.  <br /></td></tr>
<tr class="separator:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a43f6a532bcc3da9e6fc8977094f419d9">isReleasable</a> () const</td></tr>
<tr class="memdesc:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the object is subordinate.  <br /></td></tr>
<tr class="separator:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Sleeping</h2></td></tr>
<tr class="memitem:a9d6619ab960c7a390fecae5b6b6cd3b4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a9d6619ab960c7a390fecae5b6b6cd3b4">isSleeping</a> () const =0</td></tr>
<tr class="memdesc:a9d6619ab960c7a390fecae5b6b6cd3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this body is sleeping.  <br /></td></tr>
<tr class="separator:a9d6619ab960c7a390fecae5b6b6cd3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8303c00229cbc0f81d558a4a5f2f836"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#af8303c00229cbc0f81d558a4a5f2f836">setSleepThreshold</a> (PxReal threshold)=0</td></tr>
<tr class="memdesc:af8303c00229cbc0f81d558a4a5f2f836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.  <br /></td></tr>
<tr class="separator:af8303c00229cbc0f81d558a4a5f2f836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71505fab4985422823515215b702617f"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a71505fab4985422823515215b702617f">getSleepThreshold</a> () const =0</td></tr>
<tr class="memdesc:a71505fab4985422823515215b702617f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mass-normalized kinetic energy below which an actor may go to sleep.  <br /></td></tr>
<tr class="separator:a71505fab4985422823515215b702617f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cfe393f9cafa76bdd19f8a42b90ab2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#ac8cfe393f9cafa76bdd19f8a42b90ab2">setStabilizationThreshold</a> (PxReal threshold)=0</td></tr>
<tr class="memdesc:ac8cfe393f9cafa76bdd19f8a42b90ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilization.  <br /></td></tr>
<tr class="separator:ac8cfe393f9cafa76bdd19f8a42b90ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf6c8ec928098508fc563d81ce6197e"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a1cf6c8ec928098508fc563d81ce6197e">getStabilizationThreshold</a> () const =0</td></tr>
<tr class="memdesc:a1cf6c8ec928098508fc563d81ce6197e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mass-normalized kinetic energy below which an actor may participate in stabilization.  <br /></td></tr>
<tr class="separator:a1cf6c8ec928098508fc563d81ce6197e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f6a31e33533d5139d52965186dfa4d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_flags.html">PxRigidDynamicLockFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#ac6f6a31e33533d5139d52965186dfa4d">getRigidDynamicLockFlags</a> () const =0</td></tr>
<tr class="memdesc:ac6f6a31e33533d5139d52965186dfa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> lock flags.  <br /></td></tr>
<tr class="separator:ac6f6a31e33533d5139d52965186dfa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5183da770209976883f8c9ffd325f9b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a5183da770209976883f8c9ffd325f9b3">setRigidDynamicLockFlag</a> (PxRigidDynamicLockFlag::Enum flag, bool value)=0</td></tr>
<tr class="memdesc:a5183da770209976883f8c9ffd325f9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular rigid dynamic lock flag.  <br /></td></tr>
<tr class="separator:a5183da770209976883f8c9ffd325f9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a8253eb408465422d485cfbc8dae38"><td class="memItemLeft" align="right" valign="top"><a id="a73a8253eb408465422d485cfbc8dae38" name="a73a8253eb408465422d485cfbc8dae38"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setRigidDynamicLockFlags</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxRigidDynamicLockFlags</a> flags)=0</td></tr>
<tr class="separator:a73a8253eb408465422d485cfbc8dae38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e22669a3296cc6c2a2161606d7c887"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a85e22669a3296cc6c2a2161606d7c887">getLinearVelocity</a> () const =0</td></tr>
<tr class="memdesc:a85e22669a3296cc6c2a2161606d7c887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the linear velocity of an actor.  <br /></td></tr>
<tr class="separator:a85e22669a3296cc6c2a2161606d7c887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed77febd573d1f3969f1d18b6c6822a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6ed77febd573d1f3969f1d18b6c6822a">setLinearVelocity</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;linVel, bool autowake=true)=0</td></tr>
<tr class="memdesc:a6ed77febd573d1f3969f1d18b6c6822a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the linear velocity of the actor.  <br /></td></tr>
<tr class="separator:a6ed77febd573d1f3969f1d18b6c6822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcf6611fa954275cdbcd290691ca76c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6fcf6611fa954275cdbcd290691ca76c">getAngularVelocity</a> () const =0</td></tr>
<tr class="memdesc:a6fcf6611fa954275cdbcd290691ca76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the angular velocity of the actor.  <br /></td></tr>
<tr class="separator:a6fcf6611fa954275cdbcd290691ca76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad3c1668c33b479282d7098804bc6ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6ad3c1668c33b479282d7098804bc6ec">setAngularVelocity</a> (const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;angVel, bool autowake=true)=0</td></tr>
<tr class="memdesc:a6ad3c1668c33b479282d7098804bc6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the angular velocity of the actor.  <br /></td></tr>
<tr class="separator:a6ad3c1668c33b479282d7098804bc6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5fb999688228627a19a8ff1a9ad8f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a2d5fb999688228627a19a8ff1a9ad8f2">setWakeCounter</a> (PxReal wakeCounterValue)=0</td></tr>
<tr class="memdesc:a2d5fb999688228627a19a8ff1a9ad8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wake counter for the actor.  <br /></td></tr>
<tr class="separator:a2d5fb999688228627a19a8ff1a9ad8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af427a629fc881eb5d3e06368f1c455b9"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#af427a629fc881eb5d3e06368f1c455b9">getWakeCounter</a> () const =0</td></tr>
<tr class="memdesc:af427a629fc881eb5d3e06368f1c455b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wake counter of the actor.  <br /></td></tr>
<tr class="separator:af427a629fc881eb5d3e06368f1c455b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4b4d29d351c53788f0b71a5435a037"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a4e4b4d29d351c53788f0b71a5435a037">wakeUp</a> ()=0</td></tr>
<tr class="memdesc:a4e4b4d29d351c53788f0b71a5435a037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up the actor if it is sleeping.  <br /></td></tr>
<tr class="separator:a4e4b4d29d351c53788f0b71a5435a037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d98d53cde945bb1f1ed5e204bc925aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6d98d53cde945bb1f1ed5e204bc925aa">putToSleep</a> ()=0</td></tr>
<tr class="memdesc:a6d98d53cde945bb1f1ed5e204bc925aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the actor to sleep.  <br /></td></tr>
<tr class="separator:a6d98d53cde945bb1f1ed5e204bc925aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f95eb2bc3cc9b3bbc6200ee290affb0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a7f95eb2bc3cc9b3bbc6200ee290affb0">setSolverIterationCounts</a> (PxU32 minPositionIters, PxU32 minVelocityIters=1)=0</td></tr>
<tr class="memdesc:a7f95eb2bc3cc9b3bbc6200ee290affb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the solver iteration counts for the body.  <br /></td></tr>
<tr class="separator:a7f95eb2bc3cc9b3bbc6200ee290affb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34385068b0d0ef6dbb2ee55d696cb45"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#ab34385068b0d0ef6dbb2ee55d696cb45">getSolverIterationCounts</a> (PxU32 &amp;minPositionIters, PxU32 &amp;minVelocityIters) const =0</td></tr>
<tr class="memdesc:ab34385068b0d0ef6dbb2ee55d696cb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the solver iteration counts.  <br /></td></tr>
<tr class="separator:ab34385068b0d0ef6dbb2ee55d696cb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f3b11e28c129aaf9adc87acfad4486"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#af2f3b11e28c129aaf9adc87acfad4486">getContactReportThreshold</a> () const =0</td></tr>
<tr class="memdesc:af2f3b11e28c129aaf9adc87acfad4486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the force threshold for contact reports.  <br /></td></tr>
<tr class="separator:af2f3b11e28c129aaf9adc87acfad4486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0a6d0129045078874bde3412724a30"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a1a0a6d0129045078874bde3412724a30">setContactReportThreshold</a> (PxReal threshold)=0</td></tr>
<tr class="memdesc:a1a0a6d0129045078874bde3412724a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the force threshold for contact reports.  <br /></td></tr>
<tr class="separator:a1a0a6d0129045078874bde3412724a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619d1bac2bc10731bb191e554bff52ab"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a619d1bac2bc10731bb191e554bff52ab">getConcreteTypeName</a> () const</td></tr>
<tr class="memdesc:a619d1bac2bc10731bb191e554bff52ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string name of dynamic type.  <br /></td></tr>
<tr class="separator:a619d1bac2bc10731bb191e554bff52ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0da710100975959c7e2701c7d7922d"><td class="memItemLeft" align="right" valign="top"><a id="a9a0da710100975959c7e2701c7d7922d" name="a9a0da710100975959c7e2701c7d7922d"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxRigidDynamic</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a9a0da710100975959c7e2701c7d7922d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bbd892b75690ae2a2683b086dbe395"><td class="memItemLeft" align="right" valign="top"><a id="ab1bbd892b75690ae2a2683b086dbe395" name="ab1bbd892b75690ae2a2683b086dbe395"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxRigidDynamic</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:ab1bbd892b75690ae2a2683b086dbe395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5193ba15d2640226bb9747a8b998bc35"><td class="memItemLeft" align="right" valign="top"><a id="a5193ba15d2640226bb9747a8b998bc35" name="a5193ba15d2640226bb9747a8b998bc35"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PxRigidDynamic</b> ()</td></tr>
<tr class="separator:a5193ba15d2640226bb9747a8b998bc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e7bb6ab20e7d635c9263fba2f283ed"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a24e7bb6ab20e7d635c9263fba2f283ed">isKindOf</a> (const char *name) const</td></tr>
<tr class="memdesc:a24e7bb6ab20e7d635c9263fba2f283ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:a24e7bb6ab20e7d635c9263fba2f283ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classphysx_1_1_px_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classphysx_1_1_px_actor')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classphysx_1_1_px_actor.html">physx::PxActor</a></td></tr>
<tr class="memitem:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="a85d97eb04de762d740345cc469824b6f" name="a85d97eb04de762d740345cc469824b6f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>userData</b></td></tr>
<tr class="memdesc:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object. <br /></td></tr>
<tr class="separator:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_rigid_body"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_rigid_body')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_rigid_body.html">physx::PxRigidBody</a></td></tr>
<tr class="memitem:a00f73ea4c22236077d0ea55fe5ca2048 inherit pro_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top"><a id="a00f73ea4c22236077d0ea55fe5ca2048" name="a00f73ea4c22236077d0ea55fe5ca2048"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxRigidBody</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a00f73ea4c22236077d0ea55fe5ca2048 inherit pro_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c68990ce024b92c5ad18e88c83ff497 inherit pro_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top"><a id="a3c68990ce024b92c5ad18e88c83ff497" name="a3c68990ce024b92c5ad18e88c83ff497"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxRigidBody</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a3c68990ce024b92c5ad18e88c83ff497 inherit pro_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada115a8b6441798bfd89a9ded9dedef9 inherit pro_methods_classphysx_1_1_px_rigid_body"><td class="memItemLeft" align="right" valign="top"><a id="ada115a8b6441798bfd89a9ded9dedef9" name="ada115a8b6441798bfd89a9ded9dedef9"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PxRigidBody</b> ()</td></tr>
<tr class="separator:ada115a8b6441798bfd89a9ded9dedef9 inherit pro_methods_classphysx_1_1_px_rigid_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_rigid_actor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_rigid_actor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_rigid_actor.html">physx::PxRigidActor</a></td></tr>
<tr class="memitem:a19d601aff4c99aae855bac2d84c2ea4b inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top"><a id="a19d601aff4c99aae855bac2d84c2ea4b" name="a19d601aff4c99aae855bac2d84c2ea4b"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxRigidActor</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a19d601aff4c99aae855bac2d84c2ea4b inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e66d5f55151b1e81bd391f0e044eed inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top"><a id="ae1e66d5f55151b1e81bd391f0e044eed" name="ae1e66d5f55151b1e81bd391f0e044eed"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxRigidActor</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:ae1e66d5f55151b1e81bd391f0e044eed inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44f9c3cd9442253412732cd0e4a4e3a inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memItemLeft" align="right" valign="top"><a id="ae44f9c3cd9442253412732cd0e4a4e3a" name="ae44f9c3cd9442253412732cd0e4a4e3a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PxRigidActor</b> ()</td></tr>
<tr class="separator:ae44f9c3cd9442253412732cd0e4a4e3a inherit pro_methods_classphysx_1_1_px_rigid_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_actor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_actor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_actor.html">physx::PxActor</a></td></tr>
<tr class="memitem:a38b030b8d43f75ca6a0011d369369fdf inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="a38b030b8d43f75ca6a0011d369369fdf" name="a38b030b8d43f75ca6a0011d369369fdf"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxActor</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a38b030b8d43f75ca6a0011d369369fdf inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d98db236080d8bdb8f7dd179d84bde inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="ad8d98db236080d8bdb8f7dd179d84bde" name="ad8d98db236080d8bdb8f7dd179d84bde"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxActor</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:ad8d98db236080d8bdb8f7dd179d84bde inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a538ec41302af60afec0df10f31f4ab24">isKindOf</a> (const char *name) const</td></tr>
<tr class="memdesc:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a92f28ef9d2c863db69d316e68375fac5" name="a92f28ef9d2c863db69d316e68375fac5"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxBase</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor setting concrete type and base flags. <br /></td></tr>
<tr class="separator:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a4f41a74f151437e79ea1fb075df19cbc" name="a4f41a74f151437e79ea1fb075df19cbc"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxBase</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialization constructor setting base flags. <br /></td></tr>
<tr class="separator:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="adcee0bb92feaaaaeb2340d7304af1830" name="adcee0bb92feaaaaeb2340d7304af1830"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PxBase</b> ()</td></tr>
<tr class="memdesc:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a8645a6d66bcc1df05a82bf3be518cb55">isKindOf</a> (const char *superClass) const</td></tr>
<tr class="memdesc:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="abcfbbbce797c885d67969f6c5b975601" name="abcfbbbce797c885d67969f6c5b975601"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeMatch</b> () const</td></tr>
<tr class="separator:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:ad6a3f9870b95cebff97107058729852a inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="ad6a3f9870b95cebff97107058729852a" name="ad6a3f9870b95cebff97107058729852a"></a>
PxType&#160;</td><td class="memItemRight" valign="bottom"><b>mConcreteType</b></td></tr>
<tr class="separator:ad6a3f9870b95cebff97107058729852a inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24687e4fc96f1902f53cd4e0444c4482 inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a24687e4fc96f1902f53cd4e0444c4482" name="a24687e4fc96f1902f53cd4e0444c4482"></a>
<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mBaseFlags</b></td></tr>
<tr class="separator:a24687e4fc96f1902f53cd4e0444c4482 inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e247c6b6559031c784449e79396af0 inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a67e247c6b6559031c784449e79396af0" name="a67e247c6b6559031c784449e79396af0"></a>
PxU32&#160;</td><td class="memItemRight" valign="bottom"><b>mBuiltInRefCount</b></td></tr>
<tr class="separator:a67e247c6b6559031c784449e79396af0 inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> represents a dynamic rigid simulation object in the physics SDK. </p>
<h3>Creation</h3>
<p>Instances of this class are created by calling <a class="el" href="classphysx_1_1_px_physics.html#afeb392c0bf73e2ad6778d0300ba85c9d" title="Creates a dynamic rigid actor with the specified pose and all other fields initialized to their defau...">PxPhysics::createRigidDynamic()</a> and deleted with <a class="el" href="classphysx_1_1_px_rigid_actor.html#aa586d6c2d8eef65c4b986066297809f7" title="Deletes the rigid actor object.">release()</a>.</p>
<h3>Visualizations</h3>
<ul>
<li><a class="el" href="structphysx_1_1_px_visualization_parameter.html#aa447b94a67f50a6573d90f68812ad47ea687c6933b0f6cb87572a5e591fc5acc1" title="Visualize actor axes.">PxVisualizationParameter::eACTOR_AXES</a> </li>
<li><a class="el" href="structphysx_1_1_px_visualization_parameter.html#aa447b94a67f50a6573d90f68812ad47eafad967506b25ce9441b4c37fb8c582d9" title="Visualize a bodies axes.">PxVisualizationParameter::eBODY_AXES</a> </li>
<li><a class="el" href="structphysx_1_1_px_visualization_parameter.html#aa447b94a67f50a6573d90f68812ad47eab563b1d22cdcb3e6b244921ef6d63184" title="Visualize a body&#39;s mass axes.">PxVisualizationParameter::eBODY_MASS_AXES</a> </li>
<li><a class="el" href="structphysx_1_1_px_visualization_parameter.html#aa447b94a67f50a6573d90f68812ad47eacffe33089a88d220dd537ae28a69fddf" title="Visualize the bodies linear velocity.">PxVisualizationParameter::eBODY_LIN_VELOCITY</a> </li>
<li><a class="el" href="structphysx_1_1_px_visualization_parameter.html#aa447b94a67f50a6573d90f68812ad47ea48d199f2c53a1226176ebdc31212e57c" title="Visualize the bodies angular velocity.">PxVisualizationParameter::eBODY_ANG_VELOCITY</a></li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_body.html" title="PxRigidBody is a base class shared between dynamic rigid body objects.">PxRigidBody</a> <a class="el" href="classphysx_1_1_px_physics.html#afeb392c0bf73e2ad6778d0300ba85c9d" title="Creates a dynamic rigid actor with the specified pose and all other fields initialized to their defau...">PxPhysics.createRigidDynamic()</a> <a class="el" href="classphysx_1_1_px_rigid_actor.html#aa586d6c2d8eef65c4b986066297809f7" title="Deletes the rigid actor object.">release()</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6fcf6611fa954275cdbcd290691ca76c" name="a6fcf6611fa954275cdbcd290691ca76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcf6611fa954275cdbcd290691ca76c">&#9670;&#160;</a></span>getAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> physx::PxRigidDynamic::getAngularVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the angular velocity of the actor. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to use this method while the simulation is running (except during <a class="el" href="classphysx_1_1_px_scene.html#a9c63e5a0e592a434b8647c98e569aed4" title="Performs collision detection for the scene over elapsedTime.">PxScene::collide()</a>, in <a class="el" href="classphysx_1_1_px_contact_modify_callback.html" title="An interface class that the user can implement in order to modify contact constraints.">PxContactModifyCallback</a> or in contact report callbacks).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The angular velocity of the actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6ad3c1668c33b479282d7098804bc6ec" title="Sets the angular velocity of the actor.">PxRigidDynamic.setAngularVelocity()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a85e22669a3296cc6c2a2161606d7c887" title="Retrieves the linear velocity of an actor.">getLinearVelocity()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_rigid_body.html#a0718c3215843b0c333665cb2caffca8d">physx::PxRigidBody</a>.</p>

</div>
</div>
<a id="a619d1bac2bc10731bb191e554bff52ab" name="a619d1bac2bc10731bb191e554bff52ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619d1bac2bc10731bb191e554bff52ab">&#9670;&#160;</a></span>getConcreteTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * physx::PxRigidDynamic::getConcreteTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns string name of dynamic type. </p>
<dl class="section return"><dt>Returns</dt><dd>Class name of most derived type of this object. </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_base.html#aea4c4ef95da2697f36d3a9fc9a2f897a">physx::PxBase</a>.</p>

</div>
</div>
<a id="af2f3b11e28c129aaf9adc87acfad4486" name="af2f3b11e28c129aaf9adc87acfad4486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f3b11e28c129aaf9adc87acfad4486">&#9670;&#160;</a></span>getContactReportThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidDynamic::getContactReportThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the force threshold for contact reports. </p>
<p>The contact report threshold is a force threshold. If the force between two actors exceeds this threshold for either of the two actors, a contact report will be generated according to the contact report threshold flags provided by the filter shader/callback. See #PxPairFlag.</p>
<p>The threshold used for a collision between a dynamic actor and the static environment is the threshold of the dynamic actor, and all contacts with static actors are summed to find the total normal force.</p>
<p><b>Default:</b> PX_MAX_F32</p>
<dl class="section return"><dt>Returns</dt><dd>Force threshold for contact reports.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a1a0a6d0129045078874bde3412724a30" title="Sets the force threshold for contact reports.">setContactReportThreshold</a> <a class="el" href="structphysx_1_1_px_pair_flag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a> <a class="el" href="namespacephysx.html#a7d989364d9339d1946b69ec9432f36ae" title="Filter method to specify how a pair of potentially colliding objects should be processed.">PxSimulationFilterShader</a> <a class="el" href="classphysx_1_1_px_simulation_filter_callback.html" title="Filter callback to specify handling of collision pairs.">PxSimulationFilterCallback</a> </dd></dl>

</div>
</div>
<a id="ac4ad06a0a2c871c17ea8122975af9b22" name="ac4ad06a0a2c871c17ea8122975af9b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ad06a0a2c871c17ea8122975af9b22">&#9670;&#160;</a></span>getKinematicTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::PxRigidDynamic::getKinematicTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get target pose of a kinematically controlled dynamic actor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">target</td><td>Transform to write the target pose to. Only valid if the method returns true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the actor is a kinematically controlled dynamic and the target has been set, else False.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#ac63b42588e1abbc80ba22735d975f498" title="Moves kinematically controlled dynamic actors through the game world.">setKinematicTarget()</a> <a class="el" href="structphysx_1_1_px_rigid_body_flag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#ab85350efb9b525a6cf0de079d959d8c4" title="Raises or clears a particular rigid body flag.">setRigidBodyFlag()</a> </dd></dl>

</div>
</div>
<a id="a85e22669a3296cc6c2a2161606d7c887" name="a85e22669a3296cc6c2a2161606d7c887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e22669a3296cc6c2a2161606d7c887">&#9670;&#160;</a></span>getLinearVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> physx::PxRigidDynamic::getLinearVelocity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the linear velocity of an actor. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to use this method while the simulation is running (except during <a class="el" href="classphysx_1_1_px_scene.html#a9c63e5a0e592a434b8647c98e569aed4" title="Performs collision detection for the scene over elapsedTime.">PxScene::collide()</a>, in <a class="el" href="classphysx_1_1_px_contact_modify_callback.html" title="An interface class that the user can implement in order to modify contact constraints.">PxContactModifyCallback</a> or in contact report callbacks).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The linear velocity of the actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6ed77febd573d1f3969f1d18b6c6822a" title="Sets the linear velocity of the actor.">PxRigidDynamic.setLinearVelocity()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6fcf6611fa954275cdbcd290691ca76c" title="Retrieves the angular velocity of the actor.">getAngularVelocity()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_rigid_body.html#ae2739d0560b5681034deb063fe6916f3">physx::PxRigidBody</a>.</p>

</div>
</div>
<a id="ac6f6a31e33533d5139d52965186dfa4d" name="ac6f6a31e33533d5139d52965186dfa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f6a31e33533d5139d52965186dfa4d">&#9670;&#160;</a></span>getRigidDynamicLockFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_flags.html">PxRigidDynamicLockFlags</a> physx::PxRigidDynamic::getRigidDynamicLockFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the <a class="el" href="classphysx_1_1_px_rigid_dynamic.html" title="PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.">PxRigidDynamic</a> lock flags. </p>
<p>See the list of flags #PxRigidDynamicLockFlag</p>
<dl class="section return"><dt>Returns</dt><dd>The values of the PxRigidDynamicLock flags.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_rigid_dynamic_lock_flag.html" title="Collection of flags providing a mechanism to lock motion along/around a specific axis.">PxRigidDynamicLockFlag</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a5183da770209976883f8c9ffd325f9b3" title="Raises or clears a particular rigid dynamic lock flag.">setRigidDynamicLockFlag()</a> </dd></dl>

</div>
</div>
<a id="a71505fab4985422823515215b702617f" name="a71505fab4985422823515215b702617f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71505fab4985422823515215b702617f">&#9670;&#160;</a></span>getSleepThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidDynamic::getSleepThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mass-normalized kinetic energy below which an actor may go to sleep. </p>
<dl class="section return"><dt>Returns</dt><dd>The energy threshold for sleeping.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a9d6619ab960c7a390fecae5b6b6cd3b4" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a4e4b4d29d351c53788f0b71a5435a037" title="Wakes up the actor if it is sleeping.">wakeUp()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6d98d53cde945bb1f1ed5e204bc925aa" title="Forces the actor to sleep.">putToSleep()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#af8303c00229cbc0f81d558a4a5f2f836" title="Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.">setSleepThreshold()</a> </dd></dl>

</div>
</div>
<a id="ab34385068b0d0ef6dbb2ee55d696cb45" name="ab34385068b0d0ef6dbb2ee55d696cb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34385068b0d0ef6dbb2ee55d696cb45">&#9670;&#160;</a></span>getSolverIterationCounts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::getSolverIterationCounts </td>
          <td>(</td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>minVelocityIters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the solver iteration counts. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a7f95eb2bc3cc9b3bbc6200ee290affb0" title="Sets the solver iteration counts for the body.">setSolverIterationCounts()</a> </dd></dl>

</div>
</div>
<a id="a1cf6c8ec928098508fc563d81ce6197e" name="a1cf6c8ec928098508fc563d81ce6197e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf6c8ec928098508fc563d81ce6197e">&#9670;&#160;</a></span>getStabilizationThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidDynamic::getStabilizationThreshold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mass-normalized kinetic energy below which an actor may participate in stabilization. </p>
<p>Actors whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.</p>
<dl class="section return"><dt>Returns</dt><dd>The energy threshold for participating in stabilization.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#ac8cfe393f9cafa76bdd19f8a42b90ab2" title="Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilizati...">setStabilizationThreshold()</a> <a class="el" href="structphysx_1_1_px_scene_flag.html#a1a7984bb50590b1a2ce5ca5fe6469e50a9d32b1e3f43824243dd594085274ea37" title="Enables additional stabilization pass in solver.">PxSceneFlag::eENABLE_STABILIZATION</a> </dd></dl>

</div>
</div>
<a id="af427a629fc881eb5d3e06368f1c455b9" name="af427a629fc881eb5d3e06368f1c455b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af427a629fc881eb5d3e06368f1c455b9">&#9670;&#160;</a></span>getWakeCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::PxRigidDynamic::getWakeCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the wake counter of the actor. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to use this method while the simulation is running.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The wake counter of the actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a9d6619ab960c7a390fecae5b6b6cd3b4" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a2d5fb999688228627a19a8ff1a9ad8f2" title="Sets the wake counter for the actor.">setWakeCounter()</a> </dd></dl>

</div>
</div>
<a id="a24e7bb6ab20e7d635c9263fba2f283ed" name="a24e7bb6ab20e7d635c9263fba2f283ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e7bb6ab20e7d635c9263fba2f283ed">&#9670;&#160;</a></span>isKindOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::PxRigidDynamic::isKindOf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>superClass</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether a given type name matches with the type of this instance. </p>

<p>Reimplemented from <a class="el" href="classphysx_1_1_px_rigid_body.html#a231f75c8948a5b712453b18339a4bae1">physx::PxRigidBody</a>.</p>

</div>
</div>
<a id="a9d6619ab960c7a390fecae5b6b6cd3b4" name="a9d6619ab960c7a390fecae5b6b6cd3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6619ab960c7a390fecae5b6b6cd3b4">&#9670;&#160;</a></span>isSleeping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::PxRigidDynamic::isSleeping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this body is sleeping. </p>
<p>When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or one of its properties is changed by the user, the entire sleep mechanism should be transparent to the user.</p>
<p>In general, a dynamic rigid actor is guaranteed to be awake if at least one of the following holds:</p>
<ul>
<li>The wake counter is positive (see <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a2d5fb999688228627a19a8ff1a9ad8f2" title="Sets the wake counter for the actor.">setWakeCounter()</a>). </li>
<li>The linear or angular velocity is non-zero. </li>
<li>A non-zero force or torque has been applied.</li>
</ul>
<p>If a dynamic rigid actor is sleeping, the following state is guaranteed:</p>
<ul>
<li>The wake counter is zero. </li>
<li>The linear and angular velocity is zero. </li>
<li>There is no force update pending.</li>
</ul>
<p>When an actor gets inserted into a scene, it will be considered asleep if all the points above hold, else it will be treated as awake.</p>
<p>If an actor is asleep after the call to <a class="el" href="classphysx_1_1_px_scene.html#a0933fe0846ed7ee44b36accddcd16e94">PxScene::fetchResults()</a> returns, it is guaranteed that the pose of the actor was not changed. You can use this information to avoid updating the transforms of associated objects.</p>
<dl class="section note"><dt>Note</dt><dd>A kinematic actor is asleep unless a target pose has been set (in which case it will stay awake until two consecutive simulation steps without a target pose being set have passed). The wake counter will get set to zero or to the reset value <a class="el" href="classphysx_1_1_px_scene_desc.html#a9fa76944edfb3c85dbc3c9009256f595" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a> in the case where a target pose has been set to be consistent with the definitions above.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already.</dd>
<dd>
It is not allowed to use this method while the simulation is running.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the actor is sleeping.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a9d6619ab960c7a390fecae5b6b6cd3b4" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a4e4b4d29d351c53788f0b71a5435a037" title="Wakes up the actor if it is sleeping.">wakeUp()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6d98d53cde945bb1f1ed5e204bc925aa" title="Forces the actor to sleep.">putToSleep()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a71505fab4985422823515215b702617f" title="Returns the mass-normalized kinetic energy below which an actor may go to sleep.">getSleepThreshold()</a> </dd></dl>

</div>
</div>
<a id="a6d98d53cde945bb1f1ed5e204bc925aa" name="a6d98d53cde945bb1f1ed5e204bc925aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d98d53cde945bb1f1ed5e204bc925aa">&#9670;&#160;</a></span>putToSleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::putToSleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the actor to sleep. </p>
<p>The actor will stay asleep during the next simulation step if not touched by another non-sleeping actor.</p>
<dl class="section note"><dt>Note</dt><dd>Any applied force will be cleared and the velocity and the wake counter of the actor will be set to 0.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd>
<dd>
It is invalid to use this method for kinematic actors since the sleep state for kinematics is defined based on whether a target pose has been set (see the comment in <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a9d6619ab960c7a390fecae5b6b6cd3b4" title="Returns true if this body is sleeping.">isSleeping()</a>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a9d6619ab960c7a390fecae5b6b6cd3b4" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a4e4b4d29d351c53788f0b71a5435a037" title="Wakes up the actor if it is sleeping.">wakeUp()</a> </dd></dl>

</div>
</div>
<a id="a6ad3c1668c33b479282d7098804bc6ec" name="a6ad3c1668c33b479282d7098804bc6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad3c1668c33b479282d7098804bc6ec">&#9670;&#160;</a></span>setAngularVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::setAngularVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>angVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autowake</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the angular velocity of the actor. </p>
<p>Note that if you continuously set the angular velocity of an actor yourself, forces such as friction will not be able to rotate the actor, because forces directly influence only the velocity/momentum.</p>
<p><b>Default:</b> (0.0, 0.0, 0.0)</p>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the new velocity is non-zero.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angVel</td><td>New angular velocity of actor. <b>Range:</b> angular velocity vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autowake</td><td>Whether to wake the object up if it is asleep. If true and the current wake counter value is smaller than <a class="el" href="classphysx_1_1_px_scene_desc.html#a9fa76944edfb3c85dbc3c9009256f595" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6fcf6611fa954275cdbcd290691ca76c" title="Retrieves the angular velocity of the actor.">getAngularVelocity()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6ed77febd573d1f3969f1d18b6c6822a" title="Sets the linear velocity of the actor.">setLinearVelocity()</a> </dd></dl>

</div>
</div>
<a id="a1a0a6d0129045078874bde3412724a30" name="a1a0a6d0129045078874bde3412724a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0a6d0129045078874bde3412724a30">&#9670;&#160;</a></span>setContactReportThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::setContactReportThreshold </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the force threshold for contact reports. </p>
<p>See <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#af2f3b11e28c129aaf9adc87acfad4486" title="Retrieves the force threshold for contact reports.">getContactReportThreshold()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>Force threshold for contact reports. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#af2f3b11e28c129aaf9adc87acfad4486" title="Retrieves the force threshold for contact reports.">getContactReportThreshold</a> <a class="el" href="structphysx_1_1_px_pair_flag.html" title="Collection of flags describing the actions to take for a collision pair.">PxPairFlag</a> </dd></dl>

</div>
</div>
<a id="ac63b42588e1abbc80ba22735d975f498" name="ac63b42588e1abbc80ba22735d975f498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63b42588e1abbc80ba22735d975f498">&#9670;&#160;</a></span>setKinematicTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::setKinematicTarget </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_transform_t.html">PxTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves kinematically controlled dynamic actors through the game world. </p>
<p>You set a dynamic actor to be kinematic using the <a class="el" href="structphysx_1_1_px_rigid_body_flag.html#ae3a4da7ce0535fdd127728674e060869ac054cc6937fcf00bcc2d750edeecb867" title="Enables kinematic mode for the actor.">PxRigidBodyFlag::eKINEMATIC</a> flag with <a class="el" href="classphysx_1_1_px_rigid_body.html#ab85350efb9b525a6cf0de079d959d8c4" title="Raises or clears a particular rigid body flag.">setRigidBodyFlag()</a>.</p>
<p>The move command will result in a velocity that will move the body into the desired pose. After the move is carried out during a single time step, the velocity is returned to zero. Thus, you must continuously call this in every time step for kinematic actors so that they move along a path.</p>
<p>This function simply stores the move destination until the next simulation step is processed, so consecutive calls will simply overwrite the stored target variable.</p>
<p>The motion is always fully carried out.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping and will set the wake counter to <a class="el" href="classphysx_1_1_px_scene_desc.html#a9fa76944edfb3c85dbc3c9009256f595" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destination</td><td>The desired pose for the kinematic actor, in the global frame. <b>Range:</b> rigid body transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#ac4ad06a0a2c871c17ea8122975af9b22" title="Get target pose of a kinematically controlled dynamic actor.">getKinematicTarget()</a> <a class="el" href="structphysx_1_1_px_rigid_body_flag.html" title="Collection of flags describing the behavior of a rigid body.">PxRigidBodyFlag</a> <a class="el" href="classphysx_1_1_px_rigid_body.html#ab85350efb9b525a6cf0de079d959d8c4" title="Raises or clears a particular rigid body flag.">setRigidBodyFlag()</a> </dd></dl>

</div>
</div>
<a id="a6ed77febd573d1f3969f1d18b6c6822a" name="a6ed77febd573d1f3969f1d18b6c6822a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed77febd573d1f3969f1d18b6c6822a">&#9670;&#160;</a></span>setLinearVelocity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::setLinearVelocity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>linVel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autowake</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the linear velocity of the actor. </p>
<p>Note that if you continuously set the velocity of an actor yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of an actor.</p>
<p><b>Default:</b> (0.0, 0.0, 0.0)</p>
<p><b>Sleeping:</b> This call wakes the actor if it is sleeping, and the autowake parameter is true (default) or the new velocity is non-zero.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">linVel</td><td>New linear velocity of actor. <b>Range:</b> velocity vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autowake</td><td>Whether to wake the object up if it is asleep. If true and the current wake counter value is smaller than <a class="el" href="classphysx_1_1_px_scene_desc.html#a9fa76944edfb3c85dbc3c9009256f595" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a> it will get increased to the reset value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a85e22669a3296cc6c2a2161606d7c887" title="Retrieves the linear velocity of an actor.">getLinearVelocity()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6ad3c1668c33b479282d7098804bc6ec" title="Sets the angular velocity of the actor.">setAngularVelocity()</a> </dd></dl>

</div>
</div>
<a id="a5183da770209976883f8c9ffd325f9b3" name="a5183da770209976883f8c9ffd325f9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5183da770209976883f8c9ffd325f9b3">&#9670;&#160;</a></span>setRigidDynamicLockFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::setRigidDynamicLockFlag </td>
          <td>(</td>
          <td class="paramtype">PxRigidDynamicLockFlag::Enum&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raises or clears a particular rigid dynamic lock flag. </p>
<p>See the list of flags #PxRigidDynamicLockFlag</p>
<p><b>Default:</b> no flags are set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>The PxRigidDynamicLockBody flag to raise(set) or clear. See #PxRigidBodyFlag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The new boolean value for the flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_rigid_dynamic_lock_flag.html" title="Collection of flags providing a mechanism to lock motion along/around a specific axis.">PxRigidDynamicLockFlag</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#ac6f6a31e33533d5139d52965186dfa4d" title="Reads the PxRigidDynamic lock flags.">getRigidDynamicLockFlags()</a> </dd></dl>

</div>
</div>
<a id="af8303c00229cbc0f81d558a4a5f2f836" name="af8303c00229cbc0f81d558a4a5f2f836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8303c00229cbc0f81d558a4a5f2f836">&#9670;&#160;</a></span>setSleepThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::setSleepThreshold </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep. </p>
<p>Actors whose kinetic energy divided by their mass is below this threshold will be candidates for sleeping.</p>
<p><b>Default:</b> 5e-5f * <a class="el" href="classphysx_1_1_px_tolerances_scale.html#a2e7f1386c5c1e3765e64d8b130a7c9bb" title="The typical magnitude of velocities of objects in simulation. This is used to estimate whether a cont...">PxTolerancesScale::speed</a> * <a class="el" href="classphysx_1_1_px_tolerances_scale.html#a2e7f1386c5c1e3765e64d8b130a7c9bb" title="The typical magnitude of velocities of objects in simulation. This is used to estimate whether a cont...">PxTolerancesScale::speed</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>Energy below which an actor may go to sleep. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a9d6619ab960c7a390fecae5b6b6cd3b4" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a71505fab4985422823515215b702617f" title="Returns the mass-normalized kinetic energy below which an actor may go to sleep.">getSleepThreshold()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a4e4b4d29d351c53788f0b71a5435a037" title="Wakes up the actor if it is sleeping.">wakeUp()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6d98d53cde945bb1f1ed5e204bc925aa" title="Forces the actor to sleep.">putToSleep()</a> <a class="el" href="classphysx_1_1_px_tolerances_scale.html" title="Class to define the scale at which simulation runs. Most simulation tolerances are calculated in term...">PxTolerancesScale</a> </dd></dl>

</div>
</div>
<a id="a7f95eb2bc3cc9b3bbc6200ee290affb0" name="a7f95eb2bc3cc9b3bbc6200ee290affb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f95eb2bc3cc9b3bbc6200ee290affb0">&#9670;&#160;</a></span>setSolverIterationCounts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::setSolverIterationCounts </td>
          <td>(</td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>minVelocityIters</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the solver iteration counts for the body. </p>
<p>The solver iteration count determines how accurately joints and contacts are resolved. If you are having trouble with jointed bodies oscillating and behaving erratically, then setting a higher position iteration count may improve their stability.</p>
<p>If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations. More velocity iterations will drive the relative exit velocity of the intersecting objects closer to the correct value given the restitution.</p>
<p><b>Default:</b> 4 position iterations, 1 velocity iteration</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minPositionIters</td><td>Number of position iterations the solver should perform for this body. <b>Range:</b> [1,255] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minVelocityIters</td><td>Number of velocity iterations the solver should perform for this body. <b>Range:</b> [0,255]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#ab34385068b0d0ef6dbb2ee55d696cb45" title="Retrieves the solver iteration counts.">getSolverIterationCounts()</a> </dd></dl>

</div>
</div>
<a id="ac8cfe393f9cafa76bdd19f8a42b90ab2" name="ac8cfe393f9cafa76bdd19f8a42b90ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8cfe393f9cafa76bdd19f8a42b90ab2">&#9670;&#160;</a></span>setStabilizationThreshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::setStabilizationThreshold </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the mass-normalized kinetic energy threshold below which an actor may participate in stabilization. </p>
<p>Actors whose kinetic energy divided by their mass is above this threshold will not participate in stabilization.</p>
<p>This value has no effect if <a class="el" href="structphysx_1_1_px_scene_flag.html#a1a7984bb50590b1a2ce5ca5fe6469e50a9d32b1e3f43824243dd594085274ea37" title="Enables additional stabilization pass in solver.">PxSceneFlag::eENABLE_STABILIZATION</a> was not enabled on the <a class="el" href="classphysx_1_1_px_scene_desc.html" title="Descriptor class for scenes. See #PxScene.">PxSceneDesc</a>.</p>
<p><b>Default:</b> 1e-5f * <a class="el" href="classphysx_1_1_px_tolerances_scale.html#a2e7f1386c5c1e3765e64d8b130a7c9bb" title="The typical magnitude of velocities of objects in simulation. This is used to estimate whether a cont...">PxTolerancesScale::speed</a> * <a class="el" href="classphysx_1_1_px_tolerances_scale.html#a2e7f1386c5c1e3765e64d8b130a7c9bb" title="The typical magnitude of velocities of objects in simulation. This is used to estimate whether a cont...">PxTolerancesScale::speed</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>Energy below which an actor may participate in stabilization. <b>Range:</b> [0,inf)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a1cf6c8ec928098508fc563d81ce6197e" title="Returns the mass-normalized kinetic energy below which an actor may participate in stabilization.">getStabilizationThreshold()</a> <a class="el" href="structphysx_1_1_px_scene_flag.html#a1a7984bb50590b1a2ce5ca5fe6469e50a9d32b1e3f43824243dd594085274ea37" title="Enables additional stabilization pass in solver.">PxSceneFlag::eENABLE_STABILIZATION</a> </dd></dl>

</div>
</div>
<a id="a2d5fb999688228627a19a8ff1a9ad8f2" name="a2d5fb999688228627a19a8ff1a9ad8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5fb999688228627a19a8ff1a9ad8f2">&#9670;&#160;</a></span>setWakeCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::setWakeCounter </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>wakeCounterValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the wake counter for the actor. </p>
<p>The wake counter value determines the minimum amount of time until the body can be put to sleep. Please note that a body will not be put to sleep if the energy is above the specified threshold (see <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#af8303c00229cbc0f81d558a4a5f2f836" title="Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.">setSleepThreshold()</a>) or if other awake bodies are touching it.</p>
<dl class="section note"><dt>Note</dt><dd>Passing in a positive value will wake the actor up automatically.</dd>
<dd>
It is invalid to use this method for kinematic actors since the wake counter for kinematics is defined based on whether a target pose has been set (see the comment in <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a9d6619ab960c7a390fecae5b6b6cd3b4" title="Returns true if this body is sleeping.">isSleeping()</a>).</dd>
<dd>
It is invalid to use this method if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd></dl>
<p><b>Default:</b> 0.4 (which corresponds to 20 frames for a time step of 0.02)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeCounterValue</td><td>Wake counter value. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a9d6619ab960c7a390fecae5b6b6cd3b4" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#af427a629fc881eb5d3e06368f1c455b9" title="Returns the wake counter of the actor.">getWakeCounter()</a> </dd></dl>

</div>
</div>
<a id="a4e4b4d29d351c53788f0b71a5435a037" name="a4e4b4d29d351c53788f0b71a5435a037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4b4d29d351c53788f0b71a5435a037">&#9670;&#160;</a></span>wakeUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::PxRigidDynamic::wakeUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wakes up the actor if it is sleeping. </p>
<p>The actor will get woken up and might cause other touching actors to wake up as well during the next simulation step.</p>
<dl class="section note"><dt>Note</dt><dd>This will set the wake counter of the actor to the value specified in <a class="el" href="classphysx_1_1_px_scene_desc.html#a9fa76944edfb3c85dbc3c9009256f595" title="The wake counter reset value.">PxSceneDesc::wakeCounterResetValue</a>.</dd>
<dd>
It is invalid to use this method if the actor has not been added to a scene already or if <a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8a0c6c9a553d3fc8ae1ad5a09cfdc7f2b5" title="Disables simulation for the actor.">PxActorFlag::eDISABLE_SIMULATION</a> is set.</dd>
<dd>
It is invalid to use this method for kinematic actors since the sleep state for kinematics is defined based on whether a target pose has been set (see the comment in <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a9d6619ab960c7a390fecae5b6b6cd3b4" title="Returns true if this body is sleeping.">isSleeping()</a>).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a9d6619ab960c7a390fecae5b6b6cd3b4" title="Returns true if this body is sleeping.">isSleeping()</a> <a class="el" href="classphysx_1_1_px_rigid_dynamic.html#a6d98d53cde945bb1f1ed5e204bc925aa" title="Forces the actor to sleep.">putToSleep()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="_px_rigid_dynamic_8h_source.html">PxRigidDynamic.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacephysx.html">physx</a></li><li class="navelem"><a class="el" href="classphysx_1_1_px_rigid_dynamic.html">PxRigidDynamic</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
