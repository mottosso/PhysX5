<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PhysX: physx::NpSoftBody Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PhysX<span id="projectnumber">&#160;5.1.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classphysx_1_1_np_soft_body.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classphysx_1_1_np_soft_body-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">physx::NpSoftBody Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for physx::NpSoftBody:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classphysx_1_1_np_soft_body.png" usemap="#physx::NpSoftBody_map" alt=""/>
  <map id="physx::NpSoftBody_map" name="physx::NpSoftBody_map">
<area href="classphysx_1_1_np_actor_template.html" alt="physx::NpActorTemplate&lt; PxSoftBody &gt;" shape="rect" coords="123,168,360,192"/>
<area href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material..." alt="physx::PxSoftBody" shape="rect" coords="0,112,237,136"/>
<area href="classphysx_1_1_np_actor.html" alt="physx::NpActor" shape="rect" coords="247,112,484,136"/>
<area href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK." alt="physx::PxActor" shape="rect" coords="0,56,237,80"/>
<area href="classphysx_1_1_np_base.html" alt="physx::NpBase" shape="rect" coords="247,56,484,80"/>
<area href="classphysx_1_1_px_base.html" title="Base class for objects that can be members of a PxCollection." alt="physx::PxBase" shape="rect" coords="0,0,237,24"/>
<area href="classphysx_1_1_px_user_allocated.html" alt="physx::PxUserAllocated" shape="rect" coords="247,0,484,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e6209a5fb5dfb982bb3c6a71b36f5da"><td class="memItemLeft" align="right" valign="top"><a id="a8e6209a5fb5dfb982bb3c6a71b36f5da" name="a8e6209a5fb5dfb982bb3c6a71b36f5da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NpSoftBody</b> (PxCudaContextManager &amp;cudaContextManager)</td></tr>
<tr class="separator:a8e6209a5fb5dfb982bb3c6a71b36f5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa89d87ff4db04dcfc532721bcb86b75"><td class="memItemLeft" align="right" valign="top"><a id="afa89d87ff4db04dcfc532721bcb86b75" name="afa89d87ff4db04dcfc532721bcb86b75"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NpSoftBody</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags, PxCudaContextManager &amp;cudaContextManager)</td></tr>
<tr class="separator:afa89d87ff4db04dcfc532721bcb86b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004f443d5a484ec457e6feebbd83765f"><td class="memItemLeft" align="right" valign="top"><a id="a004f443d5a484ec457e6feebbd83765f" name="a004f443d5a484ec457e6feebbd83765f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>exportData</b> (<a class="el" href="classphysx_1_1_px_serialization_context.html">PxSerializationContext</a> &amp;) const</td></tr>
<tr class="separator:a004f443d5a484ec457e6feebbd83765f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94518fda442ec806a6f2cc9ce14b6100"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_actor_type.html#aa12d1dbb97bda016f592de47e67e3963">PxActorType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a94518fda442ec806a6f2cc9ce14b6100">getType</a> () const</td></tr>
<tr class="memdesc:a94518fda442ec806a6f2cc9ce14b6100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the type of actor.  <br /></td></tr>
<tr class="separator:a94518fda442ec806a6f2cc9ce14b6100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843cec147943460ff245dbaf22b5eade"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a843cec147943460ff245dbaf22b5eade">getWorldBounds</a> (float inflation=1.01f) const</td></tr>
<tr class="memdesc:a843cec147943460ff245dbaf22b5eade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the soft body.  <br /></td></tr>
<tr class="separator:a843cec147943460ff245dbaf22b5eade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa845d3794994188a5dbf3b6a8ec6d2f3"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#aa845d3794994188a5dbf3b6a8ec6d2f3">getGpuSoftBodyIndex</a> ()</td></tr>
<tr class="memdesc:aa845d3794994188a5dbf3b6a8ec6d2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GPU soft body index.  <br /></td></tr>
<tr class="separator:aa845d3794994188a5dbf3b6a8ec6d2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35f8ee26d9a063e75ee27da85ab9075"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#ab35f8ee26d9a063e75ee27da85ab9075">setSoftBodyFlag</a> (<a class="el" href="structphysx_1_1_px_soft_body_flag.html#ad392f0ca084f5a0ec7f110b8c2476315">PxSoftBodyFlag::Enum</a> flag, bool val)</td></tr>
<tr class="memdesc:ab35f8ee26d9a063e75ee27da85ab9075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single softbody flag.  <br /></td></tr>
<tr class="separator:ab35f8ee26d9a063e75ee27da85ab9075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892116fcb446822ea526c0468d9afeed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a892116fcb446822ea526c0468d9afeed">setSoftBodyFlags</a> (<a class="el" href="classphysx_1_1_px_flags.html">PxSoftBodyFlags</a> flags)</td></tr>
<tr class="memdesc:a892116fcb446822ea526c0468d9afeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the softbody flags.  <br /></td></tr>
<tr class="separator:a892116fcb446822ea526c0468d9afeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521c9a35bb5108d7bb73b7218eaf4479"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_flags.html">PxSoftBodyFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a521c9a35bb5108d7bb73b7218eaf4479">getSoftBodyFlag</a> () const</td></tr>
<tr class="memdesc:a521c9a35bb5108d7bb73b7218eaf4479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the softbody flags.  <br /></td></tr>
<tr class="separator:a521c9a35bb5108d7bb73b7218eaf4479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4750f90937bcf4c2d3d38da3405adaf5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a4750f90937bcf4c2d3d38da3405adaf5">setParameter</a> (const <a class="el" href="structphysx_1_1_px_f_e_m_parameters.html">PxFEMParameters</a> paramters)</td></tr>
<tr class="memdesc:a4750f90937bcf4c2d3d38da3405adaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parameter for FEM internal solve.  <br /></td></tr>
<tr class="separator:a4750f90937bcf4c2d3d38da3405adaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25244c54cd78fc7f657623a9616b588a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_f_e_m_parameters.html">PxFEMParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a25244c54cd78fc7f657623a9616b588a">getParameter</a> () const</td></tr>
<tr class="memdesc:a25244c54cd78fc7f657623a9616b588a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get parameter for FEM internal solve.  <br /></td></tr>
<tr class="separator:a25244c54cd78fc7f657623a9616b588a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e544250ed356146de0589947a08a82"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a71e544250ed356146de0589947a08a82">readData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> &amp;buffer, bool flush)</td></tr>
<tr class="memdesc:a71e544250ed356146de0589947a08a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a read command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:a71e544250ed356146de0589947a08a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179db5aa51cccbf4fea1a18bdc7cbf21"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a179db5aa51cccbf4fea1a18bdc7cbf21">readData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, bool flush)</td></tr>
<tr class="memdesc:a179db5aa51cccbf4fea1a18bdc7cbf21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a read command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:a179db5aa51cccbf4fea1a18bdc7cbf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f73ff72ecda078a7b7d4c0dbddd7b1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#ae1f73ff72ecda078a7b7d4c0dbddd7b1">writeData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> &amp;buffer, bool flush)</td></tr>
<tr class="memdesc:ae1f73ff72ecda078a7b7d4c0dbddd7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a write command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:ae1f73ff72ecda078a7b7d4c0dbddd7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aca1e67e9fdd3c0890a065ddd6974dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a9aca1e67e9fdd3c0890a065ddd6974dc">writeData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, bool flush)</td></tr>
<tr class="memdesc:a9aca1e67e9fdd3c0890a065ddd6974dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a write command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:a9aca1e67e9fdd3c0890a065ddd6974dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8144bfdbad7d4dce5d1c674d35fb0fc2"><td class="memItemLeft" align="right" valign="top">virtual PxCudaContextManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a8144bfdbad7d4dce5d1c674d35fb0fc2">getCudaContextManager</a> () const</td></tr>
<tr class="memdesc:a8144bfdbad7d4dce5d1c674d35fb0fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cuda context manager.  <br /></td></tr>
<tr class="separator:a8144bfdbad7d4dce5d1c674d35fb0fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9ae97f130dec4ed562db346b0beac5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a8b9ae97f130dec4ed562db346b0beac5">setWakeCounter</a> (PxReal wakeCounterValue)</td></tr>
<tr class="memdesc:a8b9ae97f130dec4ed562db346b0beac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wake counter for the soft body.  <br /></td></tr>
<tr class="separator:a8b9ae97f130dec4ed562db346b0beac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798fae12993c6a8bc7e68d9656d30ab1"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a798fae12993c6a8bc7e68d9656d30ab1">getWakeCounter</a> () const</td></tr>
<tr class="memdesc:a798fae12993c6a8bc7e68d9656d30ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wake counter of the soft body.  <br /></td></tr>
<tr class="separator:a798fae12993c6a8bc7e68d9656d30ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b8a1a0606542f15707b72b0ae215f0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a50b8a1a0606542f15707b72b0ae215f0">isSleeping</a> () const</td></tr>
<tr class="memdesc:a50b8a1a0606542f15707b72b0ae215f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this soft body is sleeping.  <br /></td></tr>
<tr class="separator:a50b8a1a0606542f15707b72b0ae215f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ec3a30186b37bf9498d0dd599c6257"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#af4ec3a30186b37bf9498d0dd599c6257">setSolverIterationCounts</a> (PxU32 minPositionIters, PxU32 minVelocityIters)</td></tr>
<tr class="memdesc:af4ec3a30186b37bf9498d0dd599c6257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the solver iteration counts for the body.  <br /></td></tr>
<tr class="separator:af4ec3a30186b37bf9498d0dd599c6257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2265532db39f1c302da481cff9de29f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a2265532db39f1c302da481cff9de29f6">getSolverIterationCounts</a> (PxU32 &amp;minPositionIters, PxU32 &amp;minVelocityIters) const</td></tr>
<tr class="memdesc:a2265532db39f1c302da481cff9de29f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the solver iteration counts.  <br /></td></tr>
<tr class="separator:a2265532db39f1c302da481cff9de29f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7460e06efc162477757e1db9cfc898a2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a7460e06efc162477757e1db9cfc898a2">getShape</a> ()</td></tr>
<tr class="memdesc:a7460e06efc162477757e1db9cfc898a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the shape pointer belonging to the actor.  <br /></td></tr>
<tr class="separator:a7460e06efc162477757e1db9cfc898a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0272d41af4b4adcee83cf12d4c4e2492"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a0272d41af4b4adcee83cf12d4c4e2492">getCollisionMesh</a> ()</td></tr>
<tr class="memdesc:a0272d41af4b4adcee83cf12d4c4e2492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the collision mesh pointer.  <br /></td></tr>
<tr class="separator:a0272d41af4b4adcee83cf12d4c4e2492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe546777169959ae0a817f5263b8e723"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#abe546777169959ae0a817f5263b8e723">getSimulationMesh</a> ()</td></tr>
<tr class="memdesc:abe546777169959ae0a817f5263b8e723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the simulation mesh pointer.  <br /></td></tr>
<tr class="separator:abe546777169959ae0a817f5263b8e723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8802c7d01c763ee631d102f313f4cf59"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_soft_body_aux_data.html">PxSoftBodyAuxData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a8802c7d01c763ee631d102f313f4cf59">getSoftBodyAuxData</a> ()</td></tr>
<tr class="memdesc:a8802c7d01c763ee631d102f313f4cf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the simulation state pointer.  <br /></td></tr>
<tr class="separator:a8802c7d01c763ee631d102f313f4cf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdeda0387029495cbc11a6610e9d258d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#acdeda0387029495cbc11a6610e9d258d">attachShape</a> (<a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> &amp;shape)</td></tr>
<tr class="memdesc:acdeda0387029495cbc11a6610e9d258d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a shape.  <br /></td></tr>
<tr class="separator:acdeda0387029495cbc11a6610e9d258d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc86fb7943d50aae402c1001cb01842"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#adcc86fb7943d50aae402c1001cb01842">attachSimulationMesh</a> (<a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> &amp;simulationMesh, <a class="el" href="classphysx_1_1_px_soft_body_aux_data.html">PxSoftBodyAuxData</a> &amp;softBodyAuxData)</td></tr>
<tr class="memdesc:adcc86fb7943d50aae402c1001cb01842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a simulation mesh.  <br /></td></tr>
<tr class="separator:adcc86fb7943d50aae402c1001cb01842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b4237b5b7b860fba2bf3377f309f6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a84b4237b5b7b860fba2bf3377f309f6f">detachShape</a> ()</td></tr>
<tr class="memdesc:a84b4237b5b7b860fba2bf3377f309f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the shape.  <br /></td></tr>
<tr class="separator:a84b4237b5b7b860fba2bf3377f309f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0bda2ef6e089cf443503077ae3d93a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a1b0bda2ef6e089cf443503077ae3d93a">detachSimulationMesh</a> ()</td></tr>
<tr class="memdesc:a1b0bda2ef6e089cf443503077ae3d93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the simulation mesh.  <br /></td></tr>
<tr class="separator:a1b0bda2ef6e089cf443503077ae3d93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fecbe185a5f96a553e3ecc5d3d22586"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a6fecbe185a5f96a553e3ecc5d3d22586">release</a> ()</td></tr>
<tr class="memdesc:a6fecbe185a5f96a553e3ecc5d3d22586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the softbody.  <br /></td></tr>
<tr class="separator:a6fecbe185a5f96a553e3ecc5d3d22586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdb1397c0bfc710059b5ee7e87e23d2"><td class="memItemLeft" align="right" valign="top"><a id="a6bdb1397c0bfc710059b5ee7e87e23d2" name="a6bdb1397c0bfc710059b5ee7e87e23d2"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> const <a class="el" href="classphysx_1_1_sc_1_1_soft_body_core.html">Sc::SoftBodyCore</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCore</b> () const</td></tr>
<tr class="separator:a6bdb1397c0bfc710059b5ee7e87e23d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ff6699408f28e568725773e78fb97d"><td class="memItemLeft" align="right" valign="top"><a id="ab9ff6699408f28e568725773e78fb97d" name="ab9ff6699408f28e568725773e78fb97d"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_sc_1_1_soft_body_core.html">Sc::SoftBodyCore</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCore</b> ()</td></tr>
<tr class="separator:ab9ff6699408f28e568725773e78fb97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dc4681d8b7f45784e662dd65dbb83e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#ad2dc4681d8b7f45784e662dd65dbb83e">addParticleFilter</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *buffer, PxU32 particleId, PxU32 tetId)</td></tr>
<tr class="memdesc:ad2dc4681d8b7f45784e662dd65dbb83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a collision filter between a particle and a tetrahedron in the soft body's collision mesh.  <br /></td></tr>
<tr class="separator:ad2dc4681d8b7f45784e662dd65dbb83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd1fb08f0f7069e09f37be5607df3ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a3bd1fb08f0f7069e09f37be5607df3ac">removeParticleFilter</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *buffer, PxU32 particleId, PxU32 tetId)</td></tr>
<tr class="memdesc:a3bd1fb08f0f7069e09f37be5607df3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a collision filter between a particle and a tetrahedron in the soft body's collision mesh.  <br /></td></tr>
<tr class="separator:a3bd1fb08f0f7069e09f37be5607df3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005fce4e8c69d42ed397b063136565c9"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a005fce4e8c69d42ed397b063136565c9">addParticleAttachment</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *buffer, PxU32 particleId, PxU32 tetId, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;barycentric)</td></tr>
<tr class="memdesc:a005fce4e8c69d42ed397b063136565c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not.  <br /></td></tr>
<tr class="separator:a005fce4e8c69d42ed397b063136565c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1a90aaef852b165a94d5d5a19601fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a1d1a90aaef852b165a94d5d5a19601fc">removeParticleAttachment</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, PxU32 handle)</td></tr>
<tr class="memdesc:a1d1a90aaef852b165a94d5d5a19601fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not.  <br /></td></tr>
<tr class="separator:a1d1a90aaef852b165a94d5d5a19601fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d0c3c97e086b461900e79327bfc9c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a31d0c3c97e086b461900e79327bfc9c8">addRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 vertId)</td></tr>
<tr class="memdesc:a31d0c3c97e086b461900e79327bfc9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a collision filter between a vertex in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:a31d0c3c97e086b461900e79327bfc9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5d98f6e8b4e4e262eb3210f5e4e91d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a4e5d98f6e8b4e4e262eb3210f5e4e91d">removeRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 vertId)</td></tr>
<tr class="memdesc:a4e5d98f6e8b4e4e262eb3210f5e4e91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a collision filter between a vertex in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:a4e5d98f6e8b4e4e262eb3210f5e4e91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af297b69811c935ac3a900befbd21638e"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#af297b69811c935ac3a900befbd21638e">addRigidAttachment</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 vertId, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;actorSpacePose, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint)</td></tr>
<tr class="memdesc:af297b69811c935ac3a900befbd21638e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <br /></td></tr>
<tr class="separator:af297b69811c935ac3a900befbd21638e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af8ad423b1fb1a40f820563ee491d72"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a2af8ad423b1fb1a40f820563ee491d72">removeRigidAttachment</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 handle)</td></tr>
<tr class="memdesc:a2af8ad423b1fb1a40f820563ee491d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <br /></td></tr>
<tr class="separator:a2af8ad423b1fb1a40f820563ee491d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae9d773c4ef3ac8c86a67809718cbf6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a3ae9d773c4ef3ac8c86a67809718cbf6">addTetRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 tetIdx)</td></tr>
<tr class="memdesc:a3ae9d773c4ef3ac8c86a67809718cbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filter between a tetrahedron in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:a3ae9d773c4ef3ac8c86a67809718cbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73645316600c85639db4a150eb91adf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#af73645316600c85639db4a150eb91adf">removeTetRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 tetIdx)</td></tr>
<tr class="memdesc:af73645316600c85639db4a150eb91adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filter between a tetrahedron in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:af73645316600c85639db4a150eb91adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dda681f24e37f9126dee9206c12a243"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a5dda681f24e37f9126dee9206c12a243">addTetRigidAttachment</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 tetIdx, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;barycentric, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;actorSpacePose, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint)</td></tr>
<tr class="memdesc:a5dda681f24e37f9126dee9206c12a243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <br /></td></tr>
<tr class="separator:a5dda681f24e37f9126dee9206c12a243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc75faebd3eecc87040439f5d495309"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#aecc75faebd3eecc87040439f5d495309">addSoftBodyFilter</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *softbody0, PxU32 tetIdx0, PxU32 tetIdx1)</td></tr>
<tr class="memdesc:aecc75faebd3eecc87040439f5d495309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filter between a tetrahedron in a soft body and a tetrahedron in another soft body.  <br /></td></tr>
<tr class="separator:aecc75faebd3eecc87040439f5d495309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad584e5d0a8e6e2a3c6e26ff97123948f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#ad584e5d0a8e6e2a3c6e26ff97123948f">removeSoftBodyFilter</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *softbody0, PxU32 tetIdx0, PxU32 tetIdx1)</td></tr>
<tr class="memdesc:ad584e5d0a8e6e2a3c6e26ff97123948f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filter between a tetrahedron in a soft body and a tetrahedron in other soft body.  <br /></td></tr>
<tr class="separator:ad584e5d0a8e6e2a3c6e26ff97123948f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889850c0798dbd4145ad548745eee7e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a889850c0798dbd4145ad548745eee7e4">addSoftBodyFilters</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *softbody0, PxU32 *tetIndices0, PxU32 *tetIndices1, PxU32 tetIndicesSize)</td></tr>
<tr class="memdesc:a889850c0798dbd4145ad548745eee7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filters between a tetrahedron in a soft body with another soft body.  <br /></td></tr>
<tr class="separator:a889850c0798dbd4145ad548745eee7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4de9c04860fb81f471f500a96e90e6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#ac4de9c04860fb81f471f500a96e90e6f">removeSoftBodyFilters</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *softbody0, PxU32 *tetIndices0, PxU32 *tetIndices1, PxU32 tetIndicesSize)</td></tr>
<tr class="memdesc:ac4de9c04860fb81f471f500a96e90e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filters between a tetrahedron in a soft body with another soft body.  <br /></td></tr>
<tr class="separator:ac4de9c04860fb81f471f500a96e90e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200f3a2ddb701be64fcdb981f1a9e1a2"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a200f3a2ddb701be64fcdb981f1a9e1a2">addSoftBodyAttachment</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *softbody0, PxU32 tetIdx0, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;tetBarycentric0, PxU32 tetIdx1, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;tetBarycentric1, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint)</td></tr>
<tr class="memdesc:a200f3a2ddb701be64fcdb981f1a9e1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an attachment between two soft bodies.  <br /></td></tr>
<tr class="separator:a200f3a2ddb701be64fcdb981f1a9e1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c47f0e7a98b43272211aa15c11778ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a5c47f0e7a98b43272211aa15c11778ef">removeSoftBodyAttachment</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *softbody0, PxU32 handle)</td></tr>
<tr class="memdesc:a5c47f0e7a98b43272211aa15c11778ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attachment between a soft body and the other soft body. Be aware that destroying the soft body before destroying the attachment is illegal and may cause a crash.  <br /></td></tr>
<tr class="separator:a5c47f0e7a98b43272211aa15c11778ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae67852881f9d50ea2b8c84938c1c5a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a7ae67852881f9d50ea2b8c84938c1c5a">addClothFilter</a> (PxFEMCloth *cloth, PxU32 triIdx, PxU32 tetIdx)</td></tr>
<tr class="memdesc:a7ae67852881f9d50ea2b8c84938c1c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filter between a tetrahedron in a soft body and a triangle in a cloth.  <br /></td></tr>
<tr class="separator:a7ae67852881f9d50ea2b8c84938c1c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d0e44122f54cf956aa00e4eed4637c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a25d0e44122f54cf956aa00e4eed4637c">removeClothFilter</a> (PxFEMCloth *cloth, PxU32 triIdx, PxU32 tetIdx)</td></tr>
<tr class="memdesc:a25d0e44122f54cf956aa00e4eed4637c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filter between a tetrahedron in a soft body and a triangle in a cloth.  <br /></td></tr>
<tr class="separator:a25d0e44122f54cf956aa00e4eed4637c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa10948aeb97d5cb89f16e10ef919ba"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a5fa10948aeb97d5cb89f16e10ef919ba">addClothAttachment</a> (PxFEMCloth *cloth, PxU32 triIdx, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;triBarycentric, PxU32 tetIdx, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;tetBarycentric, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint)</td></tr>
<tr class="memdesc:a5fa10948aeb97d5cb89f16e10ef919ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an attachment between a soft body and a cloth. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the cloth does not.  <br /></td></tr>
<tr class="separator:a5fa10948aeb97d5cb89f16e10ef919ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ccd5efbe37a02b33020bf526fbb879"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a65ccd5efbe37a02b33020bf526fbb879">removeClothAttachment</a> (PxFEMCloth *cloth, PxU32 handle)</td></tr>
<tr class="memdesc:a65ccd5efbe37a02b33020bf526fbb879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attachment between a cloth and a soft body. Be aware that destroying the cloth before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the cloth does not.  <br /></td></tr>
<tr class="separator:a65ccd5efbe37a02b33020bf526fbb879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c88cf7b477783f4a3e5555b6d30eaf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a8c88cf7b477783f4a3e5555b6d30eaf1">setName</a> (const char *)</td></tr>
<tr class="memdesc:a8c88cf7b477783f4a3e5555b6d30eaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classphysx_1_1_np_soft_body.html#a45ba51d0ec2640598cc883d02575feae" title="Retrieves the name string set with setName().">getName()</a>.  <br /></td></tr>
<tr class="separator:a8c88cf7b477783f4a3e5555b6d30eaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ba51d0ec2640598cc883d02575feae"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a45ba51d0ec2640598cc883d02575feae">getName</a> () const</td></tr>
<tr class="memdesc:a45ba51d0ec2640598cc883d02575feae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the name string set with <a class="el" href="classphysx_1_1_np_soft_body.html#a8c88cf7b477783f4a3e5555b6d30eaf1" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>.  <br /></td></tr>
<tr class="separator:a45ba51d0ec2640598cc883d02575feae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16046224da390bf20d6ab5dcce6da341"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a16046224da390bf20d6ab5dcce6da341">getSimPositionInvMassCPU</a> ()</td></tr>
<tr class="memdesc:a16046224da390bf20d6ab5dcce6da341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the simulation mesh on the host.  <br /></td></tr>
<tr class="separator:a16046224da390bf20d6ab5dcce6da341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c507cfe064d0217afe06ee8fdbc094c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a2c507cfe064d0217afe06ee8fdbc094c">getSimVelocityInvMassCPU</a> ()</td></tr>
<tr class="memdesc:a2c507cfe064d0217afe06ee8fdbc094c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the velocities of the simulation mesh on the host.  <br /></td></tr>
<tr class="separator:a2c507cfe064d0217afe06ee8fdbc094c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470ac75a2de4ce6d2d9508ac16389c8e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#a470ac75a2de4ce6d2d9508ac16389c8e">getKinematicTargetCPU</a> ()</td></tr>
<tr class="memdesc:a470ac75a2de4ce6d2d9508ac16389c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the simulation mesh on the host.  <br /></td></tr>
<tr class="separator:a470ac75a2de4ce6d2d9508ac16389c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af781f6fcb1a3195826035444421cd3c8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#af781f6fcb1a3195826035444421cd3c8">getPositionInvMassCPU</a> ()</td></tr>
<tr class="memdesc:af781f6fcb1a3195826035444421cd3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the collision mesh on the host.  <br /></td></tr>
<tr class="separator:af781f6fcb1a3195826035444421cd3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85b9bd9c8d46799d5c1781dcb2c7666"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_soft_body.html#ab85b9bd9c8d46799d5c1781dcb2c7666">getRestPositionInvMassCPU</a> ()</td></tr>
<tr class="memdesc:ab85b9bd9c8d46799d5c1781dcb2c7666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the rest vertices of the collision mesh on the host.  <br /></td></tr>
<tr class="separator:ab85b9bd9c8d46799d5c1781dcb2c7666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fb08417873ea896d98b35ef38792a8"><td class="memItemLeft" align="right" valign="top"><a id="a93fb08417873ea896d98b35ef38792a8" name="a93fb08417873ea896d98b35ef38792a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>updateMaterials</b> ()</td></tr>
<tr class="separator:a93fb08417873ea896d98b35ef38792a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_np_actor_template"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_np_actor_template')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_np_actor_template.html">physx::NpActorTemplate&lt; PxSoftBody &gt;</a></td></tr>
<tr class="memitem:ac8d3d1ef5c7e35b70540db3e996e23ab inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top"><a id="ac8d3d1ef5c7e35b70540db3e996e23ab" name="ac8d3d1ef5c7e35b70540db3e996e23ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NpActorTemplate</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:ac8d3d1ef5c7e35b70540db3e996e23ab inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a322e4d293b078c6f7b7bed2b3b256 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top"><a id="a79a322e4d293b078c6f7b7bed2b3b256" name="a79a322e4d293b078c6f7b7bed2b3b256"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NpActorTemplate</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags, NpType::Enum type)</td></tr>
<tr class="separator:a79a322e4d293b078c6f7b7bed2b3b256 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a6f1afa2c34b814478bd4cb4d75835 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top"><a id="aa2a6f1afa2c34b814478bd4cb4d75835" name="aa2a6f1afa2c34b814478bd4cb4d75835"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>exportExtraData</b> (<a class="el" href="classphysx_1_1_px_serialization_context.html">PxSerializationContext</a> &amp;context)</td></tr>
<tr class="separator:aa2a6f1afa2c34b814478bd4cb4d75835 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6bd37002be02e87cfc4775ae469cce inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top"><a id="a6d6bd37002be02e87cfc4775ae469cce" name="a6d6bd37002be02e87cfc4775ae469cce"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>importExtraData</b> (<a class="el" href="classphysx_1_1_px_deserialization_context.html">PxDeserializationContext</a> &amp;context)</td></tr>
<tr class="separator:a6d6bd37002be02e87cfc4775ae469cce inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158f2be6f334d19a40b558e9ec44ae57 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top"><a id="a158f2be6f334d19a40b558e9ec44ae57" name="a158f2be6f334d19a40b558e9ec44ae57"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>resolveReferences</b> (<a class="el" href="classphysx_1_1_px_deserialization_context.html">PxDeserializationContext</a> &amp;context)</td></tr>
<tr class="separator:a158f2be6f334d19a40b558e9ec44ae57 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa105d090221aafe9649ceb9b209817e0 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#aa105d090221aafe9649ceb9b209817e0">release</a> ()=0</td></tr>
<tr class="separator:aa105d090221aafe9649ceb9b209817e0 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280eb3d252cc2d98cd6412dac0618fe0 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_actor_type.html#aa12d1dbb97bda016f592de47e67e3963">PxActorType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#a280eb3d252cc2d98cd6412dac0618fe0">getType</a> () const=0</td></tr>
<tr class="separator:a280eb3d252cc2d98cd6412dac0618fe0 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3b072b27e0f23ac4862058823bb45d inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_scene.html">PxScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#a2a3b072b27e0f23ac4862058823bb45d">getScene</a> () const <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="separator:a2a3b072b27e0f23ac4862058823bb45d inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961dec38a832a865d093f3940cc1bd32 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#a961dec38a832a865d093f3940cc1bd32">setName</a> (const char *) <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="separator:a961dec38a832a865d093f3940cc1bd32 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141bd0dd83403e9179d40c04a750874d inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#a141bd0dd83403e9179d40c04a750874d">getName</a> () const <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="separator:a141bd0dd83403e9179d40c04a750874d inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a072c095d1261dda9c5dd501bd0fd5 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#aa3a072c095d1261dda9c5dd501bd0fd5">getWorldBounds</a> (float inflation=1.01f) const=0</td></tr>
<tr class="separator:aa3a072c095d1261dda9c5dd501bd0fd5 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fba5f9ce993b4e4b18e6dac4ed3f28 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#a18fba5f9ce993b4e4b18e6dac4ed3f28">setActorFlag</a> (<a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8">PxActorFlag::Enum</a> flag, bool value) <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="separator:a18fba5f9ce993b4e4b18e6dac4ed3f28 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6bdc3cfe3967fd5dbea131da424811 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#a5c6bdc3cfe3967fd5dbea131da424811">setActorFlags</a> (<a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a> inFlags) <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="separator:a5c6bdc3cfe3967fd5dbea131da424811 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd5b40127e80d12872b43648ccd740e inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#afcd5b40127e80d12872b43648ccd740e">getActorFlags</a> () const <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="separator:afcd5b40127e80d12872b43648ccd740e inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3dfde0ca24db8c80cb7a0a9506c8e5 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#a1d3dfde0ca24db8c80cb7a0a9506c8e5">setDominanceGroup</a> (<a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a> dominanceGroup) <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="separator:a1d3dfde0ca24db8c80cb7a0a9506c8e5 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524eee3cee2369f7d2b0ac02b1842ae6 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#a524eee3cee2369f7d2b0ac02b1842ae6">getDominanceGroup</a> () const <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="separator:a524eee3cee2369f7d2b0ac02b1842ae6 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6270c3aed72c5c17dbdae5b1f60ceaf4 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#a6270c3aed72c5c17dbdae5b1f60ceaf4">setOwnerClient</a> (<a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a> inClient) <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="separator:a6270c3aed72c5c17dbdae5b1f60ceaf4 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb19c6fb723ff33f581ef8c134e0212 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#acfb19c6fb723ff33f581ef8c134e0212">getOwnerClient</a> () const <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="separator:acfb19c6fb723ff33f581ef8c134e0212 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4207106637fdda92c82ae84d076791 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_np_actor_template.html#a8c4207106637fdda92c82ae84d076791">getAggregate</a> () const <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="separator:a8c4207106637fdda92c82ae84d076791 inherit pub_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_soft_body"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_soft_body')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_soft_body.html">physx::PxSoftBody</a></td></tr>
<tr class="memitem:a43ba0e4e924c32131b00ba0d15ac5599 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a43ba0e4e924c32131b00ba0d15ac5599">setSoftBodyFlag</a> (<a class="el" href="structphysx_1_1_px_soft_body_flag.html#ad392f0ca084f5a0ec7f110b8c2476315">PxSoftBodyFlag::Enum</a> flag, bool val)=0</td></tr>
<tr class="memdesc:a43ba0e4e924c32131b00ba0d15ac5599 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single softbody flag.  <br /></td></tr>
<tr class="separator:a43ba0e4e924c32131b00ba0d15ac5599 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9ef79efcb2011b47bf133769535c64 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#add9ef79efcb2011b47bf133769535c64">setSoftBodyFlags</a> (<a class="el" href="classphysx_1_1_px_flags.html">PxSoftBodyFlags</a> flags)=0</td></tr>
<tr class="memdesc:add9ef79efcb2011b47bf133769535c64 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the softbody flags.  <br /></td></tr>
<tr class="separator:add9ef79efcb2011b47bf133769535c64 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56e6ff5f75fcce761f81155322afc94 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_flags.html">PxSoftBodyFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ad56e6ff5f75fcce761f81155322afc94">getSoftBodyFlag</a> () const =0</td></tr>
<tr class="memdesc:ad56e6ff5f75fcce761f81155322afc94 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the softbody flags.  <br /></td></tr>
<tr class="separator:ad56e6ff5f75fcce761f81155322afc94 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac90eaf62454ee3a35d824a5ac3668e4 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aac90eaf62454ee3a35d824a5ac3668e4">setParameter</a> (const <a class="el" href="structphysx_1_1_px_f_e_m_parameters.html">PxFEMParameters</a> parameters)=0</td></tr>
<tr class="memdesc:aac90eaf62454ee3a35d824a5ac3668e4 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parameter for FEM internal solve.  <br /></td></tr>
<tr class="separator:aac90eaf62454ee3a35d824a5ac3668e4 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae482aec041036f6187163848d1b8aaf0 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_f_e_m_parameters.html">PxFEMParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ae482aec041036f6187163848d1b8aaf0">getParameter</a> () const =0</td></tr>
<tr class="memdesc:ae482aec041036f6187163848d1b8aaf0 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get parameter for FEM internal solve.  <br /></td></tr>
<tr class="separator:ae482aec041036f6187163848d1b8aaf0 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977c8932888461538bba4f33395c650c inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a977c8932888461538bba4f33395c650c">readData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> &amp;buffer, bool flush=false)=0</td></tr>
<tr class="memdesc:a977c8932888461538bba4f33395c650c inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a read command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:a977c8932888461538bba4f33395c650c inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e154c7880a2f81bbb137bbef4b1a0fd inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a7e154c7880a2f81bbb137bbef4b1a0fd">readData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, bool flush=false)=0</td></tr>
<tr class="memdesc:a7e154c7880a2f81bbb137bbef4b1a0fd inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a read command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:a7e154c7880a2f81bbb137bbef4b1a0fd inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c79d6afd0c16411d2e45a5f1cc56252 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a3c79d6afd0c16411d2e45a5f1cc56252">writeData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> &amp;buffer, bool flush=false)=0</td></tr>
<tr class="memdesc:a3c79d6afd0c16411d2e45a5f1cc56252 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a write command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:a3c79d6afd0c16411d2e45a5f1cc56252 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fccbe8185a375cf42f9362d59f9748 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ad7fccbe8185a375cf42f9362d59f9748">writeData</a> (<a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a> flags, bool flush=false)=0</td></tr>
<tr class="memdesc:ad7fccbe8185a375cf42f9362d59f9748 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Issues a write command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.  <br /></td></tr>
<tr class="separator:ad7fccbe8185a375cf42f9362d59f9748 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8418698e3c39c87b07946a7f81cf2b23 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual PxCudaContextManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a8418698e3c39c87b07946a7f81cf2b23">getCudaContextManager</a> () const =0</td></tr>
<tr class="memdesc:a8418698e3c39c87b07946a7f81cf2b23 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cuda context manager.  <br /></td></tr>
<tr class="separator:a8418698e3c39c87b07946a7f81cf2b23 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478d801eed43606ac4e06b48c883e137 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a478d801eed43606ac4e06b48c883e137">setWakeCounter</a> (PxReal wakeCounterValue)=0</td></tr>
<tr class="memdesc:a478d801eed43606ac4e06b48c883e137 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wake counter for the soft body.  <br /></td></tr>
<tr class="separator:a478d801eed43606ac4e06b48c883e137 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18445e28706f4fa7f493c707eca4ef22 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual PxReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a18445e28706f4fa7f493c707eca4ef22">getWakeCounter</a> () const =0</td></tr>
<tr class="memdesc:a18445e28706f4fa7f493c707eca4ef22 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the wake counter of the soft body.  <br /></td></tr>
<tr class="separator:a18445e28706f4fa7f493c707eca4ef22 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131f8915719ffda345077d99118d946f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a131f8915719ffda345077d99118d946f">isSleeping</a> () const =0</td></tr>
<tr class="memdesc:a131f8915719ffda345077d99118d946f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this soft body is sleeping.  <br /></td></tr>
<tr class="separator:a131f8915719ffda345077d99118d946f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99548c514e09862494287eee688b0a1 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ab99548c514e09862494287eee688b0a1">setSolverIterationCounts</a> (PxU32 minPositionIters, PxU32 minVelocityIters=1)=0</td></tr>
<tr class="memdesc:ab99548c514e09862494287eee688b0a1 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the solver iteration counts for the body.  <br /></td></tr>
<tr class="separator:ab99548c514e09862494287eee688b0a1 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801ea01a7236f962fad8fca8adf8321e inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a801ea01a7236f962fad8fca8adf8321e">getSolverIterationCounts</a> (PxU32 &amp;minPositionIters, PxU32 &amp;minVelocityIters) const =0</td></tr>
<tr class="memdesc:a801ea01a7236f962fad8fca8adf8321e inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the solver iteration counts.  <br /></td></tr>
<tr class="separator:a801ea01a7236f962fad8fca8adf8321e inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e7f27f4209373f2dcce01448faa906 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a85e7f27f4209373f2dcce01448faa906">getShape</a> ()=0</td></tr>
<tr class="memdesc:a85e7f27f4209373f2dcce01448faa906 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the shape pointer belonging to the actor.  <br /></td></tr>
<tr class="separator:a85e7f27f4209373f2dcce01448faa906 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0473f9bb9b0e36c07c2754e001a22d inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a9c0473f9bb9b0e36c07c2754e001a22d">getCollisionMesh</a> ()=0</td></tr>
<tr class="memdesc:a9c0473f9bb9b0e36c07c2754e001a22d inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the collision mesh pointer.  <br /></td></tr>
<tr class="separator:a9c0473f9bb9b0e36c07c2754e001a22d inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f670bd0d2719c737aa52f562bd1a31 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ad2f670bd0d2719c737aa52f562bd1a31">getSimulationMesh</a> ()=0</td></tr>
<tr class="memdesc:ad2f670bd0d2719c737aa52f562bd1a31 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the simulation mesh pointer.  <br /></td></tr>
<tr class="separator:ad2f670bd0d2719c737aa52f562bd1a31 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e96324d4a20e9938900df58e2bd074 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_soft_body_aux_data.html">PxSoftBodyAuxData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a46e96324d4a20e9938900df58e2bd074">getSoftBodyAuxData</a> ()=0</td></tr>
<tr class="memdesc:a46e96324d4a20e9938900df58e2bd074 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the simulation state pointer.  <br /></td></tr>
<tr class="separator:a46e96324d4a20e9938900df58e2bd074 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa602720974de655d95049ac7dcee3c96 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aa602720974de655d95049ac7dcee3c96">attachShape</a> (<a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> &amp;shape)=0</td></tr>
<tr class="memdesc:aa602720974de655d95049ac7dcee3c96 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a shape.  <br /></td></tr>
<tr class="separator:aa602720974de655d95049ac7dcee3c96 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1358e4fc28d149ee1287edebd4240afe inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a1358e4fc28d149ee1287edebd4240afe">attachSimulationMesh</a> (<a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> &amp;simulationMesh, <a class="el" href="classphysx_1_1_px_soft_body_aux_data.html">PxSoftBodyAuxData</a> &amp;softBodyAuxData)=0</td></tr>
<tr class="memdesc:a1358e4fc28d149ee1287edebd4240afe inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a simulation mesh.  <br /></td></tr>
<tr class="separator:a1358e4fc28d149ee1287edebd4240afe inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e89cb3118981013838932b5328b2eb3 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a8e89cb3118981013838932b5328b2eb3">detachShape</a> ()=0</td></tr>
<tr class="memdesc:a8e89cb3118981013838932b5328b2eb3 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the shape.  <br /></td></tr>
<tr class="separator:a8e89cb3118981013838932b5328b2eb3 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45855574b47484673ddbc1b7b919e499 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a45855574b47484673ddbc1b7b919e499">detachSimulationMesh</a> ()=0</td></tr>
<tr class="memdesc:a45855574b47484673ddbc1b7b919e499 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the simulation mesh.  <br /></td></tr>
<tr class="separator:a45855574b47484673ddbc1b7b919e499 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd25cee2966691df649efab08c66648b inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#abd25cee2966691df649efab08c66648b">release</a> ()=0</td></tr>
<tr class="memdesc:abd25cee2966691df649efab08c66648b inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the softbody.  <br /></td></tr>
<tr class="separator:abd25cee2966691df649efab08c66648b inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe61c672f855820507b4ca39eaf44c3 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a7fe61c672f855820507b4ca39eaf44c3">addParticleFilter</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *buffer, PxU32 particleId, PxU32 tetId)=0</td></tr>
<tr class="memdesc:a7fe61c672f855820507b4ca39eaf44c3 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a collision filter between a particle and a tetrahedron in the soft body's collision mesh.  <br /></td></tr>
<tr class="separator:a7fe61c672f855820507b4ca39eaf44c3 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e58d78320439bfa33d1806dcc172ed5 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a6e58d78320439bfa33d1806dcc172ed5">removeParticleFilter</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *buffer, PxU32 particleId, PxU32 tetId)=0</td></tr>
<tr class="memdesc:a6e58d78320439bfa33d1806dcc172ed5 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a collision filter between a particle and a tetrahedron in the soft body's collision mesh.  <br /></td></tr>
<tr class="separator:a6e58d78320439bfa33d1806dcc172ed5 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeaf25e7ea0ff2976a0cb39e20cff26 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aaaeaf25e7ea0ff2976a0cb39e20cff26">addParticleAttachment</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *buffer, PxU32 particleId, PxU32 tetId, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;barycentric)=0</td></tr>
<tr class="memdesc:aaaeaf25e7ea0ff2976a0cb39e20cff26 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not.  <br /></td></tr>
<tr class="separator:aaaeaf25e7ea0ff2976a0cb39e20cff26 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab99896beb748035721e2475893d3bfd inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aab99896beb748035721e2475893d3bfd">removeParticleAttachment</a> (<a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *particlesystem, PxU32 handle)=0</td></tr>
<tr class="memdesc:aab99896beb748035721e2475893d3bfd inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not.  <br /></td></tr>
<tr class="separator:aab99896beb748035721e2475893d3bfd inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d283966ec1724c1833be787bdc51ee inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a34d283966ec1724c1833be787bdc51ee">addRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 vertId)=0</td></tr>
<tr class="memdesc:a34d283966ec1724c1833be787bdc51ee inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a collision filter between a vertex in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:a34d283966ec1724c1833be787bdc51ee inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fa0a9aa318e559478c127e771cb86a inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ae8fa0a9aa318e559478c127e771cb86a">removeRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 vertId)=0</td></tr>
<tr class="memdesc:ae8fa0a9aa318e559478c127e771cb86a inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a collision filter between a vertex in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:ae8fa0a9aa318e559478c127e771cb86a inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0df35db3b120d40bc457fe46edf1923 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ab0df35db3b120d40bc457fe46edf1923">addRigidAttachment</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 vertId, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;actorSpacePose, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint=NULL)=0</td></tr>
<tr class="memdesc:ab0df35db3b120d40bc457fe46edf1923 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <br /></td></tr>
<tr class="separator:ab0df35db3b120d40bc457fe46edf1923 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3807a77c6ce9fc27b472a1f4093bcb7e inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a3807a77c6ce9fc27b472a1f4093bcb7e">removeRigidAttachment</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 handle)=0</td></tr>
<tr class="memdesc:a3807a77c6ce9fc27b472a1f4093bcb7e inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <br /></td></tr>
<tr class="separator:a3807a77c6ce9fc27b472a1f4093bcb7e inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1223e4814b8b781fe274d549492cde9f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a1223e4814b8b781fe274d549492cde9f">addTetRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 tetIdx)=0</td></tr>
<tr class="memdesc:a1223e4814b8b781fe274d549492cde9f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filter between a tetrahedron in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:a1223e4814b8b781fe274d549492cde9f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cc13579616f7f83ff7d9eb046dfc44 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ac2cc13579616f7f83ff7d9eb046dfc44">removeTetRigidFilter</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 tetIdx)=0</td></tr>
<tr class="memdesc:ac2cc13579616f7f83ff7d9eb046dfc44 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filter between a tetrahedron in a soft body and a rigid body.  <br /></td></tr>
<tr class="separator:ac2cc13579616f7f83ff7d9eb046dfc44 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4efd157fd4bceabee9d278c34dcda7 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#abe4efd157fd4bceabee9d278c34dcda7">addTetRigidAttachment</a> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *actor, PxU32 tetIdx, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;barycentric, const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;actorSpacePose, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint=NULL)=0</td></tr>
<tr class="memdesc:abe4efd157fd4bceabee9d278c34dcda7 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not.  <br /></td></tr>
<tr class="separator:abe4efd157fd4bceabee9d278c34dcda7 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51d32b513aea14f5f15c8e7982b5bf3 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ac51d32b513aea14f5f15c8e7982b5bf3">addSoftBodyFilter</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *otherSoftBody, PxU32 otherTetIdx, PxU32 tetIdx1)=0</td></tr>
<tr class="memdesc:ac51d32b513aea14f5f15c8e7982b5bf3 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filter between a tetrahedron in a soft body and a tetrahedron in another soft body.  <br /></td></tr>
<tr class="separator:ac51d32b513aea14f5f15c8e7982b5bf3 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c8c3660b669a7bb65226e816248886 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ab4c8c3660b669a7bb65226e816248886">removeSoftBodyFilter</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *otherSoftBody, PxU32 otherTetIdx, PxU32 tetIdx1)=0</td></tr>
<tr class="memdesc:ab4c8c3660b669a7bb65226e816248886 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filter between a tetrahedron in a soft body and a tetrahedron in other soft body.  <br /></td></tr>
<tr class="separator:ab4c8c3660b669a7bb65226e816248886 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33c57f9d8f328b206398c3e8b551861 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ae33c57f9d8f328b206398c3e8b551861">addSoftBodyFilters</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *otherSoftBody, PxU32 *otherTetIndices, PxU32 *tetIndices, PxU32 tetIndicesSize)=0</td></tr>
<tr class="memdesc:ae33c57f9d8f328b206398c3e8b551861 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filters between a tetrahedron in a soft body with another soft body.  <br /></td></tr>
<tr class="separator:ae33c57f9d8f328b206398c3e8b551861 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae814d96255b19f85fdb33043bb862fba inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ae814d96255b19f85fdb33043bb862fba">removeSoftBodyFilters</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *otherSoftBody, PxU32 *otherTetIndices, PxU32 *tetIndices, PxU32 tetIndicesSize)=0</td></tr>
<tr class="memdesc:ae814d96255b19f85fdb33043bb862fba inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filters between a tetrahedron in a soft body with another soft body.  <br /></td></tr>
<tr class="separator:ae814d96255b19f85fdb33043bb862fba inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c6454c000cdf9b96e9ae58a826041f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a29c6454c000cdf9b96e9ae58a826041f">addSoftBodyAttachment</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *softbody0, PxU32 tetIdx0, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;tetBarycentric0, PxU32 tetIdx1, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;tetBarycentric1, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint=NULL)=0</td></tr>
<tr class="memdesc:a29c6454c000cdf9b96e9ae58a826041f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an attachment between two soft bodies.  <br /></td></tr>
<tr class="separator:a29c6454c000cdf9b96e9ae58a826041f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6acf80193100b2713a0e58229611b5 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aee6acf80193100b2713a0e58229611b5">removeSoftBodyAttachment</a> (<a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *softbody0, PxU32 handle)=0</td></tr>
<tr class="memdesc:aee6acf80193100b2713a0e58229611b5 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attachment between a soft body and the other soft body. Be aware that destroying the soft body before destroying the attachment is illegal and may cause a crash.  <br /></td></tr>
<tr class="separator:aee6acf80193100b2713a0e58229611b5 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1da16afabd826cc9db106f1749edbd4 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#af1da16afabd826cc9db106f1749edbd4">addClothFilter</a> (PxFEMCloth *cloth, PxU32 triIdx, PxU32 tetIdx)=0</td></tr>
<tr class="memdesc:af1da16afabd826cc9db106f1749edbd4 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates collision filter between a tetrahedron in a soft body and a triangle in a cloth.  <br /></td></tr>
<tr class="separator:af1da16afabd826cc9db106f1749edbd4 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253209fa24469ac27d7ddf9109203acd inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a253209fa24469ac27d7ddf9109203acd">removeClothFilter</a> (PxFEMCloth *cloth, PxU32 triIdx, PxU32 tetIdx)=0</td></tr>
<tr class="memdesc:a253209fa24469ac27d7ddf9109203acd inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes collision filter between a tetrahedron in a soft body and a triangle in a cloth.  <br /></td></tr>
<tr class="separator:a253209fa24469ac27d7ddf9109203acd inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb8c9c3b1a546dcc8b5ed73d854da21 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#abbb8c9c3b1a546dcc8b5ed73d854da21">addClothAttachment</a> (PxFEMCloth *cloth, PxU32 triIdx, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;triBarycentric, PxU32 tetIdx, const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;tetBarycentric, <a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *constraint=NULL)=0</td></tr>
<tr class="memdesc:abbb8c9c3b1a546dcc8b5ed73d854da21 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an attachment between a soft body and a cloth. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the cloth does not.  <br /></td></tr>
<tr class="separator:abbb8c9c3b1a546dcc8b5ed73d854da21 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0e444fad640b513acc99f42f7a6f56 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#acb0e444fad640b513acc99f42f7a6f56">removeClothAttachment</a> (PxFEMCloth *cloth, PxU32 handle)=0</td></tr>
<tr class="memdesc:acb0e444fad640b513acc99f42f7a6f56 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases an attachment between a cloth and a soft body. Be aware that destroying the cloth before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the cloth does not.  <br /></td></tr>
<tr class="separator:acb0e444fad640b513acc99f42f7a6f56 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13967dbaef4161b72e48f685c39b077 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#af13967dbaef4161b72e48f685c39b077">getSimPositionInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:af13967dbaef4161b72e48f685c39b077 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the simulation mesh on the host.  <br /></td></tr>
<tr class="separator:af13967dbaef4161b72e48f685c39b077 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b2dba42ea1ab7e59a27b30d4a7203b inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aa7b2dba42ea1ab7e59a27b30d4a7203b">getKinematicTargetCPU</a> ()=0</td></tr>
<tr class="memdesc:aa7b2dba42ea1ab7e59a27b30d4a7203b inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the simulation mesh on the host.  <br /></td></tr>
<tr class="separator:aa7b2dba42ea1ab7e59a27b30d4a7203b inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a56a2c3af0a2b35b10c054bef2baa7 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ae9a56a2c3af0a2b35b10c054bef2baa7">getSimVelocityInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:ae9a56a2c3af0a2b35b10c054bef2baa7 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the velocities of the simulation mesh on the host.  <br /></td></tr>
<tr class="separator:ae9a56a2c3af0a2b35b10c054bef2baa7 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cea5ff304ad2d73c3e71147613e818f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a4cea5ff304ad2d73c3e71147613e818f">getPositionInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:a4cea5ff304ad2d73c3e71147613e818f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the vertices of the collision mesh on the host.  <br /></td></tr>
<tr class="separator:a4cea5ff304ad2d73c3e71147613e818f inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed600012be729205b6a2ce757199a9e1 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#aed600012be729205b6a2ce757199a9e1">getRestPositionInvMassCPU</a> ()=0</td></tr>
<tr class="memdesc:aed600012be729205b6a2ce757199a9e1 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the rest vertices of the collision mesh on the host.  <br /></td></tr>
<tr class="separator:aed600012be729205b6a2ce757199a9e1 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486959160c394478b2f37b8cb1dea091 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a486959160c394478b2f37b8cb1dea091">getWorldBounds</a> (float inflation=1.01f) const =0</td></tr>
<tr class="memdesc:a486959160c394478b2f37b8cb1dea091 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the soft body.  <br /></td></tr>
<tr class="separator:a486959160c394478b2f37b8cb1dea091 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3867e1e682567681e73ee0f68828069c inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual PxU32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a3867e1e682567681e73ee0f68828069c">getGpuSoftBodyIndex</a> ()=0</td></tr>
<tr class="memdesc:a3867e1e682567681e73ee0f68828069c inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GPU soft body index.  <br /></td></tr>
<tr class="separator:a3867e1e682567681e73ee0f68828069c inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea6c35b687859239b5a889692ebac94 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#a3ea6c35b687859239b5a889692ebac94">getConcreteTypeName</a> () const <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="memdesc:a3ea6c35b687859239b5a889692ebac94 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string name of dynamic type.  <br /></td></tr>
<tr class="separator:a3ea6c35b687859239b5a889692ebac94 inherit pub_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782e6bd48fb10f393581302d428eee19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a782e6bd48fb10f393581302d428eee19">release</a> ()=0</td></tr>
<tr class="memdesc:a782e6bd48fb10f393581302d428eee19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the actor.  <br /></td></tr>
<tr class="separator:a782e6bd48fb10f393581302d428eee19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff803bacb565652fb46ab69cda1d2526"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structphysx_1_1_px_actor_type.html#aa12d1dbb97bda016f592de47e67e3963">PxActorType::Enum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aff803bacb565652fb46ab69cda1d2526">getType</a> () const =0</td></tr>
<tr class="memdesc:aff803bacb565652fb46ab69cda1d2526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the type of actor.  <br /></td></tr>
<tr class="separator:aff803bacb565652fb46ab69cda1d2526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002cfb766d7d8aa71f174980fe7b1c6b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_scene.html">PxScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a002cfb766d7d8aa71f174980fe7b1c6b">getScene</a> () const =0</td></tr>
<tr class="memdesc:a002cfb766d7d8aa71f174980fe7b1c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the scene which this actor belongs to.  <br /></td></tr>
<tr class="separator:a002cfb766d7d8aa71f174980fe7b1c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab374c355cdd9c9b5a93479a8c751704a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#ab374c355cdd9c9b5a93479a8c751704a">setName</a> (const char *name)=0</td></tr>
<tr class="memdesc:ab374c355cdd9c9b5a93479a8c751704a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a name string for the object that can be retrieved with <a class="el" href="classphysx_1_1_px_actor.html#aad553a24aa6546e93bfb887d0c27fba9" title="Retrieves the name string set with setName().">getName()</a>.  <br /></td></tr>
<tr class="separator:ab374c355cdd9c9b5a93479a8c751704a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad553a24aa6546e93bfb887d0c27fba9"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aad553a24aa6546e93bfb887d0c27fba9">getName</a> () const =0</td></tr>
<tr class="memdesc:aad553a24aa6546e93bfb887d0c27fba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the name string set with <a class="el" href="classphysx_1_1_px_actor.html#ab374c355cdd9c9b5a93479a8c751704a" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>.  <br /></td></tr>
<tr class="separator:aad553a24aa6546e93bfb887d0c27fba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4121e4d3f38d9303b840159ac18bc5d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#ab4121e4d3f38d9303b840159ac18bc5d">getWorldBounds</a> (float inflation=1.01f) const =0</td></tr>
<tr class="memdesc:ab4121e4d3f38d9303b840159ac18bc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the axis aligned bounding box enclosing the actor.  <br /></td></tr>
<tr class="separator:ab4121e4d3f38d9303b840159ac18bc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6587b0a441c214a3f4504099105e298f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a6587b0a441c214a3f4504099105e298f">setActorFlag</a> (<a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8">PxActorFlag::Enum</a> flag, bool value)=0</td></tr>
<tr class="memdesc:a6587b0a441c214a3f4504099105e298f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises or clears a particular actor flag.  <br /></td></tr>
<tr class="separator:a6587b0a441c214a3f4504099105e298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47d905605f403aa95aee541a772b696"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#aa47d905605f403aa95aee541a772b696">setActorFlags</a> (<a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a> inFlags)=0</td></tr>
<tr class="memdesc:aa47d905605f403aa95aee541a772b696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the actor flags.  <br /></td></tr>
<tr class="separator:aa47d905605f403aa95aee541a772b696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3aebddb7b31092182606c61398983a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a5d3aebddb7b31092182606c61398983a">getActorFlags</a> () const =0</td></tr>
<tr class="memdesc:a5d3aebddb7b31092182606c61398983a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the <a class="el" href="classphysx_1_1_px_actor.html" title="PxActor is the base class for the main simulation objects in the physics SDK.">PxActor</a> flags.  <br /></td></tr>
<tr class="separator:a5d3aebddb7b31092182606c61398983a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3786b0f53c9a37074372d0ea62ce348d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a3786b0f53c9a37074372d0ea62ce348d">setDominanceGroup</a> (<a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a> dominanceGroup)=0</td></tr>
<tr class="memdesc:a3786b0f53c9a37074372d0ea62ce348d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns dynamic actors a dominance group identifier.  <br /></td></tr>
<tr class="separator:a3786b0f53c9a37074372d0ea62ce348d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7effc9b077780ffd713baa8869feae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a4b7effc9b077780ffd713baa8869feae">getDominanceGroup</a> () const =0</td></tr>
<tr class="memdesc:a4b7effc9b077780ffd713baa8869feae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the value set with <a class="el" href="classphysx_1_1_px_actor.html#a3786b0f53c9a37074372d0ea62ce348d" title="Assigns dynamic actors a dominance group identifier.">setDominanceGroup()</a>.  <br /></td></tr>
<tr class="separator:a4b7effc9b077780ffd713baa8869feae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160170378b1a28ef6f82f9c603b3cdf9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a160170378b1a28ef6f82f9c603b3cdf9">setOwnerClient</a> (<a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a> inClient)=0</td></tr>
<tr class="memdesc:a160170378b1a28ef6f82f9c603b3cdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the owner client of an actor.  <br /></td></tr>
<tr class="separator:a160170378b1a28ef6f82f9c603b3cdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fe5ab2d87b2cded54153370492875"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a0f3fe5ab2d87b2cded54153370492875">getOwnerClient</a> () const =0</td></tr>
<tr class="memdesc:a0f3fe5ab2d87b2cded54153370492875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the owner client that was specified at creation time.  <br /></td></tr>
<tr class="separator:a0f3fe5ab2d87b2cded54153370492875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2001117af8250e4afc077e160307aa13"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a2001117af8250e4afc077e160307aa13">getAggregate</a> () const =0</td></tr>
<tr class="memdesc:a2001117af8250e4afc077e160307aa13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the aggregate the actor might be a part of.  <br /></td></tr>
<tr class="separator:a2001117af8250e4afc077e160307aa13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a09013f88c156cfcdfcb001611360e92c">release</a> ()=0</td></tr>
<tr class="memdesc:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the <a class="el" href="classphysx_1_1_px_base.html" title="Base class for objects that can be members of a PxCollection.">PxBase</a> instance, please check documentation of release in derived class.  <br /></td></tr>
<tr class="separator:a09013f88c156cfcdfcb001611360e92c inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aea4c4ef95da2697f36d3a9fc9a2f897a">getConcreteTypeName</a> () const =0</td></tr>
<tr class="memdesc:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns string name of dynamic type.  <br /></td></tr>
<tr class="separator:aea4c4ef95da2697f36d3a9fc9a2f897a inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="a76be84f268e30c6fcb62a413963908db" name="a76be84f268e30c6fcb62a413963908db"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is</b> ()</td></tr>
<tr class="separator:a76be84f268e30c6fcb62a413963908db inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="a114ba2d2c3e2e50368c7003660b7e78d" name="a114ba2d2c3e2e50368c7003660b7e78d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is</b> () const</td></tr>
<tr class="separator:a114ba2d2c3e2e50368c7003660b7e78d inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> PxType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aeb75b831810e817d266223ccb244f3e4">getConcreteType</a> () const</td></tr>
<tr class="memdesc:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns concrete type of object.  <br /></td></tr>
<tr class="separator:aeb75b831810e817d266223ccb244f3e4 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#aa1f16f63ebbcad8aff05560d28709ff0">setBaseFlag</a> (PxBaseFlag::Enum flag, bool value)</td></tr>
<tr class="memdesc:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="structphysx_1_1_px_base_flag.html" title="Flags for PxBase.">PxBaseFlag</a> <br  />
  <br /></td></tr>
<tr class="separator:aa1f16f63ebbcad8aff05560d28709ff0 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a87724fce99cffbdd787a13391e58c04e">setBaseFlags</a> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> inFlags)</td></tr>
<tr class="memdesc:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PxBaseFlags <br  />
  <br /></td></tr>
<tr class="separator:a87724fce99cffbdd787a13391e58c04e inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a1f7953973ba7e246effc9d4f6e6f34ab">getBaseFlags</a> () const</td></tr>
<tr class="memdesc:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns PxBaseFlags.  <br /></td></tr>
<tr class="separator:a1f7953973ba7e246effc9d4f6e6f34ab inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a43f6a532bcc3da9e6fc8977094f419d9">isReleasable</a> () const</td></tr>
<tr class="memdesc:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the object is subordinate.  <br /></td></tr>
<tr class="separator:a43f6a532bcc3da9e6fc8977094f419d9 inherit pub_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_np_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_np_actor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_np_actor.html">physx::NpActor</a></td></tr>
<tr class="memitem:a8438a0f26699a6c0572683b16cd54853 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a8438a0f26699a6c0572683b16cd54853" name="a8438a0f26699a6c0572683b16cd54853"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NpActor</b> (const <a class="el" href="namespacephysx.html#ac0b3747190a9156618f0aed307778eda">PxEMPTY</a>)</td></tr>
<tr class="separator:a8438a0f26699a6c0572683b16cd54853 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166538d82a71e8742d5a8639d8bf11a1 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a166538d82a71e8742d5a8639d8bf11a1" name="a166538d82a71e8742d5a8639d8bf11a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>exportExtraData</b> (<a class="el" href="classphysx_1_1_px_serialization_context.html">PxSerializationContext</a> &amp;stream)</td></tr>
<tr class="separator:a166538d82a71e8742d5a8639d8bf11a1 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b455acbff86abd068a47e9c0a0c23d inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a23b455acbff86abd068a47e9c0a0c23d" name="a23b455acbff86abd068a47e9c0a0c23d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>importExtraData</b> (<a class="el" href="classphysx_1_1_px_deserialization_context.html">PxDeserializationContext</a> &amp;context)</td></tr>
<tr class="separator:a23b455acbff86abd068a47e9c0a0c23d inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e00793d14bd0111c7e7e85c62cd9b0 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="ab5e00793d14bd0111c7e7e85c62cd9b0" name="ab5e00793d14bd0111c7e7e85c62cd9b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resolveReferences</b> (<a class="el" href="classphysx_1_1_px_deserialization_context.html">PxDeserializationContext</a> &amp;context)</td></tr>
<tr class="separator:ab5e00793d14bd0111c7e7e85c62cd9b0 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380a0c8f65509f9fa6b9456578385b21 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a380a0c8f65509f9fa6b9456578385b21" name="a380a0c8f65509f9fa6b9456578385b21"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NpActor</b> (NpType::Enum type)</td></tr>
<tr class="separator:a380a0c8f65509f9fa6b9456578385b21 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e8db22551ac1756c4f7d40b1b82827 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a72e8db22551ac1756c4f7d40b1b82827" name="a72e8db22551ac1756c4f7d40b1b82827"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeConstraints</b> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> &amp;owner)</td></tr>
<tr class="separator:a72e8db22551ac1756c4f7d40b1b82827 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b84185348c28a2c5bf79dd2d68bfacb inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a2b84185348c28a2c5bf79dd2d68bfacb" name="a2b84185348c28a2c5bf79dd2d68bfacb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeFromAggregate</b> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;owner)</td></tr>
<tr class="separator:a2b84185348c28a2c5bf79dd2d68bfacb inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50429c19f75a7fb7e4fc1e333dbd2ea9 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a50429c19f75a7fb7e4fc1e333dbd2ea9" name="a50429c19f75a7fb7e4fc1e333dbd2ea9"></a>
<a class="el" href="classphysx_1_1_np_aggregate.html">NpAggregate</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getNpAggregate</b> (PxU32 &amp;index) const</td></tr>
<tr class="separator:a50429c19f75a7fb7e4fc1e333dbd2ea9 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c469997dfaff9d938efddc23c487cc4 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a1c469997dfaff9d938efddc23c487cc4" name="a1c469997dfaff9d938efddc23c487cc4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setAggregate</b> (<a class="el" href="classphysx_1_1_np_aggregate.html">NpAggregate</a> *np, <a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;owner)</td></tr>
<tr class="separator:a1c469997dfaff9d938efddc23c487cc4 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182ec84af98481e16926fe764a887701 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a182ec84af98481e16926fe764a887701" name="a182ec84af98481e16926fe764a887701"></a>
<a class="el" href="classphysx_1_1_px_aggregate.html">PxAggregate</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getAggregate</b> () const</td></tr>
<tr class="separator:a182ec84af98481e16926fe764a887701 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0545fcb603c4ffd2377a1c56aa85b6 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a7c0545fcb603c4ffd2377a1c56aa85b6" name="a7c0545fcb603c4ffd2377a1c56aa85b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scSetDominanceGroup</b> (<a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a> v)</td></tr>
<tr class="separator:a7c0545fcb603c4ffd2377a1c56aa85b6 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a2361a1d5afd5ab74680717331a539 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a08a2361a1d5afd5ab74680717331a539" name="a08a2361a1d5afd5ab74680717331a539"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scSetOwnerClient</b> (<a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a> inId)</td></tr>
<tr class="separator:a08a2361a1d5afd5ab74680717331a539 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb72aeba9f99b524217333ffcdc73054 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="aeb72aeba9f99b524217333ffcdc73054" name="aeb72aeba9f99b524217333ffcdc73054"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeConstraintsFromScene</b> ()</td></tr>
<tr class="separator:aeb72aeba9f99b524217333ffcdc73054 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b932ba94fcb7896f72b05545e88a66 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="ae8b932ba94fcb7896f72b05545e88a66" name="ae8b932ba94fcb7896f72b05545e88a66"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>addConstraintsToScene</b> ()</td></tr>
<tr class="separator:ae8b932ba94fcb7896f72b05545e88a66 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5a4b5b8171731d86c53876e6112534 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a8a5a4b5b8171731d86c53876e6112534" name="a8a5a4b5b8171731d86c53876e6112534"></a>
PxU32&#160;</td><td class="memItemRight" valign="bottom"><b>findConnector</b> (NpConnectorType::Enum type, <a class="el" href="classphysx_1_1_px_base.html">PxBase</a> *object) const</td></tr>
<tr class="separator:a8a5a4b5b8171731d86c53876e6112534 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c61fb5cf5277f29049ed5b5b1b56161 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a4c61fb5cf5277f29049ed5b5b1b56161" name="a4c61fb5cf5277f29049ed5b5b1b56161"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addConnector</b> (NpConnectorType::Enum type, <a class="el" href="classphysx_1_1_px_base.html">PxBase</a> *object, const char *errMsg)</td></tr>
<tr class="separator:a4c61fb5cf5277f29049ed5b5b1b56161 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f67020a66554b4e8a0679a7c0bc6b46 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a7f67020a66554b4e8a0679a7c0bc6b46" name="a7f67020a66554b4e8a0679a7c0bc6b46"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeConnector</b> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;owner, NpConnectorType::Enum type, <a class="el" href="classphysx_1_1_px_base.html">PxBase</a> *object, const char *errorMsg)</td></tr>
<tr class="separator:a7f67020a66554b4e8a0679a7c0bc6b46 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db6263da431548582eee69edec440a9 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a7db6263da431548582eee69edec440a9" name="a7db6263da431548582eee69edec440a9"></a>
PxU32&#160;</td><td class="memItemRight" valign="bottom"><b>getNbConnectors</b> (NpConnectorType::Enum type) const</td></tr>
<tr class="separator:a7db6263da431548582eee69edec440a9 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0595e39187af7c68190ab2b894ce36f9 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a0595e39187af7c68190ab2b894ce36f9" name="a0595e39187af7c68190ab2b894ce36f9"></a>
const <a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getPxActor</b> () const</td></tr>
<tr class="separator:a0595e39187af7c68190ab2b894ce36f9 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a2c486f97218aeb923f0b9952fd2dd inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a53a2c486f97218aeb923f0b9952fd2dd" name="a53a2c486f97218aeb923f0b9952fd2dd"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_np_connector_iterator.html">NpConnectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getConnectorIterator</b> (NpConnectorType::Enum type)</td></tr>
<tr class="separator:a53a2c486f97218aeb923f0b9952fd2dd inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e798b8d0d70fc39d2b95564186f5139 inherit pub_methods_classphysx_1_1_np_actor"><td class="memTemplParams" colspan="2"><a id="a5e798b8d0d70fc39d2b95564186f5139" name="a5e798b8d0d70fc39d2b95564186f5139"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e798b8d0d70fc39d2b95564186f5139 inherit pub_methods_classphysx_1_1_np_actor"><td class="memTemplItemLeft" align="right" valign="top">PxU32&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getConnectors</b> (NpConnectorType::Enum type, T **userBuffer, PxU32 bufferSize, PxU32 startIndex=0) const</td></tr>
<tr class="separator:a5e798b8d0d70fc39d2b95564186f5139 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa701c17edbc80dd476448e9c23461e inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a4fa701c17edbc80dd476448e9c23461e" name="a4fa701c17edbc80dd476448e9c23461e"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> <a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getActorFlags</b> () const</td></tr>
<tr class="separator:a4fa701c17edbc80dd476448e9c23461e inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8294a2e21a87504cb61d01ed6741259d inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a8294a2e21a87504cb61d01ed6741259d" name="a8294a2e21a87504cb61d01ed6741259d"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> <a class="el" href="namespacephysx.html#a85b58455ad586b4c81c2d3f79d026f1e">PxDominanceGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getDominanceGroup</b> () const</td></tr>
<tr class="separator:a8294a2e21a87504cb61d01ed6741259d inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba524333400c0e387077b6f902a24b5a inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="aba524333400c0e387077b6f902a24b5a" name="aba524333400c0e387077b6f902a24b5a"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> <a class="el" href="namespacephysx.html#a848d3308f61402014c20104cfa3e6cc7">PxClientID</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getOwnerClient</b> () const</td></tr>
<tr class="separator:aba524333400c0e387077b6f902a24b5a inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402dbbce8399f0aaa38d13a4d1999edb inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a402dbbce8399f0aaa38d13a4d1999edb" name="a402dbbce8399f0aaa38d13a4d1999edb"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>scSetActorFlags</b> (<a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a> v)</td></tr>
<tr class="separator:a402dbbce8399f0aaa38d13a4d1999edb inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a862327f1743c4574f3287f7c074743 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a6a862327f1743c4574f3287f7c074743" name="a6a862327f1743c4574f3287f7c074743"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> const <a class="el" href="classphysx_1_1_sc_1_1_actor_core.html">Sc::ActorCore</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getActorCore</b> () const</td></tr>
<tr class="separator:a6a862327f1743c4574f3287f7c074743 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8929a298f63c7d8825a2a2bdd1b35de1 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a8929a298f63c7d8825a2a2bdd1b35de1" name="a8929a298f63c7d8825a2a2bdd1b35de1"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_sc_1_1_actor_core.html">Sc::ActorCore</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getActorCore</b> ()</td></tr>
<tr class="separator:a8929a298f63c7d8825a2a2bdd1b35de1 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d75d6761f276cc7a2c5208f7bef890 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a40d75d6761f276cc7a2c5208f7bef890" name="a40d75d6761f276cc7a2c5208f7bef890"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> const <a class="el" href="classphysx_1_1_sc_1_1_rigid_core.html">Sc::RigidCore</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getScRigidCore</b> () const</td></tr>
<tr class="separator:a40d75d6761f276cc7a2c5208f7bef890 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9495e5a43823ec428125fefcf8293dd3 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a9495e5a43823ec428125fefcf8293dd3" name="a9495e5a43823ec428125fefcf8293dd3"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> <a class="el" href="classphysx_1_1_sc_1_1_rigid_core.html">Sc::RigidCore</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getScRigidCore</b> ()</td></tr>
<tr class="separator:a9495e5a43823ec428125fefcf8293dd3 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199acfbdf9f18c840b348b07e57cff84 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a199acfbdf9f18c840b348b07e57cff84" name="a199acfbdf9f18c840b348b07e57cff84"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>scSwitchToNoSim</b> ()</td></tr>
<tr class="separator:a199acfbdf9f18c840b348b07e57cff84 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da93a485d2fcaa1636b5d4165b52a33 inherit pub_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a4da93a485d2fcaa1636b5d4165b52a33" name="a4da93a485d2fcaa1636b5d4165b52a33"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>scSwitchFromNoSim</b> ()</td></tr>
<tr class="separator:a4da93a485d2fcaa1636b5d4165b52a33 inherit pub_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_np_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_np_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_np_base.html">physx::NpBase</a></td></tr>
<tr class="memitem:afce03c7fb222fb777ebf58f0e6bc082e inherit pub_methods_classphysx_1_1_np_base"><td class="memItemLeft" align="right" valign="top"><a id="afce03c7fb222fb777ebf58f0e6bc082e" name="afce03c7fb222fb777ebf58f0e6bc082e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NpBase</b> (const <a class="el" href="namespacephysx.html#ac0b3747190a9156618f0aed307778eda">PxEMPTY</a>)</td></tr>
<tr class="separator:afce03c7fb222fb777ebf58f0e6bc082e inherit pub_methods_classphysx_1_1_np_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c08cffce05e0399d7c3fbe7cf488a2d inherit pub_methods_classphysx_1_1_np_base"><td class="memItemLeft" align="right" valign="top"><a id="a5c08cffce05e0399d7c3fbe7cf488a2d" name="a5c08cffce05e0399d7c3fbe7cf488a2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NpBase</b> (NpType::Enum type)</td></tr>
<tr class="separator:a5c08cffce05e0399d7c3fbe7cf488a2d inherit pub_methods_classphysx_1_1_np_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ec0a76aa321245028b19de4c461beb inherit pub_methods_classphysx_1_1_np_base"><td class="memItemLeft" align="right" valign="top"><a id="a99ec0a76aa321245028b19de4c461beb" name="a99ec0a76aa321245028b19de4c461beb"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAPIWriteForbidden</b> () const</td></tr>
<tr class="separator:a99ec0a76aa321245028b19de4c461beb inherit pub_methods_classphysx_1_1_np_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c6b90fb0685223e3f9cecfbf8b3e46 inherit pub_methods_classphysx_1_1_np_base"><td class="memItemLeft" align="right" valign="top"><a id="af8c6b90fb0685223e3f9cecfbf8b3e46" name="af8c6b90fb0685223e3f9cecfbf8b3e46"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><b>isAPIWriteForbiddenExceptSplitSim</b> () const</td></tr>
<tr class="separator:af8c6b90fb0685223e3f9cecfbf8b3e46 inherit pub_methods_classphysx_1_1_np_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17ba227943fe924e9843096f025b8fa inherit pub_methods_classphysx_1_1_np_base"><td class="memItemLeft" align="right" valign="top"><a id="aa17ba227943fe924e9843096f025b8fa" name="aa17ba227943fe924e9843096f025b8fa"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> NpType::Enum&#160;</td><td class="memItemRight" valign="bottom"><b>getNpType</b> () const</td></tr>
<tr class="separator:aa17ba227943fe924e9843096f025b8fa inherit pub_methods_classphysx_1_1_np_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c41a2aa7d2139287c40a998f40b2e2 inherit pub_methods_classphysx_1_1_np_base"><td class="memItemLeft" align="right" valign="top"><a id="a18c41a2aa7d2139287c40a998f40b2e2" name="a18c41a2aa7d2139287c40a998f40b2e2"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setNpScene</b> (<a class="el" href="classphysx_1_1_np_scene.html">NpScene</a> *scene)</td></tr>
<tr class="separator:a18c41a2aa7d2139287c40a998f40b2e2 inherit pub_methods_classphysx_1_1_np_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db6006a8fa334785559f4840bb73bcf inherit pub_methods_classphysx_1_1_np_base"><td class="memItemLeft" align="right" valign="top"><a id="a3db6006a8fa334785559f4840bb73bcf" name="a3db6006a8fa334785559f4840bb73bcf"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> <a class="el" href="classphysx_1_1_np_scene.html">NpScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getNpScene</b> () const</td></tr>
<tr class="separator:a3db6006a8fa334785559f4840bb73bcf inherit pub_methods_classphysx_1_1_np_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa1cbf5fd086b3ca67342127e7ae1e4 inherit pub_methods_classphysx_1_1_np_base"><td class="memItemLeft" align="right" valign="top"><a id="a9fa1cbf5fd086b3ca67342127e7ae1e4" name="a9fa1cbf5fd086b3ca67342127e7ae1e4"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> PxU32&#160;</td><td class="memItemRight" valign="bottom"><b>getBaseIndex</b> () const</td></tr>
<tr class="separator:a9fa1cbf5fd086b3ca67342127e7ae1e4 inherit pub_methods_classphysx_1_1_np_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48da1248f0bda175f90fd63c39b72d7b inherit pub_methods_classphysx_1_1_np_base"><td class="memItemLeft" align="right" valign="top"><a id="a48da1248f0bda175f90fd63c39b72d7b" name="a48da1248f0bda175f90fd63c39b72d7b"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setBaseIndex</b> (PxU32 index)</td></tr>
<tr class="separator:a48da1248f0bda175f90fd63c39b72d7b inherit pub_methods_classphysx_1_1_np_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classphysx_1_1_px_user_allocated"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classphysx_1_1_px_user_allocated')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classphysx_1_1_px_user_allocated.html">physx::PxUserAllocated</a></td></tr>
<tr class="memitem:ac6a9a67e2851ca793aab3e5cd5d40dc9 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="ac6a9a67e2851ca793aab3e5cd5d40dc9" name="ac6a9a67e2851ca793aab3e5cd5d40dc9"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t, void *address)</td></tr>
<tr class="separator:ac6a9a67e2851ca793aab3e5cd5d40dc9 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046ea5070dbf9afdd2a7861e92e94d81 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="a046ea5070dbf9afdd2a7861e92e94d81" name="a046ea5070dbf9afdd2a7861e92e94d81"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *, void *)</td></tr>
<tr class="separator:a046ea5070dbf9afdd2a7861e92e94d81 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bae0296ddfbc31b60216e2ba92abd2 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="ae4bae0296ddfbc31b60216e2ba92abd2" name="ae4bae0296ddfbc31b60216e2ba92abd2"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:ae4bae0296ddfbc31b60216e2ba92abd2 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new</b> (size_t size, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:ae4bae0296ddfbc31b60216e2ba92abd2 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a10b191838ea8c32665b016efdc8f3 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="a63a10b191838ea8c32665b016efdc8f3" name="a63a10b191838ea8c32665b016efdc8f3"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a63a10b191838ea8c32665b016efdc8f3 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new</b> (size_t size, size_t, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:a63a10b191838ea8c32665b016efdc8f3 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5b943c992e48740700b211db97c551 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="aba5b943c992e48740700b211db97c551" name="aba5b943c992e48740700b211db97c551"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:aba5b943c992e48740700b211db97c551 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new[]</b> (size_t size, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:aba5b943c992e48740700b211db97c551 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290c0241798e99dd5aa3268ab4409e5d inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="a290c0241798e99dd5aa3268ab4409e5d" name="a290c0241798e99dd5aa3268ab4409e5d"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a290c0241798e99dd5aa3268ab4409e5d inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator new[]</b> (size_t size, size_t, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:a290c0241798e99dd5aa3268ab4409e5d inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75170caed9ba30211dac6786a2bd6a0b inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="a75170caed9ba30211dac6786a2bd6a0b" name="a75170caed9ba30211dac6786a2bd6a0b"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a75170caed9ba30211dac6786a2bd6a0b inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator delete</b> (void *ptr, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:a75170caed9ba30211dac6786a2bd6a0b inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac388e14397c75698987292f6e366603e inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplParams" colspan="2"><a id="ac388e14397c75698987292f6e366603e" name="ac388e14397c75698987292f6e366603e"></a>
template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:ac388e14397c75698987292f6e366603e inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr, Alloc alloc, const char *fileName, int line)</td></tr>
<tr class="separator:ac388e14397c75698987292f6e366603e inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f3a3f96013ef224beb23fbdc73d758 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="a14f3a3f96013ef224beb23fbdc73d758" name="a14f3a3f96013ef224beb23fbdc73d758"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *ptr)</td></tr>
<tr class="separator:a14f3a3f96013ef224beb23fbdc73d758 inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec6f784dc7cbe8d3542f22e8c5ec3fa inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memItemLeft" align="right" valign="top"><a id="a5ec6f784dc7cbe8d3542f22e8c5ec3fa" name="a5ec6f784dc7cbe8d3542f22e8c5ec3fa"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *ptr)</td></tr>
<tr class="separator:a5ec6f784dc7cbe8d3542f22e8c5ec3fa inherit pub_methods_classphysx_1_1_px_user_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8c14ac56babddcbed4f2e7bc6782e8a2"><td class="memItemLeft" align="right" valign="top"><a id="a8c14ac56babddcbed4f2e7bc6782e8a2" name="a8c14ac56babddcbed4f2e7bc6782e8a2"></a>
static <a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getCoreOffset</b> ()</td></tr>
<tr class="separator:a8c14ac56babddcbed4f2e7bc6782e8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classphysx_1_1_np_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classphysx_1_1_np_actor')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classphysx_1_1_np_actor.html">physx::NpActor</a></td></tr>
<tr class="memitem:a4d0e84a6117b868a3e9d657f3b36e423 inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a4d0e84a6117b868a3e9d657f3b36e423" name="a4d0e84a6117b868a3e9d657f3b36e423"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>getBinaryMetaData</b> (<a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream)</td></tr>
<tr class="separator:a4d0e84a6117b868a3e9d657f3b36e423 inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8e2fabe629e344ffdae4a38907f4db inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="acc8e2fabe629e344ffdae4a38907f4db" name="acc8e2fabe629e344ffdae4a38907f4db"></a>
static <a class="el" href="classphysx_1_1_np_shape_manager.html">NpShapeManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getShapeManager_</b> (<a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> &amp;actor)</td></tr>
<tr class="separator:acc8e2fabe629e344ffdae4a38907f4db inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81edb6889d4ee3221379126d79cac7fd inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a81edb6889d4ee3221379126d79cac7fd" name="a81edb6889d4ee3221379126d79cac7fd"></a>
static const <a class="el" href="classphysx_1_1_np_shape_manager.html">NpShapeManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getShapeManager_</b> (const <a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> &amp;actor)</td></tr>
<tr class="separator:a81edb6889d4ee3221379126d79cac7fd inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cea0d1c2b2cad9401ef2d6791a715b inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="aa2cea0d1c2b2cad9401ef2d6791a715b" name="aa2cea0d1c2b2cad9401ef2d6791a715b"></a>
static <a class="el" href="classphysx_1_1_np_actor.html">NpActor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getFromPxActor</b> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;actor)</td></tr>
<tr class="separator:aa2cea0d1c2b2cad9401ef2d6791a715b inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa354ceef92f1c51a5e10987fb433a718 inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="aa354ceef92f1c51a5e10987fb433a718" name="aa354ceef92f1c51a5e10987fb433a718"></a>
static const <a class="el" href="classphysx_1_1_np_actor.html">NpActor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getFromPxActor</b> (const <a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;actor)</td></tr>
<tr class="separator:aa354ceef92f1c51a5e10987fb433a718 inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757c36fb299f5f736fa9231a5b720d9e inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a757c36fb299f5f736fa9231a5b720d9e" name="a757c36fb299f5f736fa9231a5b720d9e"></a>
static <a class="el" href="classphysx_1_1_np_scene.html">NpScene</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getNpSceneFromActor</b> (const <a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> &amp;actor)</td></tr>
<tr class="separator:a757c36fb299f5f736fa9231a5b720d9e inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3812b598620d6fd4f60cfdc464fb240 inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="ae3812b598620d6fd4f60cfdc464fb240" name="ae3812b598620d6fd4f60cfdc464fb240"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>onActorRelease</b> (<a class="el" href="classphysx_1_1_px_actor.html">PxActor</a> *actor)</td></tr>
<tr class="separator:ae3812b598620d6fd4f60cfdc464fb240 inherit pub_static_methods_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classphysx_1_1_np_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classphysx_1_1_np_base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classphysx_1_1_np_base.html">physx::NpBase</a></td></tr>
<tr class="memitem:a28123443a33eea978564a8951572006e inherit pub_static_methods_classphysx_1_1_np_base"><td class="memItemLeft" align="right" valign="top"><a id="a28123443a33eea978564a8951572006e" name="a28123443a33eea978564a8951572006e"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>getBinaryMetaData</b> (<a class="el" href="classphysx_1_1_px_output_stream.html">PxOutputStream</a> &amp;stream)</td></tr>
<tr class="separator:a28123443a33eea978564a8951572006e inherit pub_static_methods_classphysx_1_1_np_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classphysx_1_1_px_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classphysx_1_1_px_actor')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classphysx_1_1_px_actor.html">physx::PxActor</a></td></tr>
<tr class="memitem:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="a85d97eb04de762d740345cc469824b6f" name="a85d97eb04de762d740345cc469824b6f"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>userData</b></td></tr>
<tr class="memdesc:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">user can assign this to whatever, usually to create a 1:1 relationship with a user object. <br /></td></tr>
<tr class="separator:a85d97eb04de762d740345cc469824b6f inherit pub_attribs_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classphysx_1_1_np_actor"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classphysx_1_1_np_actor')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classphysx_1_1_np_actor.html">physx::NpActor</a></td></tr>
<tr class="memitem:acb4adf88f466733ff4cabb9cc1a47159 inherit pub_static_attribs_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="acb4adf88f466733ff4cabb9cc1a47159" name="acb4adf88f466733ff4cabb9cc1a47159"></a>
static const Offsets&#160;</td><td class="memItemRight" valign="bottom"><b>sOffsets</b></td></tr>
<tr class="separator:acb4adf88f466733ff4cabb9cc1a47159 inherit pub_static_attribs_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b9f6d8500c9db9d68a8ff3bf3ae4cb inherit pub_static_attribs_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a65b9f6d8500c9db9d68a8ff3bf3ae4cb" name="a65b9f6d8500c9db9d68a8ff3bf3ae4cb"></a>
static const <a class="el" href="structphysx_1_1_np_actor_1_1_np_offsets.html">NpOffsets</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sNpOffsets</b></td></tr>
<tr class="separator:a65b9f6d8500c9db9d68a8ff3bf3ae4cb inherit pub_static_attribs_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_np_actor_template"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_np_actor_template')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_np_actor_template.html">physx::NpActorTemplate&lt; PxSoftBody &gt;</a></td></tr>
<tr class="memitem:a4f07163ce172eab6605005d228225b5f inherit pro_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top"><a id="a4f07163ce172eab6605005d228225b5f" name="a4f07163ce172eab6605005d228225b5f"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setActorFlagInternal</b> (<a class="el" href="structphysx_1_1_px_actor_flag.html#a123559ef67fcc063d513f580fcfd02b8">PxActorFlag::Enum</a> flag, bool value)</td></tr>
<tr class="separator:a4f07163ce172eab6605005d228225b5f inherit pro_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad254ffa962f89d85376e01db49e1424b inherit pro_methods_classphysx_1_1_np_actor_template"><td class="memItemLeft" align="right" valign="top"><a id="ad254ffa962f89d85376e01db49e1424b" name="ad254ffa962f89d85376e01db49e1424b"></a>
<a class="el" href="group__foundation.html#ga6a774eed3cad34b0f636332a3d28c6bb">PX_FORCE_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>setActorFlagsInternal</b> (<a class="el" href="namespacephysx.html#ab50c563b8069a2b8ace391a0d18b6563">PxActorFlags</a> inFlags)</td></tr>
<tr class="separator:ad254ffa962f89d85376e01db49e1424b inherit pro_methods_classphysx_1_1_np_actor_template"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_soft_body"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_soft_body')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_soft_body.html">physx::PxSoftBody</a></td></tr>
<tr class="memitem:a6c6716eec721065ea5ac640f850eafa5 inherit pro_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top"><a id="a6c6716eec721065ea5ac640f850eafa5" name="a6c6716eec721065ea5ac640f850eafa5"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxSoftBody</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a6c6716eec721065ea5ac640f850eafa5 inherit pro_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05e4f32c556aa6bacfbd1ea9bac2c96 inherit pro_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top"><a id="af05e4f32c556aa6bacfbd1ea9bac2c96" name="af05e4f32c556aa6bacfbd1ea9bac2c96"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxSoftBody</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:af05e4f32c556aa6bacfbd1ea9bac2c96 inherit pro_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2829fb17dad1d3e808e74db36006c5 inherit pro_methods_classphysx_1_1_px_soft_body"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_soft_body.html#ace2829fb17dad1d3e808e74db36006c5">isKindOf</a> (const char *name) const <a class="el" href="group__foundation.html#ga7f84f0458b75adc8c2f2a164fdb6fb0d">PX_OVERRIDE</a></td></tr>
<tr class="memdesc:ace2829fb17dad1d3e808e74db36006c5 inherit pro_methods_classphysx_1_1_px_soft_body"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:ace2829fb17dad1d3e808e74db36006c5 inherit pro_methods_classphysx_1_1_px_soft_body"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_actor"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_actor')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_actor.html">physx::PxActor</a></td></tr>
<tr class="memitem:a38b030b8d43f75ca6a0011d369369fdf inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="a38b030b8d43f75ca6a0011d369369fdf" name="a38b030b8d43f75ca6a0011d369369fdf"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxActor</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:a38b030b8d43f75ca6a0011d369369fdf inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d98db236080d8bdb8f7dd179d84bde inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top"><a id="ad8d98db236080d8bdb8f7dd179d84bde" name="ad8d98db236080d8bdb8f7dd179d84bde"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxActor</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="separator:ad8d98db236080d8bdb8f7dd179d84bde inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_actor.html#a538ec41302af60afec0df10f31f4ab24">isKindOf</a> (const char *name) const</td></tr>
<tr class="memdesc:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:a538ec41302af60afec0df10f31f4ab24 inherit pro_methods_classphysx_1_1_px_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a92f28ef9d2c863db69d316e68375fac5" name="a92f28ef9d2c863db69d316e68375fac5"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxBase</b> (PxType concreteType, <a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor setting concrete type and base flags. <br /></td></tr>
<tr class="separator:a92f28ef9d2c863db69d316e68375fac5 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a4f41a74f151437e79ea1fb075df19cbc" name="a4f41a74f151437e79ea1fb075df19cbc"></a>
<a class="el" href="group__foundation.html#gacb03347b642a2a5bdea1f9b305a6fbec">PX_INLINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PxBase</b> (<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a> baseFlags)</td></tr>
<tr class="memdesc:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialization constructor setting base flags. <br /></td></tr>
<tr class="separator:a4f41a74f151437e79ea1fb075df19cbc inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="adcee0bb92feaaaaeb2340d7304af1830" name="adcee0bb92feaaaaeb2340d7304af1830"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PxBase</b> ()</td></tr>
<tr class="memdesc:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:adcee0bb92feaaaaeb2340d7304af1830 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classphysx_1_1_px_base.html#a8645a6d66bcc1df05a82bf3be518cb55">isKindOf</a> (const char *superClass) const</td></tr>
<tr class="memdesc:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a given type name matches with the type of this instance.  <br /></td></tr>
<tr class="separator:a8645a6d66bcc1df05a82bf3be518cb55 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memTemplParams" colspan="2"><a id="abcfbbbce797c885d67969f6c5b975601" name="abcfbbbce797c885d67969f6c5b975601"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>typeMatch</b> () const</td></tr>
<tr class="separator:abcfbbbce797c885d67969f6c5b975601 inherit pro_methods_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classphysx_1_1_px_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classphysx_1_1_px_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classphysx_1_1_px_base.html">physx::PxBase</a></td></tr>
<tr class="memitem:ad6a3f9870b95cebff97107058729852a inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="ad6a3f9870b95cebff97107058729852a" name="ad6a3f9870b95cebff97107058729852a"></a>
PxType&#160;</td><td class="memItemRight" valign="bottom"><b>mConcreteType</b></td></tr>
<tr class="separator:ad6a3f9870b95cebff97107058729852a inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24687e4fc96f1902f53cd4e0444c4482 inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a24687e4fc96f1902f53cd4e0444c4482" name="a24687e4fc96f1902f53cd4e0444c4482"></a>
<a class="el" href="classphysx_1_1_px_flags.html">PxBaseFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mBaseFlags</b></td></tr>
<tr class="separator:a24687e4fc96f1902f53cd4e0444c4482 inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e247c6b6559031c784449e79396af0 inherit pro_attribs_classphysx_1_1_px_base"><td class="memItemLeft" align="right" valign="top"><a id="a67e247c6b6559031c784449e79396af0" name="a67e247c6b6559031c784449e79396af0"></a>
PxU32&#160;</td><td class="memItemRight" valign="bottom"><b>mBuiltInRefCount</b></td></tr>
<tr class="separator:a67e247c6b6559031c784449e79396af0 inherit pro_attribs_classphysx_1_1_px_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classphysx_1_1_np_actor"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classphysx_1_1_np_actor')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classphysx_1_1_np_actor.html">physx::NpActor</a></td></tr>
<tr class="memitem:ae47be0e379eed65e8f9cc2a5c47832a0 inherit pro_attribs_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="ae47be0e379eed65e8f9cc2a5c47832a0" name="ae47be0e379eed65e8f9cc2a5c47832a0"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>mName</b></td></tr>
<tr class="separator:ae47be0e379eed65e8f9cc2a5c47832a0 inherit pro_attribs_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2773cd855cc917f50f6415173dc93f inherit pro_attribs_classphysx_1_1_np_actor"><td class="memItemLeft" align="right" valign="top"><a id="a7e2773cd855cc917f50f6415173dc93f" name="a7e2773cd855cc917f50f6415173dc93f"></a>
<a class="el" href="classphysx_1_1_np_connector_array.html">NpConnectorArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>mConnectorArray</b></td></tr>
<tr class="separator:a7e2773cd855cc917f50f6415173dc93f inherit pro_attribs_classphysx_1_1_np_actor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classphysx_1_1_np_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classphysx_1_1_np_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classphysx_1_1_np_base.html">physx::NpBase</a></td></tr>
<tr class="memitem:a78f30f5f4ac4022004a23e565dd7eb95 inherit pro_attribs_classphysx_1_1_np_base"><td class="memItemLeft" align="right" valign="top"><a id="a78f30f5f4ac4022004a23e565dd7eb95" name="a78f30f5f4ac4022004a23e565dd7eb95"></a>
PxU32&#160;</td><td class="memItemRight" valign="bottom"><b>mFreeSlot</b></td></tr>
<tr class="separator:a78f30f5f4ac4022004a23e565dd7eb95 inherit pro_attribs_classphysx_1_1_np_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5fa10948aeb97d5cb89f16e10ef919ba" name="a5fa10948aeb97d5cb89f16e10ef919ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa10948aeb97d5cb89f16e10ef919ba">&#9670;&#160;</a></span>addClothAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::NpSoftBody::addClothAttachment </td>
          <td>(</td>
          <td class="paramtype">PxFEMCloth *&#160;</td>
          <td class="paramname"><em>cloth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>triIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>triBarycentric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>tetBarycentric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an attachment between a soft body and a cloth. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the cloth does not. </p>
<p>This method attaches a point inside a tetrahedron of the collision mesh to a cloth.</p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloth</td><td>The cloth actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triIdx</td><td>The index of a triangle in the cloth mesh that contains the point to be attached to the soft body </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triBarycentric</td><td>The barycentric coordinates of the attachment point inside the triangle specified by triangleIdx </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of a tetrahedron in the softbody's collision mesh that contains the point to be attached to the cloth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetBarycentric</td><td>The barycentric coordinates of the attachment point inside the tetrahedron specified by tetIdx </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The user defined cone distance limit constraint to limit the movement between a triangle in the fem cloth and a tet in the soft body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to release the attachment later </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#abbb8c9c3b1a546dcc8b5ed73d854da21">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a7ae67852881f9d50ea2b8c84938c1c5a" name="a7ae67852881f9d50ea2b8c84938c1c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae67852881f9d50ea2b8c84938c1c5a">&#9670;&#160;</a></span>addClothFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::addClothFilter </td>
          <td>(</td>
          <td class="paramtype">PxFEMCloth *&#160;</td>
          <td class="paramname"><em>cloth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>triIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates collision filter between a tetrahedron in a soft body and a triangle in a cloth. </p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloth</td><td>The cloth actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triIdx</td><td>The index of the triangle in the cloth mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of the tetrahedron in the softbody's collision mesh to be filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#af1da16afabd826cc9db106f1749edbd4">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a005fce4e8c69d42ed397b063136565c9" name="a005fce4e8c69d42ed397b063136565c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005fce4e8c69d42ed397b063136565c9">&#9670;&#160;</a></span>addParticleAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::NpSoftBody::addParticleAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>particleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>barycentric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The <a class="el" href="classphysx_1_1_px_particle_buffer.html" title="The shared base class for all particle buffers, can be instantiated directly to simulate granular and...">PxParticleBuffer</a> to which the particle belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">particleId</td><td>The particle that is attached to a tetrahedron in the soft body's collision mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetId</td><td>The tetrahedron in the soft body's collision mesh to attach the particle to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barycentric</td><td>The barycentric coordinates of the particle attachment position with respect to the tetrahedron specified with tetId. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to release the attachment later </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#aaaeaf25e7ea0ff2976a0cb39e20cff26">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="ad2dc4681d8b7f45784e662dd65dbb83e" name="ad2dc4681d8b7f45784e662dd65dbb83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dc4681d8b7f45784e662dd65dbb83e">&#9670;&#160;</a></span>addParticleFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::addParticleFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>particleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a collision filter between a particle and a tetrahedron in the soft body's collision mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The <a class="el" href="classphysx_1_1_px_particle_buffer.html" title="The shared base class for all particle buffers, can be instantiated directly to simulate granular and...">PxParticleBuffer</a> to which the particle belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">particleId</td><td>The particle whose collisions with the tetrahedron in the soft body are filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetId</td><td>The tetradedron in the soft body that is filtered. If tetId is PX_MAX_TETID, this particle will filter against all tetrahedra in this soft body </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a7fe61c672f855820507b4ca39eaf44c3">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="af297b69811c935ac3a900befbd21638e" name="af297b69811c935ac3a900befbd21638e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af297b69811c935ac3a900befbd21638e">&#9670;&#160;</a></span>addRigidAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::NpSoftBody::addRigidAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>vertId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>actorSpacePose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not. </p>
<p>This method attaches a vertex on the soft body collision mesh to the rigid body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertId</td><td>The index of a vertex in the softbody's collision mesh that gets attached to the rigid body. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">actorSpacePose</td><td>The location of the attachment point expressed in the rigid body's coordinate system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The user defined cone distance limit constraint to limit the movement between a vertex in the soft body and rigid body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to relese the attachment later </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ab0df35db3b120d40bc457fe46edf1923">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a31d0c3c97e086b461900e79327bfc9c8" name="a31d0c3c97e086b461900e79327bfc9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d0c3c97e086b461900e79327bfc9c8">&#9670;&#160;</a></span>addRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::addRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>vertId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a collision filter between a vertex in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertId</td><td>The index of a vertex in the softbody's collision mesh whose collisions with the rigid body are filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a34d283966ec1724c1833be787bdc51ee">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a200f3a2ddb701be64fcdb981f1a9e1a2" name="a200f3a2ddb701be64fcdb981f1a9e1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200f3a2ddb701be64fcdb981f1a9e1a2">&#9670;&#160;</a></span>addSoftBodyAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::NpSoftBody::addSoftBodyAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>softbody0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>tetBarycentric0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>tetBarycentric1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an attachment between two soft bodies. </p>
<p>This method attaches a point inside a tetrahedron of the collision mesh to a point in another soft body's tetrahedron collision mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">softbody0</td><td>The soft body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx0</td><td>The index of a tetrahedron in the other soft body that contains the point to be attached to the soft body </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetBarycentric0</td><td>The barycentric coordinates of the attachment point inside the tetrahedron specified by tetIdx0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx1</td><td>The index of a tetrahedron in the softbody's collision mesh that contains the point to be attached to the softbody0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetBarycentric1</td><td>The barycentric coordinates of the attachment point inside the tetrahedron specified by tetIdx1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The user defined cone distance limit constraint to limit the movement between tets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to release the attachment later </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a29c6454c000cdf9b96e9ae58a826041f">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="aecc75faebd3eecc87040439f5d495309" name="aecc75faebd3eecc87040439f5d495309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc75faebd3eecc87040439f5d495309">&#9670;&#160;</a></span>addSoftBodyFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::addSoftBodyFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>otherTetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates collision filter between a tetrahedron in a soft body and a tetrahedron in another soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIdx</td><td>The index of the tetrahedron in the other softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx1</td><td>The index of the tetrahedron in the softbody's collision mesh to be filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ac51d32b513aea14f5f15c8e7982b5bf3">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a889850c0798dbd4145ad548745eee7e4" name="a889850c0798dbd4145ad548745eee7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889850c0798dbd4145ad548745eee7e4">&#9670;&#160;</a></span>addSoftBodyFilters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::addSoftBodyFilters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 *&#160;</td>
          <td class="paramname"><em>otherTetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 *&#160;</td>
          <td class="paramname"><em>tetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIndicesSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates collision filters between a tetrahedron in a soft body with another soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIndices</td><td>The indices of the tetrahedron in the other softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndices</td><td>The indices of the tetrahedron of the softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndicesSize</td><td>The size of tetIndices. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ae33c57f9d8f328b206398c3e8b551861">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a5dda681f24e37f9126dee9206c12a243" name="a5dda681f24e37f9126dee9206c12a243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dda681f24e37f9126dee9206c12a243">&#9670;&#160;</a></span>addTetRigidAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::NpSoftBody::addTetRigidAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec4_t.html">PxVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>barycentric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_vec3_t.html">PxVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>actorSpacePose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_cone_limited_constraint.html">PxConeLimitedConstraint</a> *&#160;</td>
          <td class="paramname"><em>constraint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not. </p>
<p>This method attaches a point inside a tetrahedron of the collision to the rigid body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of a tetrahedron in the softbody's collision mesh that contains the point to be attached to the rigid body </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">barycentric</td><td>The barycentric coordinates of the attachment point inside the tetrahedron specified by tetIdx </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">actorSpacePose</td><td>The location of the attachment point expressed in the rigid body's coordinate system. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The user defined cone distance limit constraint to limit the movement between a tet and rigid body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a handle that identifies the attachment created. This handle can be used to release the attachment later </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#abe4efd157fd4bceabee9d278c34dcda7">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a3ae9d773c4ef3ac8c86a67809718cbf6" name="a3ae9d773c4ef3ac8c86a67809718cbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae9d773c4ef3ac8c86a67809718cbf6">&#9670;&#160;</a></span>addTetRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::addTetRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates collision filter between a tetrahedron in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of a tetrahedron in the softbody's collision mesh whose collisions with the rigid body is filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a1223e4814b8b781fe274d549492cde9f">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="acdeda0387029495cbc11a6610e9d258d" name="acdeda0387029495cbc11a6610e9d258d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdeda0387029495cbc11a6610e9d258d">&#9670;&#160;</a></span>attachShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::NpSoftBody::attachShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a shape. </p>
<p>Attaches the shape to use for collision detection</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>The shape to use for collisions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the operation was successful </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#aa602720974de655d95049ac7dcee3c96">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="adcc86fb7943d50aae402c1001cb01842" name="adcc86fb7943d50aae402c1001cb01842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc86fb7943d50aae402c1001cb01842">&#9670;&#160;</a></span>attachSimulationMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::NpSoftBody::attachSimulationMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>simulationMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body_aux_data.html">PxSoftBodyAuxData</a> &amp;&#160;</td>
          <td class="paramname"><em>softBodyAuxData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a simulation mesh. </p>
<p>Attaches the simulation mesh (geometry) and a state containing inverse mass, rest pose etc. required to compute the softbody deformation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">simulationMesh</td><td>The tetrahedral mesh used to compute the softbody's deformation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">softBodyAuxData</td><td>A state that contain a mapping from simulation to collision mesh, volume information etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the operation was successful </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a1358e4fc28d149ee1287edebd4240afe">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a84b4237b5b7b860fba2bf3377f309f6f" name="a84b4237b5b7b860fba2bf3377f309f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b4237b5b7b860fba2bf3377f309f6f">&#9670;&#160;</a></span>detachShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::detachShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches the shape. </p>
<p>Detaches the shape used for collision detection.</p>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="classphysx_1_1_np_soft_body.html#a1b0bda2ef6e089cf443503077ae3d93a" title="Detaches the simulation mesh.">detachSimulationMesh()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a8e89cb3118981013838932b5328b2eb3">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a1b0bda2ef6e089cf443503077ae3d93a" name="a1b0bda2ef6e089cf443503077ae3d93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0bda2ef6e089cf443503077ae3d93a">&#9670;&#160;</a></span>detachSimulationMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::detachSimulationMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches the simulation mesh. </p>
<p>Detaches the simulation mesh and simulation state used to compute the softbody deformation.</p>
<dl class="section see"><dt>See also</dt><dd>void <a class="el" href="classphysx_1_1_np_soft_body.html#a84b4237b5b7b860fba2bf3377f309f6f" title="Detaches the shape.">detachShape()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a45855574b47484673ddbc1b7b919e499">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a0272d41af4b4adcee83cf12d4c4e2492" name="a0272d41af4b4adcee83cf12d4c4e2492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0272d41af4b4adcee83cf12d4c4e2492">&#9670;&#160;</a></span>getCollisionMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> * physx::NpSoftBody::getCollisionMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the collision mesh pointer. </p>
<p>Allows to access the geometry of the tetrahedral mesh used to perform collision detection</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the collision mesh </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a9c0473f9bb9b0e36c07c2754e001a22d">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a8144bfdbad7d4dce5d1c674d35fb0fc2" name="a8144bfdbad7d4dce5d1c674d35fb0fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8144bfdbad7d4dce5d1c674d35fb0fc2">&#9670;&#160;</a></span>getCudaContextManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxCudaContextManager * physx::NpSoftBody::getCudaContextManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cuda context manager. </p>
<dl class="section return"><dt>Returns</dt><dd>The cuda context manager </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a8418698e3c39c87b07946a7f81cf2b23">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="aa845d3794994188a5dbf3b6a8ec6d2f3" name="aa845d3794994188a5dbf3b6a8ec6d2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa845d3794994188a5dbf3b6a8ec6d2f3">&#9670;&#160;</a></span>getGpuSoftBodyIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxU32 physx::NpSoftBody::getGpuSoftBodyIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the GPU soft body index. </p>
<dl class="section return"><dt>Returns</dt><dd>The GPU index, or 0xFFFFFFFF if the soft body is not in a scene. </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a3867e1e682567681e73ee0f68828069c">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a470ac75a2de4ce6d2d9508ac16389c8e" name="a470ac75a2de4ce6d2d9508ac16389c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470ac75a2de4ce6d2d9508ac16389c8e">&#9670;&#160;</a></span>getKinematicTargetCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> * physx::NpSoftBody::getKinematicTargetCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the vertices of the simulation mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass must match the inverse mass in the simVelocityCPU buffer at the same index. A copy of this value is stored in the simVelocityCPU buffer to allow for faster access on the GPU. If the inverse masses in those two buffers don't match, the simulation may produce wrong results</p>
<p>Allows to access the CPU buffer of the simulation mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the simulation mesh's vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#aa7b2dba42ea1ab7e59a27b30d4a7203b">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a45ba51d0ec2640598cc883d02575feae" name="a45ba51d0ec2640598cc883d02575feae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ba51d0ec2640598cc883d02575feae">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * physx::NpSoftBody::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the name string set with <a class="el" href="classphysx_1_1_np_soft_body.html#a8c88cf7b477783f4a3e5555b6d30eaf1" title="Sets a name string for the object that can be retrieved with getName().">setName()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Name string associated with object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#a8c88cf7b477783f4a3e5555b6d30eaf1" title="Sets a name string for the object that can be retrieved with getName().">setName()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classphysx_1_1_np_actor_template.html">physx::NpActorTemplate&lt; PxSoftBody &gt;</a>.</p>

</div>
</div>
<a id="a25244c54cd78fc7f657623a9616b588a" name="a25244c54cd78fc7f657623a9616b588a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25244c54cd78fc7f657623a9616b588a">&#9670;&#160;</a></span>getParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structphysx_1_1_px_f_e_m_parameters.html">PxFEMParameters</a> physx::NpSoftBody::getParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get parameter for FEM internal solve. </p>
<dl class="section return"><dt>Returns</dt><dd>The FEM parameters </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ae482aec041036f6187163848d1b8aaf0">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="af781f6fcb1a3195826035444421cd3c8" name="af781f6fcb1a3195826035444421cd3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af781f6fcb1a3195826035444421cd3c8">&#9670;&#160;</a></span>getPositionInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> * physx::NpSoftBody::getPositionInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the vertices of the collision mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass on the collision mesh has no effect, it can be set to an arbitrary value.</p>
<p>Allows to access the CPU buffer of the collision mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the collision mesh's vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a4cea5ff304ad2d73c3e71147613e818f">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="ab85b9bd9c8d46799d5c1781dcb2c7666" name="ab85b9bd9c8d46799d5c1781dcb2c7666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85b9bd9c8d46799d5c1781dcb2c7666">&#9670;&#160;</a></span>getRestPositionInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> * physx::NpSoftBody::getRestPositionInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the rest vertices of the collision mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass on the collision mesh has no effect, it can be set to an arbitrary value.</p>
<p>Allows to access the CPU buffer of the collision mesh's rest vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the collision mesh's rest vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#aed600012be729205b6a2ce757199a9e1">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a7460e06efc162477757e1db9cfc898a2" name="a7460e06efc162477757e1db9cfc898a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7460e06efc162477757e1db9cfc898a2">&#9670;&#160;</a></span>getShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_shape.html">PxShape</a> * physx::NpSoftBody::getShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the shape pointer belonging to the actor. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the collision mesh's shape </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_shape.html" title="Abstract class for collision shapes.">PxShape</a> getNbShapes() <a class="el" href="classphysx_1_1_px_shape.html#af21c5392d4e2ead73034c1d838cfe48e" title="Decrements the reference count of a shape and releases it if the new reference count is zero.">PxShape::release()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a85e7f27f4209373f2dcce01448faa906">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a16046224da390bf20d6ab5dcce6da341" name="a16046224da390bf20d6ab5dcce6da341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16046224da390bf20d6ab5dcce6da341">&#9670;&#160;</a></span>getSimPositionInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> * physx::NpSoftBody::getSimPositionInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the vertices of the simulation mesh on the host. </p>
<p>Each element uses 4 float values containing position and inverseMass per vertex [x, y, z, inverseMass] The inverse mass must match the inverse mass in the simVelocityCPU buffer at the same index. A copy of this value is stored in the simVelocityCPU buffer to allow for faster access on the GPU. If the inverse masses in those two buffers don't match, the simulation may produce wrong results</p>
<p>Allows to access the CPU buffer of the simulation mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the simulation mesh's vertex positions (x, y, z) and the inverse mass as 4th component </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#af13967dbaef4161b72e48f685c39b077">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="abe546777169959ae0a817f5263b8e723" name="abe546777169959ae0a817f5263b8e723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe546777169959ae0a817f5263b8e723">&#9670;&#160;</a></span>getSimulationMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_tetrahedron_mesh.html">PxTetrahedronMesh</a> * physx::NpSoftBody::getSimulationMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the simulation mesh pointer. </p>
<p>Allows to access the geometry of the tetrahedral mesh used to compute the object's deformation</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the simulation mesh </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ad2f670bd0d2719c737aa52f562bd1a31">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a2c507cfe064d0217afe06ee8fdbc094c" name="a2c507cfe064d0217afe06ee8fdbc094c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c507cfe064d0217afe06ee8fdbc094c">&#9670;&#160;</a></span>getSimVelocityInvMassCPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> * physx::NpSoftBody::getSimVelocityInvMassCPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the velocities of the simulation mesh on the host. </p>
<p>Each element uses 4 float values containing velocity and inverseMass per vertex [x, y, z, inverseMass] The inverse mass must match the inverse mass in the simPositionInvMassCPU buffer at the same index. A copy of this value is stored in the simPositionInvMassCPU buffer to allow for faster access on the GPU. If the inverse masses in those two buffers don't match, the simulation may produce wrong results</p>
<p>Allows to access the CPU buffer of the simulation mesh's vertices</p>
<dl class="section return"><dt>Returns</dt><dd>The buffer that contains the simulation mesh's velocities (x, y, z) and the inverse mass as 4th component </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ae9a56a2c3af0a2b35b10c054bef2baa7">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a8802c7d01c763ee631d102f313f4cf59" name="a8802c7d01c763ee631d102f313f4cf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8802c7d01c763ee631d102f313f4cf59">&#9670;&#160;</a></span>getSoftBodyAuxData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_soft_body_aux_data.html">PxSoftBodyAuxData</a> * physx::NpSoftBody::getSoftBodyAuxData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the simulation state pointer. </p>
<p>Allows to access the additional data of the simulation mesh (inverse mass, rest state etc.). The geometry part of the data is stored in the simulation mesh.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the simulation state </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a46e96324d4a20e9938900df58e2bd074">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a521c9a35bb5108d7bb73b7218eaf4479" name="a521c9a35bb5108d7bb73b7218eaf4479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521c9a35bb5108d7bb73b7218eaf4479">&#9670;&#160;</a></span>getSoftBodyFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_flags.html">PxSoftBodyFlags</a> physx::NpSoftBody::getSoftBodyFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the softbody flags. </p>
<dl class="section return"><dt>Returns</dt><dd>The softbody flags </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ad56e6ff5f75fcce761f81155322afc94">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a2265532db39f1c302da481cff9de29f6" name="a2265532db39f1c302da481cff9de29f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2265532db39f1c302da481cff9de29f6">&#9670;&#160;</a></span>getSolverIterationCounts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::getSolverIterationCounts </td>
          <td>(</td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 &amp;&#160;</td>
          <td class="paramname"><em>minVelocityIters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the solver iteration counts. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#af4ec3a30186b37bf9498d0dd599c6257" title="Sets the solver iteration counts for the body.">setSolverIterationCounts()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a801ea01a7236f962fad8fca8adf8321e">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a94518fda442ec806a6f2cc9ce14b6100" name="a94518fda442ec806a6f2cc9ce14b6100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94518fda442ec806a6f2cc9ce14b6100">&#9670;&#160;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structphysx_1_1_px_actor_type.html#aa12d1dbb97bda016f592de47e67e3963">PxActorType::Enum</a> physx::NpSoftBody::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the type of actor. </p>
<dl class="section return"><dt>Returns</dt><dd>The actor type of the actor.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structphysx_1_1_px_actor_type.html" title="Identifies each type of actor.">PxActorType</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_np_actor_template.html">physx::NpActorTemplate&lt; PxSoftBody &gt;</a>.</p>

</div>
</div>
<a id="a798fae12993c6a8bc7e68d9656d30ab1" name="a798fae12993c6a8bc7e68d9656d30ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798fae12993c6a8bc7e68d9656d30ab1">&#9670;&#160;</a></span>getWakeCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PxReal physx::NpSoftBody::getWakeCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the wake counter of the soft body. </p>
<dl class="section return"><dt>Returns</dt><dd>The wake counter of the soft body.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#a50b8a1a0606542f15707b72b0ae215f0" title="Returns true if this soft body is sleeping.">isSleeping()</a> <a class="el" href="classphysx_1_1_np_soft_body.html#a8b9ae97f130dec4ed562db346b0beac5" title="Sets the wake counter for the soft body.">setWakeCounter()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a18445e28706f4fa7f493c707eca4ef22">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a843cec147943460ff245dbaf22b5eade" name="a843cec147943460ff245dbaf22b5eade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843cec147943460ff245dbaf22b5eade">&#9670;&#160;</a></span>getWorldBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classphysx_1_1_px_bounds3.html">PxBounds3</a> physx::NpSoftBody::getWorldBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>inflation</em> = <code>1.01f</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the axis aligned bounding box enclosing the soft body. </p>
<dl class="section note"><dt>Note</dt><dd>It is not allowed to use this method while the simulation is running (except during <a class="el" href="classphysx_1_1_px_scene.html#a9c63e5a0e592a434b8647c98e569aed4" title="Performs collision detection for the scene over elapsedTime.">PxScene::collide()</a>, in <a class="el" href="classphysx_1_1_px_contact_modify_callback.html" title="An interface class that the user can implement in order to modify contact constraints.">PxContactModifyCallback</a> or in contact report callbacks).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inflation</td><td>Scale factor for computed world bounds. Box extents are multiplied by this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The soft body's bounding box.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_px_bounds3.html" title="Class representing 3D range or axis aligned bounding box.">PxBounds3</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_np_actor_template.html">physx::NpActorTemplate&lt; PxSoftBody &gt;</a>.</p>

</div>
</div>
<a id="a50b8a1a0606542f15707b72b0ae215f0" name="a50b8a1a0606542f15707b72b0ae215f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b8a1a0606542f15707b72b0ae215f0">&#9670;&#160;</a></span>isSleeping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool physx::NpSoftBody::isSleeping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this soft body is sleeping. </p>
<p>When an actor does not move for a period of time, it is no longer simulated in order to save time. This state is called sleeping. However, because the object automatically wakes up when it is either touched by an awake object, or a sleep-affecting property is changed by the user, the entire sleep mechanism should be transparent to the user.</p>
<p>A soft body can only go to sleep if all vertices are ready for sleeping. A soft body is guaranteed to be awake if at least one of the following holds:</p>
<ul>
<li>The wake counter is positive (<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#a8b9ae97f130dec4ed562db346b0beac5" title="Sets the wake counter for the soft body.">setWakeCounter()</a>). </dd></dl>
</li>
<li>The velocity of any vertex is above the sleep threshold.</li>
</ul>
<p>If a soft body is sleeping, the following state is guaranteed:</p>
<ul>
<li>The wake counter is zero. </li>
<li>The linear velocity of all vertices is zero.</li>
</ul>
<p>When a soft body gets inserted into a scene, it will be considered asleep if all the points above hold, else it will be treated as awake.</p>
<dl class="section note"><dt>Note</dt><dd>It is invalid to use this method if the soft body has not been added to a scene already.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the soft body is sleeping.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#a50b8a1a0606542f15707b72b0ae215f0" title="Returns true if this soft body is sleeping.">isSleeping()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a131f8915719ffda345077d99118d946f">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a179db5aa51cccbf4fea1a18bdc7cbf21" name="a179db5aa51cccbf4fea1a18bdc7cbf21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179db5aa51cccbf4fea1a18bdc7cbf21">&#9670;&#160;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::readData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a read command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Read operations are scheduled and then flushed in <a class="el" href="classphysx_1_1_px_scene.html#ac9bf1631519e43a0375f821396e246e9" title="Advances the simulation by an elapsedTime time.">PxScene::simulate()</a>. Read operations are known to be finished when <a class="el" href="classphysx_1_1_px_buffer.html#a7f20d43d6afbf29e4ecf3ad01fc69e6a" title="Provides access to internal memory (either device or pinned host memory depending on PxBufferType).">PxBuffer::map()</a> returns.</p>
<p><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1bab6e0e9ada73a0be2a93fdfa5125ceae0" title="Flag to request access to the collision mesh&#39;s positions; read only.">PxSoftBodyData::ePOSITION_INVMASS</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba49e3ff122602577a46962206d9666780" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses.">PxSoftBodyData::eSIM_VELOCITY</a> can be read from the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.</p>
<p>The data to read from the GPU is written to the corresponding cpu buffer that a softbody provides. Those cpu buffers are accessible through <a class="el" href="classphysx_1_1_np_soft_body.html#af781f6fcb1a3195826035444421cd3c8" title="Access to the vertices of the collision mesh on the host.">getPositionInvMassCPU()</a>, <a class="el" href="classphysx_1_1_np_soft_body.html#a16046224da390bf20d6ab5dcce6da341" title="Access to the vertices of the simulation mesh on the host.">getSimPositionInvMassCPU()</a> or <a class="el" href="classphysx_1_1_np_soft_body.html#a2c507cfe064d0217afe06ee8fdbc094c" title="Access to the velocities of the simulation mesh on the host.">getSimVelocityInvMassCPU()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#ae1f73ff72ecda078a7b7d4c0dbddd7b1" title="Issues a write command to the PxSoftBody.">writeData()</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html" title="Identifies input and output buffers for PxSoftBody.">PxSoftBodyData</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a7e154c7880a2f81bbb137bbef4b1a0fd">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a71e544250ed356146de0589947a08a82" name="a71e544250ed356146de0589947a08a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e544250ed356146de0589947a08a82">&#9670;&#160;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::readData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a read command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Read operations are scheduled and then flushed in <a class="el" href="classphysx_1_1_px_scene.html#ac9bf1631519e43a0375f821396e246e9" title="Advances the simulation by an elapsedTime time.">PxScene::simulate()</a>. Read operations are known to be finished when <a class="el" href="classphysx_1_1_px_buffer.html#a7f20d43d6afbf29e4ecf3ad01fc69e6a" title="Provides access to internal memory (either device or pinned host memory depending on PxBufferType).">PxBuffer::map()</a> returns.</p>
<p><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1bab6e0e9ada73a0be2a93fdfa5125ceae0" title="Flag to request access to the collision mesh&#39;s positions; read only.">PxSoftBodyData::ePOSITION_INVMASS</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba49e3ff122602577a46962206d9666780" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses.">PxSoftBodyData::eSIM_VELOCITY</a> can be read from the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>.</p>
<p>The softbody class offers internal cpu buffers that can be used to hold the data. The cpu buffers are accessible through <a class="el" href="classphysx_1_1_np_soft_body.html#af781f6fcb1a3195826035444421cd3c8" title="Access to the vertices of the collision mesh on the host.">getPositionInvMassCPU()</a>, <a class="el" href="classphysx_1_1_np_soft_body.html#a16046224da390bf20d6ab5dcce6da341" title="Access to the vertices of the simulation mesh on the host.">getSimPositionInvMassCPU()</a> and <a class="el" href="classphysx_1_1_np_soft_body.html#a2c507cfe064d0217afe06ee8fdbc094c" title="Access to the velocities of the simulation mesh on the host.">getSimVelocityInvMassCPU()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Specifies buffer to which data is written to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#ae1f73ff72ecda078a7b7d4c0dbddd7b1" title="Issues a write command to the PxSoftBody.">writeData()</a>, <a class="el" href="classphysx_1_1_px_buffer.html" title="Buffer for delayed bulk read and write operations supporting host and GPU device memory spaces.">PxBuffer</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html" title="Identifies input and output buffers for PxSoftBody.">PxSoftBodyData</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a977c8932888461538bba4f33395c650c">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a6fecbe185a5f96a553e3ecc5d3d22586" name="a6fecbe185a5f96a553e3ecc5d3d22586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fecbe185a5f96a553e3ecc5d3d22586">&#9670;&#160;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the softbody. </p>
<p>Releases the softbody and frees its resources. </p>

<p>Implements <a class="el" href="classphysx_1_1_np_actor_template.html">physx::NpActorTemplate&lt; PxSoftBody &gt;</a>.</p>

</div>
</div>
<a id="a65ccd5efbe37a02b33020bf526fbb879" name="a65ccd5efbe37a02b33020bf526fbb879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ccd5efbe37a02b33020bf526fbb879">&#9670;&#160;</a></span>removeClothAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::removeClothAttachment </td>
          <td>(</td>
          <td class="paramtype">PxFEMCloth *&#160;</td>
          <td class="paramname"><em>cloth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases an attachment between a cloth and a soft body. Be aware that destroying the cloth before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the cloth does not. </p>
<p>This method removes a previously-created attachment between a point inside a collision mesh tetrahedron and a point inside a cloth mesh.</p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloth</td><td>The cloth actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Index that identifies the attachment. This handle gets returned by the addClothAttachment when the attachment is created </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#acb0e444fad640b513acc99f42f7a6f56">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a25d0e44122f54cf956aa00e4eed4637c" name="a25d0e44122f54cf956aa00e4eed4637c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d0e44122f54cf956aa00e4eed4637c">&#9670;&#160;</a></span>removeClothFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::removeClothFilter </td>
          <td>(</td>
          <td class="paramtype">PxFEMCloth *&#160;</td>
          <td class="paramname"><em>cloth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>triIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes collision filter between a tetrahedron in a soft body and a triangle in a cloth. </p>
<dl class="section warning"><dt>Warning</dt><dd>Feature under development, only for internal usage.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cloth</td><td>The cloth actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triIdx</td><td>The index of the triangle in the cloth mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of the tetrahedron in the softbody's collision mesh to be filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a253209fa24469ac27d7ddf9109203acd">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a1d1a90aaef852b165a94d5d5a19601fc" name="a1d1a90aaef852b165a94d5d5a19601fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1a90aaef852b165a94d5d5a19601fc">&#9670;&#160;</a></span>removeParticleAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::removeParticleAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an attachment between a particle and a soft body. Be aware that destroying the particle system before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the particle system does not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Index that identifies the attachment. This handle gets returned by the addParticleAttachment when the attachment is created </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#aab99896beb748035721e2475893d3bfd">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a3bd1fb08f0f7069e09f37be5607df3ac" name="a3bd1fb08f0f7069e09f37be5607df3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd1fb08f0f7069e09f37be5607df3ac">&#9670;&#160;</a></span>removeParticleFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::removeParticleFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_p_b_d_particle_system.html">PxPBDParticleSystem</a> *&#160;</td>
          <td class="paramname"><em>particlesystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classphysx_1_1_px_particle_buffer.html">PxParticleBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>particleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a collision filter between a particle and a tetrahedron in the soft body's collision mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">particlesystem</td><td>The particle system used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The <a class="el" href="classphysx_1_1_px_particle_buffer.html" title="The shared base class for all particle buffers, can be instantiated directly to simulate granular and...">PxParticleBuffer</a> to which the particle belongs to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">particleId</td><td>The particle whose collisions with the tetrahedron in the soft body are filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetId</td><td>The tetrahedron in the soft body is filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a6e58d78320439bfa33d1806dcc172ed5">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a2af8ad423b1fb1a40f820563ee491d72" name="a2af8ad423b1fb1a40f820563ee491d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af8ad423b1fb1a40f820563ee491d72">&#9670;&#160;</a></span>removeRigidAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::removeRigidAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases a rigid attachment between a soft body and a rigid body. Be aware that destroying the rigid body before destroying the attachment is illegal and may cause a crash. The soft body keeps track of these attachments but the rigid body does not. </p>
<p>This method removes a previously-created attachment between a vertex of the soft body collision mesh and the rigid body.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the attachment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Index that identifies the attachment. This handle gets returned by the addRigidAttachment when the attachment is created </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a3807a77c6ce9fc27b472a1f4093bcb7e">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a4e5d98f6e8b4e4e262eb3210f5e4e91d" name="a4e5d98f6e8b4e4e262eb3210f5e4e91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5d98f6e8b4e4e262eb3210f5e4e91d">&#9670;&#160;</a></span>removeRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::removeRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>vertId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a collision filter between a vertex in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for the collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertId</td><td>The index of a vertex in the softbody's collision mesh whose collisions with the rigid body are filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ae8fa0a9aa318e559478c127e771cb86a">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a5c47f0e7a98b43272211aa15c11778ef" name="a5c47f0e7a98b43272211aa15c11778ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c47f0e7a98b43272211aa15c11778ef">&#9670;&#160;</a></span>removeSoftBodyAttachment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::removeSoftBodyAttachment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>softbody0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases an attachment between a soft body and the other soft body. Be aware that destroying the soft body before destroying the attachment is illegal and may cause a crash. </p>
<p>This method removes a previously-created attachment between a point inside a tetrahedron of the collision mesh to a point in another soft body's tetrahedron collision mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">softbody0</td><td>The softbody actor used for the attachment. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>Index that identifies the attachment. This handle gets returned by the addSoftBodyAttachment when the attachment is created. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#aee6acf80193100b2713a0e58229611b5">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="ad584e5d0a8e6e2a3c6e26ff97123948f" name="ad584e5d0a8e6e2a3c6e26ff97123948f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad584e5d0a8e6e2a3c6e26ff97123948f">&#9670;&#160;</a></span>removeSoftBodyFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::removeSoftBodyFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>otherTetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes collision filter between a tetrahedron in a soft body and a tetrahedron in other soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIdx</td><td>The index of the other tetrahedron in the other softbody's collision mesh whose collision with the tetrahedron with the soft body is filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx1</td><td>The index of the tetrahedron in the softbody's collision mesh whose collision with the other tetrahedron with the other soft body is filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ab4c8c3660b669a7bb65226e816248886">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="ac4de9c04860fb81f471f500a96e90e6f" name="ac4de9c04860fb81f471f500a96e90e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4de9c04860fb81f471f500a96e90e6f">&#9670;&#160;</a></span>removeSoftBodyFilters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::removeSoftBodyFilters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_soft_body.html">PxSoftBody</a> *&#160;</td>
          <td class="paramname"><em>otherSoftBody</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 *&#160;</td>
          <td class="paramname"><em>otherTetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32 *&#160;</td>
          <td class="paramname"><em>tetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIndicesSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes collision filters between a tetrahedron in a soft body with another soft body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherSoftBody</td><td>The other soft body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">otherTetIndices</td><td>The indices of the tetrahedron in the other softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndices</td><td>The indices of the tetrahedron of the softbody's collision mesh to be filtered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIndicesSize</td><td>The size of tetIndices. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ae814d96255b19f85fdb33043bb862fba">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="af73645316600c85639db4a150eb91adf" name="af73645316600c85639db4a150eb91adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73645316600c85639db4a150eb91adf">&#9670;&#160;</a></span>removeTetRigidFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::removeTetRigidFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_rigid_actor.html">PxRigidActor</a> *&#160;</td>
          <td class="paramname"><em>actor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>tetIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes collision filter between a tetrahedron in a soft body and a rigid body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">actor</td><td>The rigid body actor used for collision filter </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetIdx</td><td>The index of a tetrahedron in the softbody's collision mesh whose collisions with the rigid body is filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ac2cc13579616f7f83ff7d9eb046dfc44">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a8c88cf7b477783f4a3e5555b6d30eaf1" name="a8c88cf7b477783f4a3e5555b6d30eaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c88cf7b477783f4a3e5555b6d30eaf1">&#9670;&#160;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void physx::NpSoftBody::setName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a name string for the object that can be retrieved with <a class="el" href="classphysx_1_1_np_soft_body.html#a45ba51d0ec2640598cc883d02575feae" title="Retrieves the name string set with setName().">getName()</a>. </p>
<p>This is for debugging and is not used by the SDK. The string is not copied by the SDK, only the pointer is stored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>String to set the objects name to.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Default:</b> NULL</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#a45ba51d0ec2640598cc883d02575feae" title="Retrieves the name string set with setName().">getName()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classphysx_1_1_np_actor_template.html">physx::NpActorTemplate&lt; PxSoftBody &gt;</a>.</p>

</div>
</div>
<a id="a4750f90937bcf4c2d3d38da3405adaf5" name="a4750f90937bcf4c2d3d38da3405adaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4750f90937bcf4c2d3d38da3405adaf5">&#9670;&#160;</a></span>setParameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::setParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structphysx_1_1_px_f_e_m_parameters.html">PxFEMParameters</a>&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set parameter for FEM internal solve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>The FEM parameters </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#aac90eaf62454ee3a35d824a5ac3668e4">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="ab35f8ee26d9a063e75ee27da85ab9075" name="ab35f8ee26d9a063e75ee27da85ab9075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35f8ee26d9a063e75ee27da85ab9075">&#9670;&#160;</a></span>setSoftBodyFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::setSoftBodyFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_soft_body_flag.html#ad392f0ca084f5a0ec7f110b8c2476315">PxSoftBodyFlag::Enum</a>&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a single softbody flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>The flag to set or clear </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The new state of the flag </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a43ba0e4e924c32131b00ba0d15ac5599">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a892116fcb446822ea526c0468d9afeed" name="a892116fcb446822ea526c0468d9afeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892116fcb446822ea526c0468d9afeed">&#9670;&#160;</a></span>setSoftBodyFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::setSoftBodyFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_flags.html">PxSoftBodyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the softbody flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>The new softbody flags </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#add9ef79efcb2011b47bf133769535c64">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="af4ec3a30186b37bf9498d0dd599c6257" name="af4ec3a30186b37bf9498d0dd599c6257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ec3a30186b37bf9498d0dd599c6257">&#9670;&#160;</a></span>setSolverIterationCounts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::setSolverIterationCounts </td>
          <td>(</td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>minPositionIters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PxU32&#160;</td>
          <td class="paramname"><em>minVelocityIters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the solver iteration counts for the body. </p>
<p>The solver iteration count determines how accurately deformation and contacts are resolved. If you are having trouble with softbodies that are not as stiff as they should be, then setting a higher position iteration count may improve the behavior.</p>
<p>If intersecting bodies are being depenetrated too violently, increase the number of velocity iterations.</p>
<p><b>Default:</b> 4 position iterations, 1 velocity iteration</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minPositionIters</td><td>Minimal number of position iterations the solver should perform for this body. <b>Range:</b> [1,255] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minVelocityIters</td><td>Minimal number of velocity iterations the solver should perform for this body. <b>Range:</b> [1,255]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#a2265532db39f1c302da481cff9de29f6" title="Retrieves the solver iteration counts.">getSolverIterationCounts()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ab99548c514e09862494287eee688b0a1">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a8b9ae97f130dec4ed562db346b0beac5" name="a8b9ae97f130dec4ed562db346b0beac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9ae97f130dec4ed562db346b0beac5">&#9670;&#160;</a></span>setWakeCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::setWakeCounter </td>
          <td>(</td>
          <td class="paramtype">PxReal&#160;</td>
          <td class="paramname"><em>wakeCounterValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the wake counter for the soft body. </p>
<p>The wake counter value determines the minimum amount of time until the soft body can be put to sleep. Please note that a soft body will not be put to sleep if any vertex velocity is above the specified threshold or if other awake objects are touching it.</p>
<dl class="section note"><dt>Note</dt><dd>Passing in a positive value will wake the soft body up automatically.</dd></dl>
<p><b>Default:</b> 0.4 (which corresponds to 20 frames for a time step of 0.02)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wakeCounterValue</td><td>Wake counter value. <b>Range:</b> [0, PX_MAX_F32)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#a50b8a1a0606542f15707b72b0ae215f0" title="Returns true if this soft body is sleeping.">isSleeping()</a> <a class="el" href="classphysx_1_1_np_soft_body.html#a798fae12993c6a8bc7e68d9656d30ab1" title="Returns the wake counter of the soft body.">getWakeCounter()</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a478d801eed43606ac4e06b48c883e137">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="a9aca1e67e9fdd3c0890a065ddd6974dc" name="a9aca1e67e9fdd3c0890a065ddd6974dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aca1e67e9fdd3c0890a065ddd6974dc">&#9670;&#160;</a></span>writeData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a write command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Write operations are scheduled and then flushed in <a class="el" href="classphysx_1_1_px_scene.html#ac9bf1631519e43a0375f821396e246e9" title="Advances the simulation by an elapsedTime time.">PxScene::simulate()</a>. Write operations are known to be finished when PxScene::fetchResult() returns.</p>
<p><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba49e3ff122602577a46962206d9666780" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses.">PxSoftBodyData::eSIM_VELOCITY</a> can be written to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1bab6e0e9ada73a0be2a93fdfa5125ceae0" title="Flag to request access to the collision mesh&#39;s positions; read only.">PxSoftBodyData::ePOSITION_INVMASS</a> is read only, because the collision-mesh vertices are driven by the simulation-mesh vertices, which can be written to with <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a>.</p>
<p>The data to write to the GPU is taken from the corresponding cpu buffer that a softbody provides. Those cpu buffers are accessible through <a class="el" href="classphysx_1_1_np_soft_body.html#af781f6fcb1a3195826035444421cd3c8" title="Access to the vertices of the collision mesh on the host.">getPositionInvMassCPU()</a>, <a class="el" href="classphysx_1_1_np_soft_body.html#a16046224da390bf20d6ab5dcce6da341" title="Access to the vertices of the simulation mesh on the host.">getSimPositionInvMassCPU()</a> or <a class="el" href="classphysx_1_1_np_soft_body.html#a2c507cfe064d0217afe06ee8fdbc094c" title="Access to the velocities of the simulation mesh on the host.">getSimVelocityInvMassCPU()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#a71e544250ed356146de0589947a08a82" title="Issues a read command to the PxSoftBody.">readData()</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html" title="Identifies input and output buffers for PxSoftBody.">PxSoftBodyData</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#ad7fccbe8185a375cf42f9362d59f9748">physx::PxSoftBody</a>.</p>

</div>
</div>
<a id="ae1f73ff72ecda078a7b7d4c0dbddd7b1" name="ae1f73ff72ecda078a7b7d4c0dbddd7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f73ff72ecda078a7b7d4c0dbddd7b1">&#9670;&#160;</a></span>writeData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void physx::NpSoftBody::writeData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1b">PxSoftBodyData::Enum</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classphysx_1_1_px_buffer.html">PxBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Issues a write command to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. </p>
<p>Write operations are scheduled and then flushed in <a class="el" href="classphysx_1_1_px_scene.html#ac9bf1631519e43a0375f821396e246e9" title="Advances the simulation by an elapsedTime time.">PxScene::simulate()</a>. Write operations are known to be finished when PxScene::fetchResult() returns.</p>
<p><a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a> and <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba49e3ff122602577a46962206d9666780" title="Flag to request access to the simulation mesh&#39;s velocities and inverse masses.">PxSoftBodyData::eSIM_VELOCITY</a> can be written to the <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a>. <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1bab6e0e9ada73a0be2a93fdfa5125ceae0" title="Flag to request access to the collision mesh&#39;s positions; read only.">PxSoftBodyData::ePOSITION_INVMASS</a> is read only, because the collision-mesh vertices are driven by the simulation-mesh vertices, which can be written to with <a class="el" href="structphysx_1_1_px_soft_body_data.html#af8e5b06e3580dea390876d5d7bec4a1ba325833042ca5c8043c3f43ccbea6874b" title="Flag to request access to the simulation mesh&#39;s positions and inverse masses.">PxSoftBodyData::eSIM_POSITION_INVMASS</a>.</p>
<p>The softbody class offers internal cpu buffers that can be used to hold the data. The cpu buffers are accessible through <a class="el" href="classphysx_1_1_np_soft_body.html#af781f6fcb1a3195826035444421cd3c8" title="Access to the vertices of the collision mesh on the host.">getPositionInvMassCPU()</a>, <a class="el" href="classphysx_1_1_np_soft_body.html#a16046224da390bf20d6ab5dcce6da341" title="Access to the vertices of the simulation mesh on the host.">getSimPositionInvMassCPU()</a> and <a class="el" href="classphysx_1_1_np_soft_body.html#a2c507cfe064d0217afe06ee8fdbc094c" title="Access to the velocities of the simulation mesh on the host.">getSimVelocityInvMassCPU()</a>. Consider to use the <a class="el" href="classphysx_1_1_px_soft_body_ext.html#a7d38f3baba9f41a471c85725dcef03b4" title="Uploads prepared SoftBody data to the GPU. It ensures that the embedded collision mesh matches the si...">PxSoftBodyExt::commit()</a> extension method if all buffers should get written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Specifies which <a class="el" href="classphysx_1_1_px_soft_body.html" title="Represents a FEM softbody including everything to calculate its definition like geometry and material...">PxSoftBody</a> data to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Specifies buffer from which data is read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush</td><td>If set to true the command gets executed immediately, otherwise it will get executed the next time copy commands are flushed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classphysx_1_1_np_soft_body.html#a71e544250ed356146de0589947a08a82" title="Issues a read command to the PxSoftBody.">readData()</a>, <a class="el" href="classphysx_1_1_px_buffer.html" title="Buffer for delayed bulk read and write operations supporting host and GPU device memory spaces.">PxBuffer</a>, <a class="el" href="structphysx_1_1_px_soft_body_data.html" title="Identifies input and output buffers for PxSoftBody.">PxSoftBodyData</a>, <a class="el" href="classphysx_1_1_px_soft_body_ext.html#a7d38f3baba9f41a471c85725dcef03b4" title="Uploads prepared SoftBody data to the GPU. It ensures that the embedded collision mesh matches the si...">PxSoftBodyExt::commit</a> </dd></dl>

<p>Implements <a class="el" href="classphysx_1_1_px_soft_body.html#a3c79d6afd0c16411d2e45a5f1cc56252">physx::PxSoftBody</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>source/physx/src/<a class="el" href="_np_soft_body_8h_source.html">NpSoftBody.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacephysx.html">physx</a></li><li class="navelem"><a class="el" href="classphysx_1_1_np_soft_body.html">NpSoftBody</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
